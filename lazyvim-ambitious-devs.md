# [第一章：介绍与安装](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_introduction_and_installation)

这本书是为那些被模态编辑强大功能所吸引，却因为即便是入门教程中也充斥着大量配置内容而感到望而生畏或索然无味的开发者们所写。

我猜你可能是一位 Visual Studio Code 用户（这确实是一个很棒的编辑器，我也用过几年），当然你也可能是从其他各种集成开发环境和代码编辑器转向模态编辑的。你可能听说过 Vim，现在想要尝试一下。

## [1.1. 为什么选择 Vim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_why_vim)

Vim 有着非常悠久的历史。它创建于90年代早期，是对（更加）古老的 Vi 编辑器（创建于70年代）的改进。"Vim" 这个名字实际上是 "Vi, improved"（Vi的改进版）的缩写。而它的前身 Vi，则是 "Visual"（可视化）的简称，因为它是对更早期（1971年）的一个名为 ed 的非可视化行编辑器的改进。

> 有趣的是，ed 这个编辑器在现代 Unix 系统中仍然可用。如果你使用 MacOS 或 Linux 环境，你很可能可以在任何终端中输入 ed 来访问它。（如果你不小心尝试了的话，按 Control-D 可以退出）。现在你对 ed 的了解和我一样多了，相信我，你也不会想知道更多了。

你可能还熟悉 ed 的另一个分支版本：sed（流编辑器）。直到今天，它仍然被用于在 shell 管道中修改文本。

ed 命令还被扩展出了另一个行编辑器，叫做 ex，这个编辑器现在基本不再单独使用了，但它作为 Vim 的一个子模式被（广泛地）使用着。事实上，如果你安装了 Neovim 并在命令行中输入 ex，你会得到一个功能非常受限的 Neovim 实例，它只支持 ex 命令。

这确实是一个相当复杂的家族树，但仅凭血统并不能很好地预示质量，正如任何第四代显贵都能证明的那样。

使用任何一个编辑器都有很多原因，但对于 Vim 来说，以下几点尤为突出：

- 健康效益

  这对我来说是最重要的一点。在我职业生涯早期，我大量使用 Vim，不过和许多开发者一样，在 2015 年 VS Code 发布后就转向了它。我在键盘前花费了大量时间，到了 2020 年，我被重复性劳损（RSI）折磨得如此严重，以至于我花了六个月的时间完全靠语音编程（一篇关于这个话题的博客文章让我获得了超出预期的关注）。一个朋友建议我重新转向模态编辑，这对我来说产生了巨大的改变。绝大多数 Vim 按键操作不需要用同一只手同时按住多个键，这极大地减轻了腕管综合症的困扰。

- 性能表现

  大多数 IDE 都有某种"vi 模拟"层或插件，让你可以在不完全切换到新编辑器的情况下获得一些模态编辑的健康效益。但是等待 VS Code 启动并加载所有你熟悉和喜爱的扩展已经成为许多人的一种冥想练习（或者是重返社交媒体刷屏的机会）。相比之下，当我加载我的 LazyVim 配置时，它会很贴心地告诉我加载所需的时间：56.98 毫秒。对于我这个反应迟钝的人类来说，这简直是瞬间完成。

- 开发效率

  这是一个有争议且主观的话题。工具的好坏取决于使用者的水平，我当然知道有一些优秀的程序员能够熟练运用他们的 VS Code、Emacs 或 JetBrains 配置。尽管如此，我真的相信一个精心调教的 Vim 配置可以超越它们所有。

- 开放生态系统

  自从 Nadella 掌舵以来，我非常敬佩微软对开源软件的态度，但 VS Code 正在显示出越来越多的专有锁定迹象（尤其是在其 AI 集成方面）。相比之下，Neovim 生态系统是一个充满活力的开放社区，每周都会出现一些在 VS Code 中永远不会尝试的创新插件。

## [1.2. 为什么特别选择 Neovim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_why_neovim_specifically)

如果你决定使用 Vim，你很快就会发现有两个现代变体：Vim 和 Neovim。它们都是 90 年代原始开源 Vim 代码的直系后裔。Neovim 于 2014 年从 Vim 分支出来，其愿景是重构并现代化其代码库和功能集。

这两者都在积极维护中，且都有潜力让人感觉精致现代，尽管要实现这种潜力需要一些配置。它们各自都拥有非常强大的插件生态系统，但 Neovim 有一个杀手级特性：除了其兄弟版本使用的原生 VimScript 外，它还引入了 Lua 编程语言用于插件开发（和配置）。

仅就 Lua 本身而言，并不会使 Neovim 本质上比 Vim 更好。然而，虽然大多数 Vim 插件也能在 Neovim 上运行，但反过来却并不总是如此，而且有一些同类最佳的 Lua 插件只能在 Neovim 上运行。

就本书而言，你的选择已经替你做好了：本书所讲的 LazyVim 发行版只能在 Neovim 上运行。

## [1.3. LazyVim 简介](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_introducing_lazyvim)

Vim 和 Neovim 的主要缺点是，虽然它们有能力提供与任何其他 IDE 相同（或更好）的现代编辑体验，但它们的初始状态并非如此。Vim 一直保持着与过时的 vi 工具的兼容传统，而 Neovim 也只是略微偏离了这一传统。当你首次安装 Neovim 时，你得到的是一个相当朴素的代码编辑体验。

2020 年当我从习惯了 VS Code 带来的出色功能后重新转向 Vim 时，我花了两周时间才让配置达到我想要的状态，之后的几个月里我还在不断调整。最终的配置包含了大约 300 行 Vimscript，后来我将其移植为约 250 行 Lua 代码。说实话，我一向热衷于定制，我的 VS Code 配置实际上比这两者都要长！但我也得承认，VS Code 的开箱即用体验确实要好得多。

我研究了几个所谓的 Neovim "发行版"（预配置安装包）。我不会详细比较，但 LazyVim 是目前最出色的赢家，主要是因为它在开箱即用的简单体验和相对容易的定制配置之间取得了平衡。

需要明确的是，LazyVim 就是 Vim。编辑体验是完全一致的。它不像 Neovim 那样是 Vim 的新迭代或版本。相反，LazyVim 是一种理念；它始于对现代开发最佳插件配置的共识，以及让这些插件能够很好地协同工作的配置（让不同插件的键位绑定不相互冲突是手动管理编辑器配置时的主要痛点之一）。

但如果你在使用 LazyVim 时抱着这样的心态：这种体验将比你之前使用过的任何编辑体验都要好，并且接受你需要重新训练一些键盘肌肉记忆，你会发现它的设计非常周到。根据我的经验，这正是 2020 年代模态编辑体验应有的样子。

## [1.4. 选择终端](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_choosing_a_terminal)

如果你已经看到这里，你可能觉得已经准备好安装 Neovim 了。实际上，你还有一个决定要做。

Neovim 可以在许多不同的环境中运行（你甚至可以在 Visual Studio Code 内运行它！）默认情况下它是一个终端程序，但也有大量的图形界面（GUI）可用。我几乎尝试过所有这些界面，老实说，我认为它们相比于直接在终端中运行 Neovim 并没有任何本质上的优势。

我们将在本书后面简要讨论如何将 Neovim 连接到几个 GUI，但对于入门来说，我建议在终端中运行 Neovim。具体来说，是一个非常好的终端。

要获得最佳的 Vim 编辑体验，你需要一个 GPU 加速的终端。这是什么意思？基本上就是你将使用设计用于渲染照片级真实视频的芯片来渲染源代码。这听起来就像用它来做人工智能一样合理，对吧？

你需要自行研究以下选项，所以可以请教你喜欢的搜索引擎或当下流行的 AI 聊天机器人来帮你决定：

- Kitty Terminal

  这是我个人的首选。我发现它文档完善、配置简单且功能齐全。

- Alacritty

  可能是原始速度方面的赢家，但配置比较笨拙，功能也较少。

- Wezterm

  有一些非常巧妙的功能，但我发现文档不够完善，而且在使某些功能正常工作时遇到了困难。

- Windows Terminal

  如果你是 Windows 用户，它确实声称支持 GPU 加速，不过我发现 Neovim 在其中偶尔会出现无响应的情况。

- Windows Terminal

  如果你已经是 Warp 的用户而且离不开它，Neovim 也可以在其中运行。我发现使用体验有点卡顿，而且我不太喜欢 Warp 的外观和感觉（以及需要登录才能使用的事实）。

> （ethan）我在公司使用的是 tabby 或 MobaXterm。因为公司的电脑性能太垃了，使用上述的终端软件，可能会很卡。Alacritty 虽然不会卡，但是他对 Windows 的支持不太友好。

所以安装其中的一个或多个，直到你找到一个你喜欢的。如果你愿意，你也可以使用其他终端模拟器。你可能甚至不会注意到体验有什么不足，但我可以保证，如果你之后切换到 GPU 加速的体验，你会注意到这种改进。

## [1.5. 设置终端字体](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_setting_up_your_terminal_font)

LazyVim 及其插件在终端中看起来非常漂亮，你几乎不会相信它们不是 GUI 应用程序。为了实现这一点，它们依赖于包含大量编程相关字形的特殊字体。最显著的是，这让你可以看到代表你打开的文件类型的图标，同时还能在终端中提供漂亮的边框和类似窗口的行为。

要获得最佳的 LazyVim 体验，你需要安装这些特殊字体中的一个，并配置你的终端来使用它。实际上，即使你不是重度 Neovim 用户，你也应该在终端中使用这些字体。许多现代终端应用（这说法听起来有点怪，是吧？）在安装了这些字体后都会看起来更好。

访问 Nerd Fonts 网站以获取更多信息。如果你使用 Kitty，你只需要安装 NerdFontsSymbolsOnly 字体，如果在你配置的等宽字体中找不到某些符号，它会自动从该字体中提取符号。对于其他终端，你可能需要按照 Nerd Fonts 网站上讨论的那样安装和配置一个"打补丁的"字体。有很多选择可供选择。

你可以从许多最流行的编程字体中进行选择。下载和安装它们在很大程度上取决于操作系统，所以我就让 Nerd Fonts 网站上的指南来为你解释这个过程。

## [1.6. 安装 Neovim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_neovim)

Neovim 几乎可以在任何能安装软件的地方运行，它只依赖标准的系统依赖项。主要的问题是，无论你使用哪种操作系统，你都有太多的选择！

你可以访问 Neovim 主页并点击"Install Now"按钮，从 Neovim 开发者那里获取针对你所选择（或不得不使用）的操作系统的最新安装说明。

### [1.6.1. 我应该安装哪个版本？](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_which_version_should_i_install)

与其发布周期相比，Neovim 的开发进度非常快，所以人们经常使用最新的每日构建版本。我很少在从 Github 主分支构建的版本中遇到 bug，所以通常来说是安全的。我通常在新的稳定版本发布时使用它，然后当某个插件更新说"如果你使用 Neovim 每日构建版本，这里有个很酷的新功能"时，我就会改为安装最新的 Neovim 构建版本。

我建议现在先从最新的稳定版 Neovim 开始，在写作本文时是 0.10.0 版本。如果可能的话，避免使用更老的版本。LazyVim 确实倾向于添加来自每日发布版本的功能，所以如果你开始像我一样对这个发行版感到兴奋，切换到预发布版本将是一个很自然的进展。

### [1.6.2. Windows](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_windows)

在 Windows 上，我建议使用 Windows Subsystem for Linux（WSL）并在其中进行所有开发。WSL 远超出了本书的范围，但微软和许多在线教程都对其有很好的文档说明。一旦你选择了一个兼容 WSL 的 Linux 发行版，设置好并在你选择的终端中运行它，你就可以使用下面的 Linux 安装说明来安装 Neovim。

如果你有理由或偏好在原生 Windows 上开发，最简单的方法是从 GitHub 上 neovim/neovim 仓库的 Releases 部分获取 MSI 安装程序。

如果你已经在使用 Winget、Chocolatey 或 Scoop 来管理你的 Windows 机器上的包，它们各自都有 Neovim 包。

请注意，如果你使用 Windows 而不使用 WSL，你还需要安装一个 C 编译器才能获得 treesitter 支持（这基本上意味着更好的语法高亮和代码导航支持）。遗憾的是，这不是一个简单的任务。这在 nvim-treesitter/nvim-treesitter GitHub 仓库中有文档说明，所以我在这里不会详细介绍。

### [1.6.3. MacOS](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_macos)

在 MacOS 上，大多数开发者都使用 Homebrew，所以如果你还没有安装它，我建议按照 brew.sh 上的说明进行安装。

一旦你安装并运行了 brew，使用命令 brew install neovim 就可以安装 Neovim。

如果你想追求最新特性，brew install --HEAD neovim 将安装最新的 Neovim 每日构建版本，这个版本可能是稳定的，但不能保证。

我发现相比其他 MacOS 上安装 Neovim 的选项，brew 的体验要友好得多，所以如果你还不是 Homebrew 用户，我强烈建议设置它。随着我们在 LazyVim 的旅程中深入，你会想要安装其他开源工具，而 brew 将是获取所有这些工具最简单的方式。

如果你不想使用 Homebrew，事情就会有点烦人。Neovim 开发团队并不维护 MacOS 安装程序，所以你必须下载一个 tarball 并解压它，然后从系统路径中的某个位置链接到二进制文件。如果你不知道这些是什么意思，说实话，还是用 Homebrew 吧，它更简单！

### [1.6.4. Linux](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_linux)

如果在你的发行版的默认包管理器中找不到 Neovim，那你用的确实是一个非常特别的 Linux 发行版！

所以只需运行 sudo pacman -S neovim、sudo apt install neovim、sudo dnf install neovim，或者使用你偏好的其他特殊包管理器的相应命令即可。

不过，一些发行版附带的 Neovim 版本可能非常过时。如果你想要每日构建版本，你可以在 neovim/neovim GitHub Releases 页面找到相关说明，或者需要深入研究你的发行版的文档。

在不太可能出现的情况下，如果你的 Linux 发行版没有自带 C 编译器，你还需要安装一个。对于大多数发行版来说，只需安装 gcc 包就可以了。

## [1.7. 尝试原始的 Neovim（如果你敢的话）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_try_neovim_raw_if_you_dare)

安装完 Neovim 后，你可以通过在之前几节安装的终端中简单地输入 nvim（或者 nvim <文件名> 来打开特定文件）来尝试使用它。如果 Neovim 安装正确并且在你的系统路径中，你会看到一个视觉上不太吸引人的编辑器，看起来就像是从 90 年代的某个程序分叉出来的，而且刻意让它看起来像是 70 年代写的。

所以，至少它很诚实？

不幸的是，你现在被困住了。为了省去你疯狂地在 Google 上搜索"如何退出 Vim"，这里告诉你退出的命令是：先按 Escape，然后输入三个字符 :q!，最后按 Enter。因此，整个操作序列是 <Escape> <冒号> q <感叹号> <Enter>。

说真的，"如何退出 Vim"是 Google 上"如何退出..."这个搜索词的前三个自动补全之一。显然只有三星电视和 MacOS 的全屏模式比它更难退出！在我们深入了解 vim 的思维模型和命令模式后，我们就会明白为什么这个咒语是有效的。

> 如果你想的话，可以运行命令 <Escape>:Tutor<Enter> （如果失败的话，可以在终端使用命令：vimtutor）来打开一个交互式文本文件，你可以在学习 Neovim 基础知识的同时阅读和编辑它。我确实建议你在某个时候完成这个教程，但现在可能不是最佳时机。在 Vim 教程中很多"正常"的操作在使用 LazyVim 时都是不同的（而且更好！）。本书的其余部分并不假设你已经完成了这个教程。

## [1.8. 安装 LazyVim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_lazyvim)

现在你已经安装并运行了 Neovim，让我们来配置它，让它看起来像是这个世纪开发的产品。

安装 LazyVim 需要使用一些 git 操作。既然你在阅读这本书，我假设你是一名软件开发者，因此对 git 有一定的了解。

在不同的操作系统上安装 LazyVim 的 git 命令基本相同，只是路径和环境变量略有不同。

### [1.8.1. 从零开始](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_start_with_a_clean_slate)

> 如果你已经有了 Neovim 配置，并且想在不丢失现有配置的情况下尝试 LazyVim，可以设置环境变量 NVIM_APPNAME=lazyvim。直接跳到下面的"克隆启动模板"部分，然后克隆到 ~/.config/lazyvim 目录而不是 ~/.config/nvim。如果你想让这些更改永久生效，可以在你的 shell 启动文件中设置 NVIM_APPNAME，或者将 lazyvim 配置文件夹重命名为 nvim。

首先，删除或备份所有现有的 Neovim 状态。如果你以前从未使用过 Neovim，这一步基本上是可选的，但我建议确保以下目录已被删除或移动：

**清理：适用于 WSL 的 Windows、MacOS 和 Linux**
删除或备份（使用 mv 而不是 rm）以下目录：

```bash
$ rm -rf ~/.config/nvim
$ rm -rf ~/.local/share/nvim
$ rm -rf ~/.local/state/nvim
$ rm -rf ~/.cache/nvim
```

**清理：不使用 WSL 的 Windows**
在 Windows 上，配置和数据文件夹的位置与 Unix 系统略有不同，但基本思路是一样的。只需使用 Powershell 命令替代 Unix 核心工具：

```bash
$ Move-Item $env:LOCALAPPDATA\nvim $env:LOCALAPPDATA\nvim.bak
$ Move-Item $env:LOCALAPPDATA\nvim-data $env:LOCALAPPDATA\nvim-data.bak
```

### [1.8.2. 安装其他推荐的依赖项](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_other_recommended_dependencies)

我强烈建议安装 lazygit、ripgrep 和 fd，LazyVim 使用这些工具来提供增强的 git、字符串搜索和文件搜索功能。大多数操作系统的包管理器都可以轻松安装这些工具。你可以在它们各自的 GitHub 仓库中找到更具体的安装说明：

- [jesseduffield/lazygit](https://github.com/jesseduffield/lazygit)
- [BurntSushi/ripgrep](https://github.com/BurntSushi/ripgrep)
- [sharkdp/fd](https://github.com/sharkdp/fd)

### [1.8.3. 克隆 LazyVim 启动模板](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_clone_the_lazyvim_starter_template)

你将使用 git clone 命令下载启动模板并将其复制到 Neovim 的用户配置目录中，然后删除 .git 文件夹。

这个启动模板就是字面意思：一个起点。所以你永远不需要从这个仓库拉取更改。相反，LazyVim 会自己管理自身和所有插件的更新。启动模板之所以是一个 git 仓库，仅仅是因为这样对 LazyVim 维护者来说更容易维护。从你的角度来看，你只是在下载仓库的当前状态，不需要知道它的过去或未来状态。

**克隆启动仓库：WSL、MacOS 和 Linux**
在 Unix 系统上，使用以下命令：

```bash
$ git clone https://github.com/LazyVim/starter ~/.config/nvim
$ rm -rf ~/.config/nvim/.git
```

**克隆启动仓库：不使用 WSL 的 Windows**
在原生 Windows 上，使用以下命令：

```bash
$ git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA\nvim
$ Remove-Item $env:LOCALAPPDATA\nvim\.git -Recurse -Force
```

## [1.9. 仪表盘（Dashboard）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_the_dashboard)

好了，你已经完成了本书最困难的部分，现在终于可以开始使用 LazyVim 了！使用与之前相同的终端命令：nvim。

当 LazyVim 设置一切并下载它认为必要的插件时，你会看到一连串的活动。你可能会看到它编译和安装一堆 treesitter 语法解析器；如果你看到"Show More"（显示更多）的消息，可以使用 G（即 Shift+g）跳到末尾。

一旦所有内容都安装完成，你会在一个由 Lazy.nvim 插件管理的窗口中看到已安装插件的摘要，我们稍后会讨论这个插件。现在，当你看到 Lazy.nvim 界面时，可以按 q 键。插件会将其解释为"退出 Lazy.nvim"，窗口就会关闭。

现在你可以看到 LazyVim 的仪表盘，这是你每次启动 LazyVim 时首先看到的界面。比起开箱即用的 Neovim 体验，这个界面要友好得多：

<img src="mymedia\dashboard-dark.png" alt="dashboard dark" style="zoom:50%;" />

如你所见，有几个命令可以通过单个按键与仪表盘进行交互。当然，最重要的是按 q 键退出！

这些选项大多是不言自明的，但我们会在后面的章节中深入讨论其中的一些选项。

## [1.10. Lazy.nvim 插件管理器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_lazy_nvim_plugin_manager)

当你第一次打开 LazyVim 时，它会检查是否有可更新的插件，并在一个消息通知中给你一个概览，看起来会像这样：

<img src="mymedia\plugin-updates-dark.png" alt="plugin updates dark" style="zoom:50%;" />

由于 Neovim 默认非常基础，LazyVim 预装了大量实用的插件。而且这些插件很可能已经过时了，因为 Neovim 世界的插件开发速度快得惊人。

在很久以前，插件管理完全是手动过程。在不那么久远但仍然是过去的日子里，插件管理由各种插件来完成，但总感觉缺少些什么。

然后出现了名为 Lazy.nvim 的插件管理器，它是由后来创建 LazyVim 的同一个人开发的。虽然两者都由同一个人维护，但不要把 Lazy.nvim 插件管理器与 LazyVim 本身混淆。Lazy.nvim 严格来说只是一个插件管理器，而 LazyVim 是一个插件和配置的集合。Lazy.nvim 是其中的一个插件。

Lazy.nvim 有许多出色的功能，最显著的是只在需要时加载插件（因此名为"Lazy"），这使得你的编辑器启动速度非常快。它还有一个很好的用户界面来管理插件的安装和更新。

你可以在仪表盘中简单地按 l 键来访问这个界面，在仪表盘中标记为 Lazy。这个标签可能应该标记为 Lazy Plugin Manager 会更清楚一些，但现在你已经知道 Lazy 的含义了，所以不会忘记。

如果你没有主动显示仪表盘，你可以随时通过进入空格模式来显示插件管理器。我们将在下一章详细介绍空格模式，但现在：首先确保你处于普通模式，方法是检查活动窗口的左下角。如果不是，按 Esc 键进入普通模式。然后按空格键进入空格模式，再按 l 键调出 Lazy.nvim 插件管理器。

（别担心，这些按键绑定在一周之内就会成为你的第二天性。）

Lazy.nvim 插件管理器界面看起来是这样的：

<img src="mymedia\plugin-manager-dark.png" alt="plugin manager dark" style="zoom:50%;" />

弹出的这个窗口被称为浮动窗口。你会在不同的情况下看到这些窗口，通常是在需要处理交互数据时。这个特定的浮动窗口有它自己的一套按键绑定。这些按键绑定列在顶部，要注意它们都是大写的，所以在使用时需要按 Shift 键。

通常，我使用的唯一 Lazy.nvim 按键绑定是 S，用于同步（Sync）。这相当于在一个操作中同时运行安装（install）、清理（clean）和更新（update）。它确保实际安装的插件版本与 LazyVim 配置中指定的版本完全一致。

所以当"Plugin Updates"（插件更新）通知弹出时，只需按 Space-l，然后按 S，等待同步完成。之后按 q 关闭 Lazy.nvim 插件模式和浮动窗口，返回你之前的工作。

## [1.11. 关于管理点文件的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_a_note_on_managing_dot_files)

如果你在多台不同的电脑上工作，你很快就会发现你不想在所有电脑上分别设置 LazyVim 配置。LazyVim 没有类似 VS Code 的"设置同步"功能，虽然存在这样的插件。

我推荐的替代方案是将你的配置文件存储在 git 仓库中。你可能会发现还有一些其他文件也想保存在那里，比如你的终端配置文件、.gitconfig 和 .zshrc / .bashrc / .config/fish/config.fish。

如果你使用 GitHub Codespaces，你可能已经用 git 管理了一些点文件。如果没有，我个人建议遵循 Atlassian 博客上那篇优秀的文章[《Dotfiles: Best way to store in a bare git repository》](https://www.atlassian.com/git/tutorials/dotfiles)（点文件：在裸 git 仓库中存储的最佳方式）中的建议。

在像 LazyVim 这样的发行版出现之前，人们很常见地将他们的 Vim 配置存储在公共仓库中，并相互借鉴想法。这种做法现在还没有完全消失，你可以在 GitHub 上的 [dusty-phillips/dotfiles](https://github.com/dusty-phillips/dotfiles) 仓库中找到我自己的点文件。

## [1.12. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_summary)

在本章中，我们简要讨论了 Vim、Neovim 和 LazyVim 的历史，以及它们为什么在今天仍然具有重要意义。然后我们介绍了 GPU 加速终端和 Nerd Fonts 的重要性。

我们弄清楚了如何在你使用的任何操作系统上安装 Neovim 及其依赖项，最后从其起始模板安装了 LazyVim。

在下一章中，我们将讨论 Vim 的核心特性：模态编辑，并深入探讨在 LazyVim 中用键盘可以做的许多事情。

# [第二章：什么是模态编辑？](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_what_is_modal_editing_anyway)

正如仪表盘上的字母所示，LazyVim 是以键盘为中心的编辑器。尽可能多的操作都可以在不需要在鼠标和键盘之间来回切换的情况下完成。当然，你仍然可以使用鼠标。你可以点击编辑器中的任何位置，与弹出的按钮和对话框进行交互，使用滚轮或触控板手势进行滚动，通过拖动边框来调整编辑器窗格的大小。但是，这些操作都可以使用键盘来完成，而且通常效率更高。

更重要的是，你可以通过最多按住两个键，甚至只需要一个键就能完成大多数操作。你很少需要将手指扭曲成痛苦（且危险）的姿势去按 Control + Shift + Alt + <某个键>。

Vim 是如何做到这一点的？答案是模式编辑（Modal editing）。

## [2.1. 模式编辑入门](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_introduction_to_modal_editing)

在 LazyVim 中，"模式"简单来说就是根据当前激活的模式，不同的按键会有不同的含义。例如，当你启动编辑器时，你处于"仪表盘模式"（Dashboard Mode），该模式下每个按键最常见的解释都直接列在仪表盘上。这种在特定模式下按键绑定的可发现性是 LazyVim 的一个普遍特点，相比原生 Neovim 不透明的默认行为来说是一个巨大的改进。

为了更好地理解这一点，按下空格键进入"空格模式"（Space mode）。空格模式是 LazyVim 特有的概念；它在原生 Neovim 安装中并不存在（不过如果你想在不使用 LazyVim 的情况下获得空格模式，你可以通过安装各种插件来重现这个效果）。

进入空格模式后，屏幕底部会弹出一个菜单。它看起来会像这样（我的菜单包含一些自定义设置，所以你的可能会有所不同）：

<img src="mymedia\space-mode-dark.png" alt="space-mode-dark" style="zoom:50%;" />

这是一个很大的菜单。现在我们需要关注的重点是 f 键，我们将用它来理解模式编辑。

如果你在仪表盘模式下按 f 键，会打开一个查找文件（Find file）对话框，这个对话框使用了我们稍后会讨论的选择器插件。但是，当你在空格模式下，按 f 键则会打开文件/查找（file/find）其空格模式的子菜单。

这就是模式编辑的核心含义：同一个按键的行为取决于当前的模式。正如空格模式菜单底部所示，你可以按 Escape 键退出空格模式并返回到仪表盘。现在就试试吧。

现在你回到了仪表盘模式，你可以按 n 键创建一个新的空白缓冲区（buffer）。

请特别注意缓冲区左下角，你会看到 INSERT 这个词：

<img src="mymedia\insert-mode-dark.png" alt="insert mode dark" style="zoom:50%;" />

还记得我说过空格模式是 LazyVim 特有的概念吗？插入模式（Insert mode）则是最初 Vi 编辑器的概念，后来的 Vim、Neovim，以及现在的 LazyVim 都继承了这一特性。在插入模式下，绝大多数按键的行为都和你在其他编辑器中的预期一样：它们会插入文本。所以你可以像平常一样正常打字。

在插入模式下，你可以使用 Control 和 Alt 键来访问一些快捷键。例如，你可以按 Control-r 进入"寄存器"（Registers）迷你模式，这会弹出一个你可以从中粘贴内容的"寄存器"列表。我们将在第 8 章详细介绍寄存器。现在，你只需要知道在插入模式下，按 Control-r 后跟加号键（即 Shift-=）将会从剪贴板中粘贴文本。

然而，对于任何非文本输入的操作（包括粘贴文本），你会更经常地切换到普通模式（Normal mode）来执行。普通模式是另一个主要的 Vim 模式，自 Vi 时代就存在了。

要从插入模式切换到普通模式，按 Escape 键。光标会从一条竖线变成一个方块，左下角的指示器也会变成蓝色的 NORMAL：

<img src="mymedia\normal-mode-dark.png" alt="normal mode dark" style="zoom:50%;" />

在普通模式下，按键的行为与插入模式完全不同。比如按 p 键，它不会在文档中输入字母 p，而是会从系统剪贴板中粘贴内容。

Vim 和 Neovim 的一些功能虽然不太容易发现，但它们的快捷键设计得很容易记忆。大多数情况下，执行某个操作的快捷键都会使用该操作相关的首字母。你可能会认为 p 代表"paste"（粘贴），但其实这个概念比剪贴板的概念要早得多。如果你觉得理解成"paste"更容易，那也没问题，但在 Vim 的术语中，它实际上代表"put"（放置），在本书中我们也会使用这个词。

来看个不同的例子：在插入模式下按 Control-r 会弹出寄存器列表，但在普通模式下却是执行"redo"（重做）操作。如果你想在普通模式下访问寄存器列表，需要按 "（引号，即 Shift-单引号）键。

如果这些听起来很混乱，也不用担心。你的大脑和肌肉记忆会比你想象的更快适应，你也始终会明白，普通模式下的行为与插入模式下的不同。

我很少在插入模式下使用非文本输入的命令，而是习惯先切换回普通模式再执行这些命令。这样做并不会增加太多按键次数，而且避免了同时按住多个键的麻烦。

从插入模式退出到普通模式，统一使用 Escape 键。这就带来一个重要问题：你会频繁使用这个键，但是每次都要把手从主行移动到左上角的 Escape 键再移回来，这样的操作效率其实不高。

对于这个问题，有几个常见的解决方案：

- 如果你使用的是可自定义的键盘，你可以把 Escape 键放在更方便按到的位置。这就是我的做法。我用的是 Kinesis Advantage 360 键盘，虽然这个键盘的设计看起来有点奇特，但我把 Escape 键重新映射到了"拇指区"，这样按起来就和 Enter、空格、退格键一样方便了。

- 你的操作系统一般都支持键盘重映射。很多使用模式编辑器的用户会把几乎用不到的 Capslock 键改成 Escape 键。（对于非模式编辑器的用户来说，可能会更喜欢把 Capslock 改成经常需要按住的 Control 键，特别是在笔记本键盘上）。

- Neovim 本身也支持键位重映射。我们稍后会在 LazyVim 部分详细讨论如何设置。一个常见的做法是把一些在输入文本时不太可能连续按到的组合键映射成 Escape 键。比如，你可以设置在插入模式下按 jk、jj 或 ;; 来切换到普通模式。我试过这种方法，但不太喜欢，因为当你按下第一个键时，Neovim 会等待看你是要输入命令还是继续输入文本，这个延迟让我觉得不太舒服，不过你可能会喜欢这种方式。

- 另外，Control-C 组合键也可以退出插入模式，这个是默认就有的，不需要额外设置。不过我个人不太喜欢这种方式，因为需要按两个键，而且在我用的 Dvorak 键盘上，按 Control-C 比在 qwerty 键盘上要难得多，毕竟在 qwerty 键盘上 C 键就在底排靠近 Control 键的位置。

现在暂时不用急着改键位设置，先试着习惯现有的 Escape 键位置，看看是否真的觉得不方便。

当你进入普通模式后，肯定还是要回到插入模式来输入文本的。有几种不同的方法可以做到这一点。下面介绍几个最常用的：

i 键可以在光标当前位置之前插入文本。这意味着你可以（虽然很笨拙）通过重复按 i <Escape> i <Escape> 来向左移动光标。当你按 i 键时，你可以在当前位置之前插入文本，然后按 Escape 退出插入模式，这时光标就会停在新的"之前"位置。

有时候，你可能想在光标当前位置之后进入插入模式。这时就要用 a 键了（记忆方法：i 代表 Insert Before（在前插入），a 代表 Append 或 After（在后添加））。

在浏览文档时，你会发现经常需要在这两种模式之间切换，因为我们后面要讲到的各种导航命令，有时会把光标放在你需要插入的位置之前，有时会放在之后。所以记住这两个命令都很重要。

还有两个非常常用的操作是在当前行的最开始或最末尾插入文本。虽然你可以先用导航命令移动到行首或行尾，然后再用 i 和 a，但直接用 I 和 A 命令会更方便（注意这两个是大写字母，需要按住 Shift 键）。

### [2.1.1. 关于按键助记的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_a_note_on_keybinding_mnemonics)

这些相关的按键绑定通常会被分配给同一个字母的小写和大写版本。你会发现小写版本通常表示"做某事"，而大写版本要么表示"做同样的事情，但范围更大"，要么表示"做相反的事情"，具体取决于情况。在这里，i 和 a 表示"在光标前后插入一个字符"，而 I 和 A 则表示"在光标前后插入，但范围更大（即在行首或行尾）"。

举个"做相反的事情"的例子，看看 o 和（按住 Shift 的）O 键，这是另外两种进入插入模式的方式。

o 键用于在当前行下方创建新行并进入插入模式。对于"做相反的事情"的情况，大写的 O 表示"在当前行上方创建新行并进入插入模式"。

> 助记口诀"Open（打开）一个新行在上方/下方"可以帮你记住这个不太容易记住的 o 命令。

最后一个需要按两个键的有用命令是 gi。这是先按一下 g 再按一下 i。它的意思是"转到上次进入插入模式的位置，并再次进入插入模式"。在这种情况下，g 键实际上是切换到一个我称之为"Go To（转到）"的小模式，不过并非所有从这个模式可以访问的命令都严格与"转到"有关。你可以在普通模式下按 g 键，然后等待窗口底部弹出菜单，就能看到"Go To"模式下所有可用的命令列表：

<img src="mymedia\goto-mode-dark.png" alt="Go To Mode" style="zoom:50%;" />

我们稍后会介绍大部分命令，但请注意其中有 i 键，标注为"Move to the last insertion and INSERT（移动到最后插入的位置并进入插入模式）"。所以如果你忘记了如何返回上次插入点，可以进入 Go To 模式并查看菜单来找到 i。

反复练习所有这些命令（a、i、o、A、I、O 和 gi），输入一些文本，然后按 Escape 返回普通模式。然后再试一次。用鼠标在文本中移动光标（我保证我们很快就会学习键盘导航），在不同位置尝试这些命令，看看它们的行为。

要充分熟悉在普通模式和插入模式之间的切换。你可能认为会在插入模式下花费大部分时间，但事实是代码的编辑频率远高于新写代码，你会经常在这两种模式之间切换。

## [2.2. 可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_visual_mode)

LazyVim 从其前辈那里继承的另一个主要模式是"可视"模式。可视模式用于选择文本。通常，你可以进入可视模式，然后使用许多与普通模式相同的导航键来移动光标。由于我们还没有介绍这些导航按键，我会把可视模式的详细讨论推迟到第 8 章，到那时我们会有必要的基础知识。

## [2.3. 命令模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_command_mode)

命令模式与我们之前看到的其他模式不同，其他模式大多是子菜单或编辑器级别的"主要"模式。你可以在普通模式下使用 :（即 Shift+分号）进入命令模式。在 LazyVim 中，这会弹出一个小部件，你可以在其中输入所谓的"Ex 命令"。这个名称来自 vi 的前身 ex，这些年来除了作为 Vim 的一部分外，它基本上已不再被使用。

本质上，你可以在这个小部件中输入各种命令，并期望产生特定的行为。它实际上更类似于 Sublime Text 和 VS Code 普及的命令面板，尽管体验很不一样。

你已经从第 1 章知道一个 ex 命令了！还记得 <Escape><Colon>q!<Enter> 这个退出编辑器的命令吗？现在你知道了 Escape 是从任何模式返回到普通模式。冒号用于切换到命令模式，q 是 quit（退出）的简写（如果你不在意按键次数，也可以输入完整的 quit）。感叹号表示"不保存"，回车键表示"提交 ex 命令"。

举个例子，让我们看看 write 这个 ex 命令。输入 : 后面跟着 write myfile.txt，像这样：

<img src="mymedia\command-mode-write-dark.png" alt="command mode write dark" style="zoom:50%;" />

按回车键确认并执行命令，这将以给定的名称保存文件。

> 大多数命令可以缩写为它们最短的唯一公共前缀。你通常可以输入 :w myfile.txt 而不是 :write myfile.txt。最常用的命令甚至有特殊的组合命令，比如 :wq 会保存并退出，不过你可能会更喜欢使用 :x，因为它更短。

命令模式有点奇特。它有点像插入模式，因为你可以在其中输入文本，一些在插入模式下有效的快捷键在命令模式中也有效（包括用 Control-r 从寄存器中粘贴）。但其他快捷键在命令模式中的行为是不同的。最重要的一个是 Tab 键，它会对命令执行一种"tab 补全"。例如，:q<Tab> 会弹出一个像这样的菜单：

<img src="mymedia\command-tab-dark.png" alt="command tab dark" style="zoom:50%;" />

这个补全菜单的导航方式令人困惑。你可能需要把这部分内容加入书签或做些笔记，直到你习惯为止！

首先，如果你想在菜单中选择不同的条目，你肯定会认为可以使用方向键，对吧？确实可以，但这很混乱，因为你需要用左右键来实现上下移动。我知道！这很让人费解，对吧？

这主要是因为菜单在 LazyVim 中的外观与原始 Vim 不同，但按键映射没有改变。所以我建议使用 Tab 和 Shift-Tab 来选择菜单中的不同条目。这更容易记住，也更容易形成肌肉记忆：按一次 Tab 显示菜单，再次按 Tab 可以在菜单条目中循环选择。

其次，确认这些菜单条目时有一些细微差别。在上面的例子中，你可以直接按 Enter 确认选择并执行它。然而，有时你可能想确认选择后继续编辑命令。一个很好的例子是 :e 或 :edit 命令。

这个命令用于打开文件系统中的文件，但你必须输入完整的文件路径。例如，如果你有以下目录结构：

```bash
.
└── foo
    ├── bar
    └── baz
    │   └── fizz.txt
```

...并且你已经打开了 Neovim，要打开 fizz.txt 文件，你需要输入以下内容：

```
:e foo/baz/fizz.txt
```

如果需要访问深层嵌套的目录，这样输入会很麻烦。幸运的是，你可以使用 tab 补全功能。你可以输入 :e f<tab>b<tab><tab><tab> 来选择 foo/baz，但此时菜单仍然是打开的：

<img src="mymedia\edit-baz-dark.png" alt="edit baz dark" style="zoom:50%;" />

如果你现在按 Enter，它会打开 baz 文件夹而不是仅仅确认选择，这不是你想要的。如果再按 Tab，它会继续在菜单中循环。

相反，你有几个选择。向下箭头键会（不直观地）"进入"选中的目录，让你可以在其中的文件间使用 tab 切换。或者，使用 Control-y（y 代表"yes"）组合键。这将确认 baz 的选择并关闭菜单，但保持你在命令模式中。现在你可以再次按 tab 来补全命令中的 fizz.txt 部分。

可以重新映射这些键使其更像其他软件，说实话我认为这是 LazyVim 应该默认做的事情之一。不过我还没有找到我喜欢的组合，所以我就继续使用默认的键位绑定。

你可能不会在命令模式下花太多时间。例如，在 LazyVim 中有更简单的方法来打开文件，退出编辑器也是如此。如果你需要处理更复杂的命令历史，还有一个特殊的窗口可以让你用插入模式和普通模式来编辑命令，我们稍后会介绍。

现在，记住 <Tab> 和 Control-y，你就能在需要时导航命令菜单了。

顺便说一下，最重要的命令是 :help。Vim 是在人们还没有随时访问互联网的时候创建的，所以它有一个传统，就是将所有文档都随编辑器一起发布。例如，如果你记不住粘贴文本的快捷键，可以试试 :help put。或者，如果你想知道 Control-R 快捷键的作用，可以试试 :help CTRL-R。当然，Vim 的帮助文档也已经被你喜欢的搜索引擎和 AI 聊天机器人包揽了，所以如果你愿意的话也可以用这些新方式来查询。

## [2.4. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_summary_2)

在本章中，我们熟悉了模态编辑的概念和 LazyVim 最重要的模式。随着我们学习的深入，还会遇到其他的小模式，但掌握普通模式、插入模式和命令模式（以及它们之间的切换方法）将让你在 LazyVim 的使用之路上走得更远。

在下一章中，我们将学习在文档中移动光标的各种不同方法。

# [第三章：光标移动](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_getting_around)

软件开发人员花在编辑代码上的时间远比写代码的时间多。我们总是在调试、添加功能和重构。

事实上，我最常做的事情就是在代码库的某个特定行添加 print/printf/Println/console.log。

如果你来自更常见的文字处理或文本编辑生态系统，在 Vim 的模态范式中，代码导航是最不同的部分。即使你习惯了 Vim，LazyVim 默认附带的一些插件也提供了不同于传统 Vim 的代码导航方法。

在 VS Code 中，从代码中的一个点移动到另一个点，最快的方式通常是使用鼠标。对于小幅度移动，方向键效果很好，它们可以与 Control、Alt 或 Cmd/Win 键组合使用，以实现更大幅度的移动，比如按词、段落移动，或移动到行首行尾。还有许多其他键盘快捷键可以让移动更容易，而且语言服务器的支持允许简单的语义代码导航，如"转到定义"和"转到符号"。

Vim 也支持鼠标导航，但一旦你熟练掌握了导航键位映射，你就不会经常使用鼠标了。LazyVim 为与 VS Code 相同的语言服务器协议功能提供了键位绑定，而且这些功能通常更容易访问。Vim 的最大区别在于，当编辑器处于普通模式时，整个键盘都可以用来进行导航操作。

## [3.1. 查找文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_seeking_text)

LazyVim 自带了一个名为 flash.nvim 的插件，这是 LazyVim 的维护者创建的，与 LazyVim 完美集成。

这个插件提供了一种代码导航模式，这种模式在各种 vim 插件中已经存在多年，历史上一直颇具争议。许多长期使用 Vim 的用户认为它破坏了 Vim 的范式。我不会详细解释原因，但我承认这在旧版本的范式中确实如此，不过在 flash.nvim 这样的现代版本中，这个问题已经不那么明显了。

如果你能看到想要导航到的代码（即文件当前已打开且代码在视图中），flash.nvim 几乎总是将光标移动到那里的最快方式。诚然，这至少需要按三个键，但这三个按键不需要心算或逐步"靠近"目标直到到达，这是其他一些 Vim 导航技术（以及非模态编辑）中出现的两个效率较低的问题。

要调用 flash，在普通模式下按 s 键。我把 s 记为"seek"（查找）的助记符，虽然我也听说过有人称之为"sneak"（潜行）或"search"（搜索）模式。在 LazyVim 中搜索是一个不同的行为（它不在意文本是否当前可见），而"潜行"听起来不太浅显易懂，所以我使用"Seek"（查找）。

当你按下 s 时，首先要注意的是文本会褪色为统一的颜色，状态栏中会出现一个小闪电符号，表示 Flash 模式已激活：

<img src="mymedia\seek-active-dark.png" alt="seek active dark" style="zoom:50%;" />

由于你知道想要将光标移动到哪里，你的眼睛可能正盯着那个位置，而且你确切知道那个位置的字符是什么。所以在进入查找模式后，只需输入你想要跳转到的字符即可。

例如，在下面的截图中，我想要修复本节标题中的拼写错误，将 Test 改为 Text。

<img src="mymedia\seek-s-dark.png" alt="seek s dark" style="zoom:50%;" />

我按下了 ss，截图中的每一个 s（包括大写的）都变成了蓝色。状态栏中闪电图标旁边有一个 s 字符，表明我已经查找了 s。

此外，靠近光标（位于底部段落）的所有 s 字符旁边（右侧）都有一个绿色标签。如果我想跳转到这些 s 字符中的任何一个，我只需输入对应的标签，就能立即跳转到那里。

然而，我想要到达的字符距离太远，没有唯一的标签，因为我的文本中有很多 s 字符。没关系！我只需要输入目标 s 字符右侧的字符，也就是 t。现在我的屏幕看起来是这样的：

<img src="mymedia\seek-st-dark.png" alt="seek st dark" style="zoom:50%;" />

现在，文件中所有的 st 组合都以蓝色高亮显示，由于 st 的数量比单独的 s 要少，所有这些实例旁边都有一个标签。我想要移动到的文本标记为 p，所以我按下 p，光标就移动到了我想要更改的 s 字符处。现在我可以输入 rx 来将 s 替换为 x（我们将在第 6 章讨论代码编辑，但现在你已经体验到了）。

如果你在分割窗口中打开了多个文件（我们将在第 9 章讨论），查找模式可以用于将光标移动到屏幕上的任何位置，而不仅仅是当前活动的分割窗口中。

然而，查找模式也有缺点，至少在 flash.nvim 的实现方式中是这样。有些字符你无法直接移动到，因为在标记匹配到达目标位置之前就用完了可搜索的文本。对我来说，这种情况最常发生在我想要编辑行尾时。如果我输入 sn 是因为我想编辑一行以 n 结尾的文本，但是在我的光标附近有很多 n 字符比我想要移动到的那个更近，flash 可能不会标记我想要移动到的 n，而且它不接受回车键作为"下一个字符"输入。

因此，我不会在行尾附近使用查找。相反，我会查找同一行中间某个词，然后使用 A，正如你可能记得的，这会让我在行尾进入插入模式。或者，如果我不想进入插入模式，我会使用 $ 符号（Shift+4），这是普通模式下"将光标移动到当前行末尾"的命令。

## [3.2. 滚动屏幕](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_scrolling_the_screen)

查找模式只在你想跳转的文本在屏幕上可见时才有效。你无法标记看不见的内容！通常，这意味着你需要使用搜索或后面将讨论的更大范围或更具体的移动命令，但也有一些快捷键可以用来滚动屏幕，让你在跳转前看到目标。

这些快捷键按照 Vim 标准来说有点不寻常，因为它们大多使用控制键。多么反模态啊！根据我的经验，这些快捷键实际上并不常用。事实上，我已经忘记了其中一些，不得不查阅才能写这一章。

我最常用的滚动键绝对是 Control-d 和 Control-u，它们分别表示向下（down）和向上（up）。它们可以滚动半屏的文本。光标相对于窗口保持在相同位置，这意味着相对于文档，它会向上或向下移动半屏的文本距离。

如果你需要移动更远，可以使用 Control-f 和 Control-b 快捷键（向前forward和向后backward），它们会滚动整整一页文本。我不太喜欢这些，因为我永远不确定光标最终会在哪里，这让我感到迷失方向。但如果你需要快速滚动某些内容到可见区域以使用查找模式，它们会很有用。与 Control-d 和 Control-u 不同，Control-f 和 Control-b 可以加上数字前缀，所以你可以输入 5<Control-f> 来向前滚动 5 页。

要逐行滚动窗口，使用 Control-y 和 Control-e。我不知道为什么选择这些快捷键。它们没有任何助记含义。我很容易忘记它们，所以我从不使用它们。这些快捷键接受数字前缀，所以如果你能记住它们，它们对于微调文本位置很有用。这些快捷键的主要优点是除非光标会滚动出屏幕，否则它们不会移动光标，所以如果你正在处理某一行并需要更好的可见性但不想移动光标，你可以使用 Control-y 和 Control-e。

我不使用这些键的原因（除了缺乏好记的助记符外）是我更喜欢使用 z 模式进行相对光标定位。

### [3.2.1. Z 模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_z_mode)

z 菜单模式是光标定位、代码折叠和各种随机命令的混合体。你可以在普通模式下按 z 键查看列表：

<img src="mymedia\z-menu-dark.png" alt="z menu dark" style="zoom:50%;" />

如果你觉得这个菜单很大，那你还没见识到一半！还有许多其他的 z 模式快捷键太过晦涩，以至于 which-key 插件都懒得在菜单中列出它们！这里我会介绍三个最有用的滚动相关命令，其他的我们稍后再讨论。

我专门使用的相对光标快捷键是 zt、zb 和 zz。它们分别将光标所在行移动到屏幕的顶部、底部或中间。当移动到顶部或底部时，会在光标上方或下方保留几行作为上下文。

还有一些命令也会将光标移动到窗口的第一列，但与其记住那些快捷键，我建议将前面的命令与 0 组合使用，比如 zt0、zb0 和 zz0。0 命令就是"移动到行首"的意思。如果你的键盘有 Home 键，你也可以使用它，但在很多键盘上 0 更容易按到。

你可以通过输入 :help scrolling 在 Neovim 文档中找到其他滚动快捷键，但我刚才提到的这些可能已经足够满足你的需求了，因为你将学习到更多细致入微的代码导航方法。

## [3.3. Vim 的第一条规则](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_the_first_rule_of_vim)

Vim 有一条神圣的规则，我经常因为正当理由而违反它。除非你和我一样是个奇怪的人，否则你可能不应该像我这样经常打破它：

永远不要使用方向键移动光标。

这条规则的背景是，在大多数键盘上，将手移动到方向键需要大约十分之一秒，再移回主行又需要十分之一秒。我不确信这些零点几秒能累积成显著的时间，即使考虑到我一生中已经输入了数百万个字符（是的，数百万。我曾经计算过）。

但我确实认为，在大多数键盘上，方向键可能会对你的手部长期健康造成不良影响。而且说实话，当你越来越习惯使用 Vim 的替代按键绑定时，你就会越来越倾向于使用它们。

Vim 的方向键绑定在你第一次看到时可能显得很反直觉：h、j、k 和 l。这些键分别对应左、下、上、右方向。如果你觉得用 l 表示右而不是左很奇怪，或者你在想为什么跳过了 i（因为这看起来是按字母顺序排列的），看看你的键盘就明白了。

如果你使用标准 QWERTY 键盘，字母 h、j、k 和 l 就在你右手所在的主行上，按这个顺序排列，因此它们是整个键盘上最容易按到的键。

在 Neovim 中打开一个较大的文件（你可以使用 :e 路径/文件名），然后尝试使用主行键（h、j、k 和 l）来左右上下移动光标。在你练习的时候，我来告诉你为什么我不使用它们，因为我有三重特殊性。

首先，我是左撇子，所以右手主行感觉不太容易操作。其次，我使用 Dvorak 键盘布局已有二十年。j、k 和 l 键不在我的主行上。第三，我使用 Kinesis Advantage 360 键盘，除了其他奇特的布局特征外，它的方向键就在手指可及的范围内，所以我不需要移动手就能按到它们。

由于命运的奇妙转折，这些特殊性某种程度上相互抵消了。j 和 k 键恰好在我主导手（左手）的左右方向键正上方。所以这就是我用于导航的方式：左右方向键，j k。如果你没有我这么特别，你可能应该按照 Vim 设计的方式使用右手主行键。

Vim、Neovim 和 LazyVim 都非常善于重复使用移动命令，所以在阅读本书的过程中，你会发现 h、j、k 和 l 被用于许多不同的导航序列。花足够的时间来真正习惯它们。但要记住，如果你需要连续按这些键超过两次才能移动光标，那你就是在浪费按键次数。

## [3.4. 计数](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_counting)

Vim 中的绝大多数命令都可以在前面加上一个数字来重复执行多次。这个数字通常是在你想要重复的命令之前输入的一串数字。

例如，要将光标向上移动 15 行，你可以在普通模式下输入 15k。要向右移动 5 个字符，使用 5l。

这就是为什么 LazyVim 默认会有如此奇特的行号显示方式。请看下面的截图：

<img src="mymedia\relative-lines-dark.png" alt="relative lines dark" style="zoom:50%;" />

在这个截图中，我的光标位于第 126 行，这一行在左边栏中被高亮显示。这个行号也显示在窗口的右下角（虽然在这个截图中被裁掉了）。但在第 126 行的正上方，我们看到行号是 1，它下面也显示为行号 1。

假设我想将光标移动到"Scrolling the screen"这个标题处。

这一行旁边的数字是 5，所以我不需要数行或做任何心算来确定需要使用的计数。我只需输入 5j，光标就会移动到目标行。

现在你知道这些相对行号的用途了，我建议你保持它们开启，直到你习惯为止。如果你觉得它们令人分心或者根本不使用它们，你可以通过编辑 LazyVim 配置来改为普通行号显示。打开文件 ~/.config/nvim/lua/config/options.lua，这个文件应该是 LazyVim 为你创建的，但目前除了描述其用途的注释外可能没有其他内容。

> 你可以使用空格模式命令 <Space>fc 来快速在 LazyVim 配置目录中查找文件。这会弹出一个文件选择器，我们将在下一章详细讨论这个功能。输入 "xxx（options）" 并按 <Enter> 键来打开xxx文件。

要默认禁用相对行号，在文件中添加以下这行代码并保存：

```lua
vim.opt.relativenumber = false
```

然后重新打开 Neovim，你就会在左侧列看到绝对行号值。

就我个人而言，我觉得行号不是很有用，而且我不想浪费宝贵的屏幕宽度来显示这些字符。正如已经成为一个普遍的主题那样，我承认我可能有点特立独行！但如果你也想完全禁用行号显示，你需要在 options.lua 中添加第二行代码：

```lua
vim.opt.number = false
vim.opt.relativenumber = false
```

## [3.5. 查找模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_find_mode)

> （ethan）我个人觉得这个模式很鸡肋，主要是因为要自己数数，而且还要按数字键，太繁琐了。

如果你需要将光标移动到距离当前位置相对较近的位置，你可能想使用 LazyVim 的查找模式，而不是我们之前描述的 Seek 模式。Neovim 的默认查找模式相对有限，但启用 Seek 模式的 flash.nvim 插件使其变得更加好用。

要进入查找模式，按 f 键。和 Seek 模式一样，屏幕的一部分会变暗，提示你需要输入另一个字符。输入后，光标后所有该字符的实例都会被高亮显示。例如，fs 将高亮显示当前光标位置后所有的字母 s。

但是，查找模式和 Seek 模式的相似之处到此为止。查找模式不会显示标签，而是光标会立即跳转到光标后的第一个匹配字符。你还会注意到光标前的文本没有变暗，光标前的行中的匹配字符也没有被高亮。

相反，我们需要使用计数来跳转到字符的后续实例。如果我想跳转到第三个高亮显示的 s，我输入 3f，光标就会移动到那里。但是，如果你想跳转到更靠后的 s，你可能不想一个个数有多少个 s。幸运的是，在使用计数后，LazyVim 会保持你在查找模式中，所以你可以先猜测有多少个 s 字符，然后一旦接近了，就可以用新的计数重复。如果你只想向前跳一个 s 字符，你不需要输入计数，只需按 f 键就可以向前移动。

如果你数错了或猜错了跳得太远，别担心！你可以利用（大写）F 表示"向后查找"的特性，它也可以使用计数。所以如果你需要移动到第 15 个高亮显示的 s，完全可以先猜测 18f，发现跳得太远了三个，然后用 3F 跳回到前面的字符。

而且，如果你知道要查找的字符在文档中光标的后面或上面，你一开始就可以用 F 而不是 f 进入查找模式。这将立即开始向后查找而不是向前查找。如果你一开始就知道要向后或向前跳转指定字符的三个实例，你可以在首次进入查找模式时就使用计数。

还有一个查找模式的细微变体，我称之为"To"模式，尽管官方 Vim 助记符实际上是"Til"模式。你可以用 t 或 T 进入这个模式，具体取决于你想要移动的方向。

"To"模式的行为与查找模式完全相同，只是它会跳转到目标字符的前面。

你可能认为 To 模式有点多余，因为你可以很容易地使用查找模式后跟一个 h 来向左移动光标。但是当你将它与编辑文本的操作结合使用时，"To"模式非常有用，我们稍后会讨论这点。举个例子，如果你使用命令 d2ts，它会删除光标和它遇到的第二个 s 之间的所有文本，但保留那个 s。这比使用查找命令然后必须进入插入模式来添加 s 的 d2fsis<Escape> 要容易得多。

## [3.6. 按词移动](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_moving_by_words)

当 f 或 t 感觉太大，而带计数的光标移动又感觉太小时，你很可能会想使用词移动命令。在其他编辑器和 IDE 中，你可能习惯于按住 Control、Alt 或 Option 键的同时使用方向键来实现这个功能。

Neovim 更简单；你不需要把手移到键盘的方向键区域，也不需要同时按住多个键。

相反，你只需要进入普通模式并按 w 键就可以移动到下一个词的开头。如果你想移动到当前词的末尾，使用 e 键。如果你已经在当前词的末尾，e 将移动到下一个词的末尾。

这在你想要和计数组合使用时很有用：如果你需要移动到当前词之后两个词的末尾，按 3e。这相当于按三次 e，这会移动到当前词的末尾，然后是下一个词的末尾，最后是你想要到达的词的末尾。如果你需要移动到当前词之后特定数量词的开头，w 也可以加上计数前缀。

如果你想向后移动，使用 b 键。这会将你移动到当前词的开头，如果你已经在词的开头，它会移动到前一个词的开头。和之前一样，使用计数可以移动到更多词的开头。

令人惊讶的是，移动到前一个词的末尾需要多按一个键：g 后跟 e。这个助记符是"go to end of previous word"（移动到前一个词的末尾）。实际上，由于某些原因，你会发现很少需要这个功能，说实话我通常使用 be（b 移动到前一个词的开头，然后 e 移动到那个词的末尾）来移动到前一个词的末尾。不过，如果你确实使用 ge，它也可以与计数组合使用。你需要输入类似 4ge 这样的命令，具体取决于计数。命令 g4e 不会做任何有用的事情。

总的来说，你可能偶尔会听到 w、e 和 b 命令被称为"web"词。这只是表示"按词移动"。这些可能是你最常用的移动命令，比单个光标位置的移动更常用，这是因为大多数编辑操作往往涉及更改或删除一个词或一系列词。

## [3.7. 按词移动，但范围更大](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_moving_by_words_only_bigger)

"web"词的大写形式也是按词移动，但"词"的定义略有不同。具体来说，大写的 W 会移动到下一个空白字符之后，而小写的 w 会使用其他形式的标点符号来界定词。考虑在许多编程语言中对象的方法调用，它看起来像这样：

```lua
myObj.methodName('foo', 'bar', 'baz');
```

如果你的光标当前在行首，按 w 会将光标移动到行中的句点，再按一次 w 会移动到 m，后续按 w 也会在括号和引号处停留。

另一方面，如果你的光标在行首，按 W 会直接移动到"bar"参数的第一个引号处，因为那里是第一个空白字符所在的位置。

作为可视化说明，这里比较使用 w 和使用 W 时在代码行中的所有停留点：

```lua
myObj.methodName('foo', 'bar', 'baz')
-----ww---------w-w--w--ww--w--ww--w---->
------------------------W------W-------->
```

B、E 和 gE 这些移动命令的行为类似，它们是按空白字符分隔的词来移动，而不是按标点符号分隔的词来移动。

在 Vim 和 LazyVim 的默认配置中有一个比较烦人的问题：没有办法在 CamelCaseWords（驼峰命名）或 snake_case_words（蛇形命名）的单个词之间导航。虽然你可以使用 fC 或 t_ 之类的命令来实现，但我稍后会向你展示如何设置 nvim-spider 插件，它可以让在这些常见的编程命名方式之间的导航变得更简单。

## [3.8. 行目标](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_line_targets)

经常需要移动到当前编辑行的开头或结尾。如果你的目标是移动到这些位置并进入插入模式，通常可以使用 I 或 A；但如果你需要移动到那里并保持在普通模式（例如，为了删除或修改某个词），你可以使用 ^、$ 和 0 命令。

如果你熟悉正则表达式，你可能知道 ^ 用于匹配文本开头或行首，$ 用于匹配结尾，所以使用这两个键绑定来匹配当前行的开头和结尾的助记方式可能不会像最初看起来那么难记。

然而，这两个命令之间存在一定的不对称性：

- $ (Shift-4) 命令简单地表示"移动到行尾"，即结束换行符之前的最后一个字符，不管那个字符是什么。
- ^ 或插入符号 (Shift-6) 表示"移动到这一行文本的开头"。这里的"文本的"很重要：如果你的行开头有空白（比如缩进），^ 不会移动到最左边的列，而是移动到第一个非空白字符。

要移动到行的最开始位置，使用 0 键。0 是唯一一个映射到命令的数字键，因为其他数字键都用来开始计数。但用 0 开始计数没有意义，所以我们可以用它来表示"移动到第零列"。

还有一个命令可以移动到行尾但不包括空白字符，不过我从未使用过它，可能是因为我通常配置格式化工具来删除尾随空白，所以这种情况很少出现。

两个字符组合 g_（g 后跟下划线）表示"移动到最后一个非空白字符"。我猜 _ 看起来有点像"不是空格"，所以某种程度上也算是助记符？我提到它是为了完整性，但你可能不会经常使用它。你也可以组合其他已经学过的命令，这样就不用记住这个特殊的命令。例如，你可以使用三个字符 $ge（组合"行尾"和"向后移动到词尾"）或 $be 来移动到行内最后一个非空白字符。你有多个选择，选择你觉得最容易记住或最容易输入的方式即可！

## [3.9. 跳转到指定行](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_jumping_to_specific_lines)

当你编译代码或运行代码检查工具时，不可避免地会得到错误发生的行号（除非这个编译器特别没用）。

你可以通过以下方式跳转到特定行：

1. 输入行号作为计数，然后按（大写的）G。例如，100G 会将光标移动到第 100 行
2. 或者使用 ex 命令： :100<Enter>

G 命令也可以不带计数使用，这种情况下 G 命令会将你带到文件的末尾。

如果你想去到文件开头，可以用 1G，但由于这是一个非常常用的操作，你可以使用 gg（两个小写的 g）来代替。在所有情况下，g 的助记符都是"Go to"（去往），在 g 之后可以跟很多不同的命令（使用： :help g 可以了解我没有提到的那些命令，不过要注意 LazyVim 已经重新定义了其中的一些）。

因为"去往"某个行号是最常见的需求，所以最容易输入的 G 和 gg 命令被用于行号导航。

## [3.10. 跳转历史](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_jump_history)

所有这些跳转可能会让你感到有点迷失。幸运的是，有两个非常有用的键绑定可以让你回到之前跳转的位置。

Control-o 是我最常用的非模态 Control 键绑定。说实话，考虑到我使用它的频率，我应该把它绑定到一个更容易按到的位置。它基本上意味着"回到我跳转前的位置"。

这在编辑代码时特别有用。比如当你在文件深处编辑代码时，突然意识到需要在文件顶部导入一个库。你可以使用 gg 跳到文件顶部，用 s 寻找要添加导入语句的行，然后进入插入模式添加导入语句。现在你想回到之前正在处理的代码位置以便使用新导入的库。按几次 Control-o 就能带你回去。

Neovim 会保存所有跳转的历史记录，所以你可以在多个位置之间跳转（可能是为了查看文档或函数的调用签名），并且总能找到回去的路。

如果你跳转过头了，可以使用 Control-i 键绑定在历史记录中向前跳转。它就是 Control-o 的反向操作。我不知道为什么选择 i 和 o 这两个键；也许是因为它们在 Qwerty 键盘上是相邻的？它们的使用非常普遍，一旦你学会了，就不会忘记。

## [3.11. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_summary_3)

在 Vim 中，代码导航是一个很大的主题。你已经学会了足够多的命令，可以比大多数非模态编辑器更高效地在 Vim 窗口中导航。但这仅仅是皮毛，我们后面还会介绍更多有用的代码导航命令。

我们已经介绍了：

1. LazyVim 的 Seek 模式，用于跳转到可见窗口中的任何位置
2. 滚动命令，确保你想跳转的目标可见
3. 使用主行键移动光标，以及使用计数来倍增移动距离
4. Find 模式与 Seek 模式的区别，尽管它们表面上很相似
5. 一些用于按词移动和跳转到行内关键位置的标准键绑定
6. 跳转到特定行的方法
7. 如何导航回之前跳转过的位置

在下一章中，我们将学习更多关于打开文件和导航文件系统的内容。

# [第四章：打开文件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_opening_files)

在上一章学习命令模式时，我们顺便了解了使用传统 Vim 方式（即 :edit 命令）来打开文件。另一个传统方法是直接在终端命令行中使用 nvim filename 来打开文件。

这两种方法偶尔会派上用场，但 LazyVim 预先配置了更现代的文件导航和打开方式。

## [4.1. 文件选择器简介](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_introducing_file_pickers)

LazyVim 自带两个不同的"选择器"插件：它们都是用于从列表中选择项目的工具。在本章中，我们将介绍这两个选择器，并就如何选择使用哪一个提供一些建议。虽然它们的外观略有不同，但在大多数情况下可以互换使用。

默认情况下，LazyVim 启用了 Telescope 选择器。它提供了一个具有预览和模糊搜索功能的选择器界面。如果你使用过许多现代编辑器中的命令菜单（或者甚至是 Github 或 Slack），你可能就知道我在说什么。选择器本身并不关心你要选择什么，它被用于 LazyVim 内置的或第三方插件提供的各种任务，包括打开文件、选择打开的缓冲区、项目范围的搜索等等。

你最常执行的选择器任务就是使用模糊搜索来打开文件。我每天要使用这个命令几十次，可能上百次，所以很幸运它有一个非常方便的快捷键。

在一个包含大量文件的代码仓库中工作时，文件选择器的优势最为明显。所以现在请用 Space q q 关闭 Neovim，然后在终端中使用 cd 命令切换到你最近在使用的项目目录（如果手头没有合适的项目，可以克隆你喜欢的开源项目来替代）。然后输入 nvim 重新打开 Neovim。

> 我刚才让你退出到终端是因为这样比较容易理解，但实际上也可以在 LazyVim 内使用 :cd 命令来切换目录。输入 :cd 目录路径 然后按回车，记住你可以使用 Tab 键来自动补全路径。现在如果你使用 :e 来打开文件，它们将会以你指定的文件所在目录作为相对路径。如果你使用文件选择器，文件路径可能是相对于当前工作目录的，也可能是相对于包含当前文件的项目目录的，这一点我们稍后会讨论。使用 :pwd 命令可以查看当前所在的目录。

好，假设你现在在一个大型项目的根目录下，想要打开任意一个文件。只需按两次空格键（即 Space Space）就可以弹出"当前项目中的文件"选择器。就像我提到的，这是你键盘上最容易按的快捷键组合。在大多数键盘上，空格键都很大，而且你用的是最有力的拇指来按它。和往常一样，按一次空格键会弹出 Space 模式菜单，你可以看到再按一次空格键会显示"查找文件（根目录）"。

对于包含本书当前内容的项目，选择器看起来是这样的：

<img src="mymedia\telescope-current-project-dark.png" alt="telescope current project dark" style="zoom:50%;" />

选择器分为三个主要区域：左上方是结果列表，右侧是当前选中文件的预览，底部是输入区域（在这个例子中标记为"Git Files"）。

输入区域是当前焦点所在，并且处于插入模式，所以你可以直接开始输入想要打开的文件名。这是一个"模糊搜索"（这个概念由 Sublime Text 普及），意味着你可以跳过一些字母，从而节省宝贵的时间。例如，如果我输入 ch3，我的列表就会被过滤为以下文件：

<img src="mymedia\telescope-ch-3-dark.png" alt="telescope ch 3 dark" style="zoom:50%;" />

只有路径中按顺序包含这三个字符（中间可能有其他字符）的文件才会显示。选择器会在结果中高亮显示这三个字母，这样你就能轻松看到为什么会匹配到这些文件。

另外请注意，默认情况下，匹配是不区分大小写的。我输入的是小写字母 c，但它也能匹配文件名中的大写 C。这通常足以将搜索结果缩小到你需要的范围。不过，如果你在搜索中使用任何大写字母，它就会切换到区分大小写的模式（这有时被称为"智能大小写"）。

这意味着 Ch 会匹配所有的 Chapters，但 cH 则不会匹配任何内容。更有趣的是，chF 也不会匹配任何内容，因为大写字母 F 的存在使整个搜索变成了区分大小写的模式，而章节名都是以大写 C 开头的，所以小写 c 就无法匹配它们（这个例子与上图无关）。

有时你开始输入一个词，然后发现需要匹配路径中更早的部分来区分它。例如，我在 Fablehenge 的这些源文件中开始输入 outline：

<img src="mymedia\telescope-outline-dark.png" alt="telescope outline dark" style="zoom:50%;" />

"Outline" 是这个应用中的一个常见词。有 243 个匹配的文件，这时我意识到可能应该在前面输入 comp 来将范围缩小到仅组件目录中的文件。虽然我可以切换到普通模式然后编辑行首，但直接输入 <space>comp 会更快。选择器会将空格解释为"重新过滤这些行，从开头模糊匹配这个新词"。现在我们可以看到只有 comp...outline 的文件被匹配到：

<img src="mymedia\telescope-outline-comp-dark.png" alt="telescope outline comp dark" style="zoom:50%;" />

这个结果可能会让人惊讶；最有可能的匹配显然是列表底部被选中的那个。其他 27 个匹配行都包含了 "outline" 和 "comp" 这两个词的所有字母，按从左到右的顺序排列。但是，由于模糊匹配算法的原因，这两个词实际上可以重叠！例如在倒数第二个条目中，匹配 "comp" 的 c 在 outline 这个词之前，o 在这个词中，而 m 和 p 都在 outline 这个词之后。选择器并不在意这一点，不过它会将匹配字母距离更近的结果排在更重要的位置，所以它们会出现在结果的底部。

你可以使用上下箭头键（或者 ctrl+p 和 ctrl+n ）在搜索结果中选择不同的文件，选中的文件预览会显示在右侧窗口中。一旦找到想要打开的文件，按回车键就可以在当前活动的 Neovim 窗口中打开它。

在 Telescope 中，输入区域甚至有自己的普通模式！你可以通过按一次 Escape 键进入这个模式。现在如果你按 j 或 k，就可以在不把手移到方向键的情况下选择列表中的不同文件。此外，h 和 l 键可以让你在输入框内移动光标，你可以使用 i 或 a 键在新位置进入插入模式。大写的 "I" 和 "A" 键则允许你移动光标到行首或行尾并进入插入模式。

你甚至可以使用我们在第三章讨论过的 Seek 模式，尽管它在选择器中的工作方式有点不同。当你在 Telescope 选择器的普通模式下按 s 键时，你可以跳过输入要搜索的字符的步骤。相反，LazyVim 会立即在文件名左侧为选择器中的每一行标上一个字符：

<img src="mymedia\telescope-seek-dark.png" alt="telescope seek dark" style="zoom:50%;" />

这些字符是选择器中每一行的标签。只需在键盘上按下显示的任意一个字母，与该字母关联的那一行就会被选中。然后按回车键就可以实际打开文件（或者，如果不是文件选择器，则执行该选择器的默认操作）。

最后，如果你在 Telescope 窗口中，但最终决定不想打开任何文件（或者你已经从预览中获得了需要的信息），连按两次 Escape 键即可。第一次按键会进入 Telescope 选择器的普通模式，第二次按键则会关闭选择器。

如果你需要滚动预览窗口来查看文件中更下方的内容，可以使用我们在基本导航章节中讨论过的相同按键：Control-d、Control-u、Control-f 和 Control-b。

## [4.2. "Root" 和 "Cwd" 的区别](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_difference_between_root_and_cwd)

<Space><Space> 命令被映射为"查找文件（根目录）"。打开文件选择器还有两种方式，就是使用 <Space>f 打开"file/find"菜单，然后再按 f 或 F。

<Space>ff 和 <Space><Space> 是一样的。它们都会打开"查找文件（根目录）"，只是另一种较长的方式而已。我猜测之所以在两个地方都存在这个功能，是为了让用户可以选择将其他操作映射到 <Space><Space>，同时仍然可以通过 <Space>ff 访问选择器功能。

<Space>fF（注意第二个 F 是大写）也类似；它被映射到一个叫做"查找文件（cwd）"的操作。如果你在你的项目中运行它，你可能会发现它看起来和"查找文件（根目录）"做的是完全相同的事情（这取决于你的项目是如何设置的），所以有两个独立的键绑定的目的可能会让人感到困惑。

### [4.2.1. 当前工作目录](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_current_working_directory)

"cwd" 是 "当前工作目录"（Current Working Directory）的缩写，默认情况下，它指的是你在终端中输入 nvim 打开编辑器时所在的目录。你可以通过进入命令模式（按 :），然后输入 cd path/to/directory 来改变整个编辑器的 cwd（记住，所有命令后面都要按回车键）。现在如果你使用 <Space>fF，文件列表将会相对于你切换到的新目录显示。

如果你不确定当前所在的目录，可以使用 :pwd 命令（"print working directory"的缩写）来在一个小的通知窗口中显示。cd 和 pwd 与 bash、zsh 和许多其他 shell 中用于改变和显示工作目录的命令是相同的，所以你可能已经很熟悉它们了。

我们还没有讨论编辑器分屏或打开新标签页的内容，但是为了将来参考：实际上不同的窗口可以有不同的工作目录。改变当前窗口目录的命令是 :lcd，是"local change directory"的缩写。这可以成为同时处理多个项目的强大方式（例如，如果你是一个同时负责后端和前端项目的全栈开发者）。不过，LazyVim 的"Root"目录概念可以半自动化处理这个问题。

### [4.2.2. 根目录](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_root_directory)

根目录不是 Vim 的概念，而是语言服务协议（LSP）的概念。LSP 是 VS Code 能够快速流行的重要原因；其核心思想是编辑器可以调用计算机上运行的外部服务来获取代码库的有用信息。LSP 提供了许多有用的功能，如转到定义和引用、突出显示代码错误、显示变量或类的文档等。它甚至可以帮助进行代码格式化和语法高亮。

根目录是 LSP 推断出的当前打开文件所属项目的"主目录"。LSP 如何确定根目录取决于具体的编程语言（和语言服务器）。例如：

- 在 JavaScript 或 TypeScript 项目中，它可能会在父目录中搜索 package.json 或 tsconfig.json 文件，找到后，将此文件所在的目录视作根目录 
- 在 Python 项目中，它可能会寻找 pyproject.toml 或 poetry.lock
- Rust 项目使用包含 Cargo.toml 的目录
- 某些 LSP 可能只是将包含 .git 文件夹的目录视为项目工作空间的"根目录"

根目录和当前工作目录（cwd）经常是同一个目录，这其实很好理解，因为我们平常开发项目时，第一步通常就是先进入项目目录，然后再打开 Neovim。所以自然而然，当前工作目录就会和项目的根目录重合。

这种自动根目录功能在处理多个项目时非常有用。不需要像前面讨论的那样使用 lcd，你可以直接使用 :e 或我们接下来要讨论的文件查找扩展来打开另一个项目中的文件。然后如果你使用 <Space><Space> 或 <Space>ff 调用"查找文件（根目录）"命令，它会在你刚刚打开的文件所在的根目录中查找其他文件。

然而，有时这可能会造成困扰，特别是在处理单体仓库（monorepo）或根目录出现在意外位置时。例如，我有一个普通的 Svelte 项目，其中包含一个 package.json 文件。这个项目使用 Cypress 进行测试，而 Cypress 文件夹包含一个 tsconfig.json 文件，这导致 TypeScript 语言服务器将其解释为一个单独的根目录。所以当我在处理某个 Cypress 测试文件并按下 <Space><Space> 时，根目录被认为是 Cypress 文件夹，我只能打开其他 Cypress 测试。但通常我想要做的是打开主文件夹中的源文件来查看测试失败的原因。在这种情况下，我必须按 <Escape><Escape> 退出 Telescope 选择器，然后按 <Space>fF 以当前工作目录模式打开选择器。

## [4.3. Fzf.lua](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_fzf_lua)

LazyVim 最近推出了一个可选的新选择器功能，作为 Telescope 的替代方案。这让我这个写教程的人更头疼了！虽然两者很相似，但差异足够大，需要分开来说明。

Fzf.lua 的主要优势，据说在于它为习惯使用命令行 fzf 工具的用户提供了一个"熟悉"的界面。Fzf 是一个很实用的命令行工具，它可以通过模糊匹配的方式，只需输入几个字符就能在复杂的文件系统中切换目录或打开文件。我用了好几年，确实很推荐。不过说实话，我个人并不太在意编辑器是否要和命令行工具保持完全一致的体验，所以这个优势对我来说并不是特别有说服力。

另一个推荐使用 Fzf.lua 的理由是它比 Telescope 性能更好。虽然在我的电脑上没怎么感觉出差别，但如果你觉得 Telescope 有点卡顿，可以试试 Fzf.lua。

不过 Fzf.lua 也有一些缺点：

1. 主要缺点是它实际上是在 Neovim 的终端窗口中运行的，这导致普通模式的行为很奇怪。特别是按 Escape 键时，它会直接关闭选择器，而不是像 Telescope 那样进入输入区域的普通模式。
2. 第二个缺点是 Fzf.lua 的插件生态没有 Telescope 那么丰富。实际使用中，从 Telescope 换到 Fzf.lua 我只会想念一个插件，但如果你是 Telescope 的重度用户，可能会发现 Fzf.lua 的选项相对较少。

如果你想尝试 Fzf.lua，你需要了解 Lazy Extras。我会在下一章详细介绍 Lazy Extras，简单来说它们是一些可以通过单个按键启用的可选插件配置。要启用 Fzf.lua，你需要：

1. 输入 :LazyExtras 然后按回车
2. 将光标移动到包含 editor.fzf 的那一行
3. 按 x 键安装这个扩展
4. 等待相关插件安装完成
5. 重启 Neovim

完成上述操作后，Telescope 会被禁用，转而启用 Fzf.lua。当你打开选择器时，会看到一个略有不同的布局：

<img src="mymedia\fzf-dark.png" alt="fzf dark" style="zoom:50%;" />

主要的区别是在 Fzf.lua 中，输入区域位于左侧顶部，而不是像 Telescope 那样在底部。

选择器的基本操作和 Telescope 类似，我只重点说明一下不同之处。最大的区别就是前面提到的，基于终端的普通模式行为比较特别。如果你想从输入区域进入普通模式，需要按一个很奇怪的组合键：先按 Control-\，再按 Control-n。进入普通模式后，你可以在窗口中导航，大多数快捷键的行为都和你期望的普通模式一样。

最明显的例外是 Seek 模式的行为和 Telescope 不同。如果你想在 Fzf.lua 中通过标签跳转到某一行，需要使用不太好记的 Control-x 快捷键。

Fzf.lua 默认配置了几个其他快捷键，按 F1 可以看到它们的帮助菜单。我经常使用的只有几个：

- Control-a 和 Control-e（这两个是类 Emacs 风格的烦人快捷键）：跳到输入区域的开头或结尾
- Control-d 和 Control-u：滚动结果窗口

在本书剩余部分，我会默认你使用的是 Telescope 而不是 Fzf.lua，但如果两者之间有明显的差异，我会特别说明。现在，让我们转向一个完全不同的文件选择体验。

## [4.4. Neo-tree.nvim 插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_neo_tree_nvim_plugin)

Neo-tree 创建了一个左侧边栏的文件浏览器，这种体验对许多现代 IDE 和编辑器的用户来说应该很熟悉。虽然和其他那些环境一样，Neo-tree 支持鼠标操作，但它更注重键盘交互，一旦你掌握了"Neo-tree 模式"，使用起来会更快。

我想先坦白一点：我个人并不使用 Neo-tree。我觉得我们刚才讨论的文件选择器是打开文件最快的方式，而当我需要操作文件系统时，我更喜欢使用 mini.files（我们将在本章后面讨论）。我更喜欢 mini.files 的主要原因是它使用的快捷键和 Vim 普通模式相同。模式很好，但是没必要搞太多！

不过，我猜很多读者会更喜欢 Neo-tree 提供的这种熟悉的树状视图体验。由于这个插件是 LazyVim 的默认配置，我想在本书中给它一个公平的介绍。

让我们先用 Space-e 快捷键打开 Neo-tree，这里的助记符是"e for Explore"（e 代表浏览）。如果你打开 Space 模式菜单，你会看到和模糊选择器一样，有两种方式可以打开 Neo-tree 浏览器：

- Space-e：在根目录下打开 Neo-tree
- Space-E：在当前工作目录下打开 Neo-tree

"根目录"和"当前工作目录（cwd）"的含义和我们在上一节讨论的一样。你会注意到小写字母和大写字母之间的一致关系：

- Space-ff 和 Space-e 都是打开根目录
- Space-fF 和 Space-E 都是打开当前工作目录

> 要隐藏 Neo-tree 浏览器窗口，只需在窗口可见时再次按 Space-e，或者在窗口处于焦点状态时按 q 键即可。

当打开浏览器时，它会显示相关目录中的所有文件和文件夹。所有文件夹都是折叠的，除了当前正在编辑的文件所在的文件夹（如果有的话）会被展开。比如，当我编辑这个文件时，我的 Neo-tree 看起来如下：

<img src="mymedia\neo-tree-dark.png" alt="neo tree dark" style="zoom:50%;" />

光标位于我当前正在编辑的文件上（左侧的page.svx上）。我可以使用常见的 j 和 k 键上下移动光标。

文件夹都被收集在视图的顶部。如果你将光标移动到这些文件夹上，你可以按回车键查看文件夹内的文件。同样，如果移动到某个文件上，也可以用回车键在当前 Vim 窗口中打开该文件。

你也可以通过鼠标双击来展开和折叠文件夹以及打开文件，但我猜一旦你学会了正确的键盘导航方式，你就不会想用鼠标了。

说到键盘导航，是的，如果要浏览的文件很多，用 j 和 k 上下移动可能会很慢。我们在第三章讨论过的所有命令都可以加上数字用来加快移动速度。例如，输入 10j 只需要三次按键就能让光标向下移动 10 行，而不是要按 10 次 j 键。使用 Control-d 或 Control-u 可以上下滚动树状视图。最有趣的是，即使 Neo-tree 当前没有获得焦点，也可以使用 s（seek）键来快速定位到 Neo-tree 视图中的任意一行。

Neo-tree 会将根目录或当前工作目录显示为最顶层目录。如果你需要向"上"导航到更高层级的目录，你需要使用退格键。

> 退格键在 Vim 中通常被写作 BS，所以如果你看到某个快捷键绑定或说明提到 BS 可以做某事，这不是在开玩笑（bullshit）！它就是指退格键。

除了导航和打开文件，你甚至可以使用 Neo-tree 对文件系统进行修改。例如，要删除一个文件，你可以将光标移到该文件上并按 d 键。这时会弹出一个窗口询问你是否确定。按 y 然后回车确认即可：

<img src="mymedia\neo-tree-delete-dark.png" alt="neo tree delete dark" style="zoom:50%;" />

要添加文件或文件夹/目录，使用 a 键并输入新名称。在名称末尾加上斜杠（/）表示创建文件夹。你也可以在 Neo-tree 浏览器中使用 A 键来添加文件夹，这样就不用手动输入末尾的斜杠了。

r 键可以用来重命名光标下的文件或文件夹。

要复制或移动文件，你可以使用 Neo-tree 的伪剪贴板。之所以说是"伪"剪贴板，是因为你不能用它来复制文件然后粘贴到比如 MacOS Finder 或 Windows 资源管理器中；它只能用于 Neo-tree 内部的操作。

如果想剪切文件并将其移动到树中的其他位置，使用 x 命令。如果想复制文件，则使用 y 键。y 的助记符是 yank（抽出），实际上这和在普通编辑器中复制文本用的是同一个键。要完成移动或复制操作，你需要导航到目标文件夹，然后使用 p 键（你可能还记得这代表"put"或"paste"，即放置或粘贴）。

Neo-tree 还有一个"过滤"模式，我觉得这个模式相当笨拙；它实际上只是在一个较小的窗口中模仿 Telescope/Fzf.lua 选择器的功能，所以我建议你还是使用你选择的选择器。如果你想使用 Neo-tree 的过滤模式，可以用 / 键进入，然后输入一些字符来将搜索结果限制在匹配这些字符的文件中。然后使用上下箭头键来浏览列表（这里不能用 j 和 k 键，因为你处于一种类似插入模式的上下文中）。

Neo-tree 还有很多其他很酷的功能。比如，我们稍后会介绍它在缓冲区、git 和符号导航方面的用途。在此期间，你可以在 Neo-tree 窗口获得焦点时按 ? 键（助记符是"问问题寻求帮助"）来获取概览，或者输入 :help neo-tree 来获取详尽的信息（就像从消防水管里喝水一样，量巨大）。

## [4.5. 替代方案 - Mini.files](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_mini_files_alternative)

正如我提到的，我实际上并不使用 Neo-tree 来进行文件导航。我觉得它给人一种"格格不入、不像 vim"的感觉。对我来说，它就像是一个恰好嵌入到 Neovim 窗口中的完全独立的体验。话说回来，我也不喜欢 VS Code 及其模仿的/被模仿的编辑器中的树状视图侧边栏体验，所以可能树状视图就是不适合我。

这些都只是我的个人观点，文本编辑器的黄金法则之一就是"所有观点都是有效的"（否则就会引发战争）。很多 Neovim 用户都很喜欢 Neo-tree，如果它符合你的思维模式，你就应该使用它。

话虽如此，显然不只是我有这样的想法，因为 LazyVim 还可选地提供了另一种文件管理体验，一个叫做 mini.files 的插件。这个插件默认是禁用的。

> Mini.files 是 mini.nvim 套件中的一部分，这是一组相对零散的 Neovim 软件包。这些插件之间相互独立，提供了许多本应该随 Neovim 一起发布的常用功能。有时候，mini.nvim 插件可能不如它们模仿的其他插件，但很多时候它们都是同类中最好的。Mini.files 并不是 LazyVim 附带的唯一一个 mini.nvim 插件，我们稍后会介绍其他插件。

Mini.files 文件管理器有点像是 Neovim 原生版本的分栏视图，这种视图在 macOS Finder 等文件管理器中很受欢迎。我喜欢它的主要原因是编辑目录列表就像编辑普通文本缓冲区一样。我不需要记住 a 在普通模式下表示"之后"，而在资源管理器模式下却表示"添加文件/文件夹"。相反，在 mini.files 中，我使用 o 键来"在当前行下方创建新行"，然后在 Neovim 的插入模式下输入新的文件名。之后，我让 mini.files 同步我的更改，它就会为新行创建对应的文件。

要使用 mini.files，你需要像启用 FZF 选择器那样将其作为 Lazy Extra 启用。具体步骤是：

1. 输入 :LazyExtras<Enter>
2. 将光标移动到包含 mini.files 的那一行（使用 Seek 模式最快）
3. 按 x 键来安装这个 Extra（额外功能）
4. 等待插件安装完成
5. 重启 Neovim

### [4.5.1. 使用 Mini.files](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_using_mini_files)

安装完成后，你可以使用 <Space>fm 和 <Space>fM 来显示 mini.files 视图。默认情况下，这些视图与我们在 Telescope、Fzf.lua 和 Neo-tree 中看到的 cwd/root 结构略有不同。它们在 <Space>f 菜单中的显示如下：

```tex
m -> Open mini.files (Directory of Current File)
M -> Open mini.files (cwd)
```

默认的 mini.files 配置没有在根目录打开的选项。我喜欢能够打开当前打开文件所在的目录，但我不想失去打开当前项目根目录的功能。我会在第 5 章介绍如何解决这个问题。

mini.files 菜单不是以侧边栏的形式显示，而是以并排的窗口列（称为 Miller 列）的形式显示。例如，当我在这本书的当前工作目录中打开 mini.files 时，会出现如下显示：

<img src="mymedia\mini-files-dark.png" alt="mini files dark" style="zoom: 80%;" />

左侧面板显示当前工作目录，中间列显示 book 目录的内容，其中我的光标当前位于第 4 章。右侧列显示第 4 章目录的预览，其中只包含一个文件。

与 mini.files 的交互非常类似于与标准 vim 窗口的交互。你可以使用 j 和 k 键上下移动光标。如果光标停在文件夹上，该文件夹的内容会立即显示在右侧；如果停在文件上，你会看到该文件的预览。

如果你想"进入"文件夹以与其内容交互，只需按 l 键向"右"移动。

同样，按 h 键将会从当前文件夹"退出"。如果光标在最左侧列，向左移动将打开一个新的最左侧列，这样你可以根据需要一直导航到文件系统的根目录。

要在当前活动的 Neovim 窗口中打开文件，请再次在该文件上按 l 键。这里的行为可能有点出人意料：文件会在 mini.files 视图下打开，但不会隐藏文件菜单。这允许你在关闭导航器之前打开多个文件，可以使用 q 键关闭导航器。

与 Neo-tree 相比，mini.files 的优美之处在于这些小窗口的行为就像普通编辑器一样，你已经习惯的所有导航功能都可以使用。例如，可以使用 Seek 模式导航到文件。按 s 键，然后输入你想搜索的任意字符。任何与输入字符匹配的项都会被标记，你可以通过输入指示的标签跳转到它们。

甚至修改文件系统也和编辑普通缓冲区完全一样。我们还没有真正介绍编辑（我和你一样惊讶），但这里有一个快速概述：

- 要重命名文件或文件夹，导航到包含它的行，然后进入插入模式来更改或添加文本。
- 删除文件或文件夹使用命令 dd，这是在普通 Neovim 窗口中删除整行文本的键绑定。
- 使用 yy 复制文件或文件夹，这是复制（"yank"）一行文本的命令。
- 使用 p 放置/粘贴已删除或复制的文件。

我们将在第 6 章讨论这些命令和更多内容。主要的一点是，你将来学习的几乎任何导航或编辑命令都可以在 mini.files 中使用。

**保存文件系统更改：**
使用这些键绑定进行的任何修改实际上不会保存到文件系统中，直到你按下 = 键，这是一个（罕见的）mini.files 特有的键绑定。我认为它的含义是"使文件系统等于我输入的内容"。这会弹出一个小窗口，告诉你 mini.files 想要代表你执行的操作，比如删除、移动、重命名或复制文件。你可以用 y 或 n（当然是表示 yes 或 no）来确认或拒绝这些更改。

我建议你同时尝试使用 Neo-tree 和 mini.files，直到你能决定更喜欢哪一个。最终，你会得出以下结论之一：

1. 你更喜欢 Neo-tree，不需要 mini.files。在这种情况下，重新进入 LazyExtras 模式，用 x 键禁用 mini.files。
2. 你在某些交互中使用 Neo-tree（可能是我们还没有介绍的功能，比如导航 git、缓冲区或符号），在其他情况下使用 mini.files。在这种情况下，你可能对 mini.files extra 的默认 LazyVim 配置感到满意。
3. 你和我一样特别，完全不想使用 Neo-tree，只想使用 mini.files。关于如何禁用插件将在下一章讨论。

## [4.6. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_summary_4)

在本章中，我们学习了在 LazyVim 中打开文件和与文件系统交互的四种不同方式：Telescope、Fzf.lua、Neo-tree 和 mini.files。每种方式都提供了不同的机制来打开和管理文件，你会发现其中一些方式相比另外的更适合你。

作为学习这些文件系统工具的副作用，我们还简单预览了如何配置插件和安装 LazyVim extras。我们将在下一章中更详细地讨论这些内容。

# [第五章：配置与插件基础](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_configuration_and_plugin_basics)

在第一章中，我已经多次提到了插件，你也见识过了 Lazy.nvim 插件管理器的实际运用。LazyVim 采用了一种独特的多层级插件管理方式，虽然需要一些解释，但在实际使用中非常优雅。

通过安装插件，你可以让 Neovim 实现一些默认情况下无法实现的功能。插件通常使用 Lua 或 VimScript 编写，不过通过 Neovim 的远程插件架构（即 RPC：Remote Plugin Architecture 调用机制），也支持使用其他编程语言。

```tex
-- init.lua
vim.g.python3_host_prog = '/path/to/python' -- 指定 Python 解释器

-- 过程：
Neovim 
  ↓ RPC 请求
插件主机(Host Process)
  ↓ 执行对应语言代码
返回结果
```

## [5.1. LazyVim 中的三类插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_the_three_categories_of_plugins_in_lazyvim)

LazyVim 中最简单的一类插件，是由 LazyVim 本身预装提供的。你已经使用过其中的许多插件了。有些插件（如 Neo-Tree、Telescope 和 Lazy.nvim）提供了自定义的用户界面组件供交互使用。另一些插件（如 flash.nvim 和 which-key）则提供了新的命令或模式。还有一些插件则在后台静默运行，比如自动匹配括号或标签，以及绘制缩进参考线。

这些预装插件在 LazyVim 中都配置了（通常来说）合理的默认设置。由于它们集成得很好，自定义这些默认设置是可行的，不过有时需要一些技巧，我们会在本章和后续章节中介绍这些内容。

第二类插件是"Lazy Extras（Lazyvim 的扩展功能）"。这些插件默认是不启用的，但如果你需要的话，只需几次按键就能启用。Lazy Extras 的存在使得安装流行插件变得容易，而且它们的配置能保证与 LazyVim 自带的其他插件和谐共存。

> （ethan）对于 Lazy Extras，我更偏向于理解为，是一个**功能**，而不是**插件**。一项 Lazy Extras，代表着启用某一个功能，这些功能会安装、启用一个或多个插件，并按照 Lazyvim 预设的配置来工作。

第三类是 LazyVim 不直接支持的第三方插件。你需要从头开始配置这些插件，并且要自己确保它们的快捷键绑定和视觉效果不会与 LazyVim 管理的插件发生冲突。在非 LazyVim 的配置中，所有插件都属于这一类，随着插件的更新迭代或逐渐停用，维护这些插件可能会成为一个令人头疼的问题。而在 LazyVim 中，这类插件相对较少，因此整体体验要愉快得多。

让我们通过三个文件管理插件的具体例子来说明，其中两个我们在上一章已经讨论过：

- Neo-tree.nvim

  是 LazyVim 预装的默认启用插件。LazyVim 对 Neo-tree 的默认配置不会与其他 LazyVim 插件产生冲突。不过，如果你想调整这些配置，可能需要做一些额外的工作。

- Mini.files

  作为 Lazy Extra（懒加载扩展）提供，基本上只需"一键"（既然我们在讨论 Vim，那就是一次按键！）就能安装，并且能够很好地与 LazyVim 配合使用。

- Oil.nvim

  是一个文件系统管理的替代插件，LazyVim 并不直接支持它。你可以通过几行配置在 LazyVim 中安装它，但它的设置不像 mini.files 那么简单，而且无法保证不会出现需要你自己解决的冲突。

从 Neovim 的角度来看，这些插件都是完全一样的，因为 Neovim 只认识第三方插件。LazyVim 只是提供了一些额外的结构，这些结构是你在使用插件时需要考虑的。通常这种结构会让事情变得更简单，但有时也会带来一些额外的麻烦。

## [5.2. Lazy Extras](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_lazy_extras)

在上一章中，我介绍了如何使用 Fzf.lua 和 mini.files，但对安装说明讲解得比较简略。现在我们将深入探讨这个话题。

你可以在仪表盘界面按 x 键来访问 Lazy Extras 模式。如果你当前不在仪表盘界面，需要先进入命令模式（按 :），然后输入 LazyExtras 并按回车确认命令（顺便说一下，你可以随时通过输入 :Dashboard 命令来显示仪表盘）。

无论通过哪种方式，你都会看到一个可安装插件的列表。在我的设置中，它看起来是这样的：

<img src="mymedia\lazy-extras-dark.png" alt="lazy extras dark" style="zoom:50%;" />

我目前已经安装了十多个扩展，主要是为了支持我涉猎的各种编程语言。你可以使用所有标准导航命令（如 j、k 或 s）来浏览这个文件。

无论你通过什么方式到达那里，一旦你的光标位于你想要安装的扩展（比如 editor.mini-files）所在行，只需按 x 键即可安装该扩展。如果你想要卸载它，操作方式相同：移动到相应的行（现在在"已启用扩展"列表下），再按 x 键禁用该扩展。这里的记忆方式是 x 代表"Extra（扩展）"。

你可能需要退出并重启 Neovim，让 Lazy.nvim 识别到扩展已安装并同步其依赖项。

当我们在 LazyExtras 界面时，我建议为你最常用的编程语言启用 lang.* 扩展。你还应该安装"推荐插件"部分中的所有插件（它们旁边有星号图标），但以下除外：

- ui.mini-animate，除非你的机器比我的性能好得多。这个插件在我的 2020 年款 Intel IMac Pro 上非常卡顿。
- editor.fzf，除非确定更喜欢它而不是 Telescope（就像我们在第 4 章讨论的那样）。

在你完成本书的阅读或有机会研究它们之前，我建议不要安装其他非推荐的扩展。否则，它们可能会以我无法预见的方式改变行为。

你可以访问 [https://lazyvim.org](https://lazyvim.org/) 并点击左侧菜单栏的"Extras"菜单项来获取每个扩展的更多信息。它包含了每个扩展安装的插件列表的链接，以及 LazyVim 为该扩展提供的配置。

## [5.3. 禁用内置插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_disabling_a_built_in_plugin)

迟早你会想要编辑你的 LazyVim 配置。虽然默认配置很棒，但可能无法 100% 完全匹配你的个人需求。

尽管 LazyVim 的大多数默认插件都是不需要考虑就该保留的，但你可能会发现有一两个插件是你不需要的。在大多数情况下，这并不重要，因为 LazyVim 只会在你实际使用插件时才加载它们，所以你可以直接忽略那些与你无关的插件。

我唯一禁用的 LazyVim 插件是 Neo-tree。我会展示如何做到这一点，你可以据此调整来禁用任何其他你想要禁用的插件。

首先我想介绍一下 LazyVim 的配置目录。你可以在仪表盘上直接按 c 键打开配置目录。或者你可以随时使用 Space 模式通过 Space+fc（"Find Config Files"的意思）来访问配置文件。

这将在你的文件选择器中加载 LazyVim 配置文件夹。这个文件夹通常位于 $HOME/.config/nvim。Neovim 默认加载 $HOME/.config/nvim/init.lua，如果你不使用 LazyVim，这就是你进行所有配置的地方。

LazyVim 中的 init.lua 配置文件，只是使用 require（Lua 语法中的一个关键字）语句来包含 LazyVim 配置基础架构。**通常你不需要修改这个文件**，即使大多数第三方插件的安装文件都假设你的配置在该文件中。相反，请按照本章所述的"LazyVim 方式"进行操作。

除了基本的 init.lua 外，LazyVim 在配置目录中还放置了一些配置文件和文件夹结构。

目前，我们主要需要知道的是，lua/plugins 子目录中的任何 Lua 文件都会被 LazyVim 自动加载，不管它们的名字是什么。我在这个文件夹中有几个不同的文件用于自定义配置。

我把存放禁用插件的文件命名为 disabled.lua。创建这个文件最简单的方法是打开一个现有的配置文件，然后使用 Neo-tree 或 mini.files 在同一文件夹中创建新文件，就像第 4 章中描述的那样。

当我在 lua/plugins 目录中创建 disabled.lua 文件时，我的本意是在其中收集所有我不想要的 LazyVim 插件，因为我假设 LazyVim 可能不完全符合我的需求。但实际上，这个列表非常短！这个文件的内容很简单：

```lua
return {
  { "nvim-neo-tree/neo-tree.nvim", enabled = false },
}
```

如果 LazyVim 默认启用的其他插件中有你不想使用的，只需遵循相同的语法即可。每个 Lua 表中的第一个参数是包含你想要禁用的 GitHub 仓库（包含所有者）的字符串。第二个参数是设置 enabled = false。就这么简单！

> 你迟早会在插件配置文件开头忘记写 return 语句。现在你知道要注意这一点了。

如果你不懂 Lua 语言...说实话，不用担心。我从没有正式学习过它，但是通过潜移默化，我已经掌握了足够维护我的 Neovim 配置的知识。

如果你比我更谨慎，你可以输入 :help lua 来阅读 Neovim 官方文档。然后查看 :help lua-guide-api 来了解 vim 特有的 API。

## [5.4. 修改键位绑定（示例）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_modifying_keybindings_example)

说到快捷键绑定，这是我在使用 LazyVim 时为数不多不太满意的地方，虽然这并不完全是 LazyVim 的问题。我总是搞不清楚应该在哪里定义这些快捷键！

配置快捷键绑定有三个可能的位置，具体取决于插件的配置方式：

1. 在 .config/nvim/lua/config/keymaps.lua 文件中。这里通常用于配置或修改那些与插件无关的快捷键，主要是用来修改 Neovim 核心功能或 LazyVim 的功能。
2. 在传递给插件的 Lua 表（在 Lua 中，"表"类似于其他动态语言中数组和记录或字典的组合）的 keys 字段中。这里通常用于设置插件的全局普通模式快捷键绑定。这就是我们将要在 mini.files 中使用的方式。
3. 在传递给插件配置的 opts（选项）参数中。每个插件的选项格式都是特定的，但很多插件更倾向于通过选项来为你设置快捷键，而不是让你自己去映射。这种情况在快捷键定义了不同的"模式"，或者只在插件当前打开或激活时才生效时特别常见。我也会用 mini.files 来演示这一点。

为了说明这一点，我想要"修复" mini.files 没有"在根目录打开"选项的问题。虽然我喜欢"在当前文件所在目录打开"的选项，但我也想要能够在根目录打开的功能。

> 请记住，根目录是指当前项目的最顶层目录，它通常由一些特定语言的文件（比如 package.json 或 Cargo.toml）的存在来确定。而 cwd（current working directory，当前工作目录）是编辑器的当前工作目录。

既然我已经禁用了 Neo-tree，我打算把 Space e 和 Space E 这两个快捷键重新分配给 mini.files，然后把现有的 Space fm 快捷键重新映射为打开根目录的功能，这样我就能使用全部三个命令了。当然，如果你觉得其他快捷键更符合你的使用习惯，或者你还在使用 Neo-tree，你可以选择不同的快捷键绑定。

我通过在 .config/nvim/lua/config/plugins/ 目录下创建一个名为 extend-mini-files.lua 的新文件来配置 mini.files。和 disabled.lua 文件一样，这个文件的名字可以随意取，只要确保它位于 plugins 目录下就行。

我习惯给所有用来修改 LazyVim 默认配置的文件名加上 extend 前缀。这样当我用 mini.files 或 Telescope 查看目录时，就能很容易地把它们和我额外安装的非 LazyVim 插件区分开。

在这个新文件中，我使用了以下代码：

```lua
return {
  "echasnovski/mini.files",
  keys = {
    {
      "<leader>e",
      function()
        require("mini.files").open(vim.api.nvim_buf_get_name(0), true)
      end,
      desc = "Open mini.files (directory of current file)",
    },
    {
      "<leader>E",
      function()
        require("mini.files").open(vim.uv.cwd(), true)
      end,
      desc = "Open mini.files (cwd)",
    },
    {
      "<leader>fm",
      function()
        require("mini.files").open(LazyVim.root(), true)
      end,
      desc = "Open mini.files (root)",
    },
  },
}
```

我是通过从 LazyVim 网站上提供的 Telescope find files 和 Neo-tree 插件的默认配置中提取相关函数调用来构建这段代码的。

为了满足 Lazy.nvim 的要求，我们需要返回一个用花括号包裹的 Lua 表。Lua 表的特点是可以同时作为数组和字典使用。在这个例子中，表的第一个元素是字符串 "echasnovski/mini.files"。它没有指定键名，所以可以理解为一个"位置参数"（从 GitHub 上哪里下载）。

表中的第二个元素更像是一个"命名参数"，它通过 keys 这个名字来索引，其值是另一个 Lua 表。不过，这第二个表更像是一个包含三个值（三个独立的 Lua 表）的"数组"，因为它没有命名索引。

需要注意的是，keys 字段会与 LazyVim（extras）为 mini.files 提供的默认配置中的 keys 进行合并。如果出现冲突（比如 space fm），**我们的配置会覆盖默认值**。

这是 LazyVim 的一个强大特性，让我们可以使用 LazyVim 提供的托管配置，同时根据需要进行覆盖。早期的 Neovim 发行版通常没有这么灵活，所以你要么只能使用他们的配置，要么就得复制整个配置然后修改，这让更新变得非常麻烦。

需要说明的是，keys 是 LazyVim 的概念（严格来说，它其实是底层的 Lazy.nvim 插件管理器的一部分）。任何插件配置都可以有一个 keys 数组表，这些键位绑定会与 Neovim 的默认键位绑定、LazyVim 的键位绑定、你的自定义全局键位绑定以及其他插件的键位绑定进行合并。

是的，这确实可能会产生很多冲突，这也是为什么我非常感激 LazyVim 帮我处理了大部分配置工作！

### [5.4.1 键位配置项的结构](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_structure_of_a_keys_entry)

keys 表中的每一项都是一个包含（在这个例子中是）三个字段的 Lua 表。前两个字段是位置参数，分别表示键位绑定名称和当这个键位被触发时要调用的 Lua 回调函数。第三个字段是一个命名字段 desc，它提供了一个字符串描述，这个描述会显示在 Space 模式菜单中。

第一个配置项中的键位序列使用的是标准的 Vim 语法。这里的 <leader> 是一个古老的 Vim 概念，它允许你配置哪个键作为自定义键位绑定的前缀。在 LazyVim（实际上对大多数现代 Neovim 用户来说也是如此）中，leader 键被设置为 <Space>。特殊键需要用尖括号来指示给 Vim 的键位绑定引擎，所以你经常会看到像 <Space>、<Right>、<Left> 或 <BS> 这样的表示方法。

在 <leader> 字符串之后，我们需要包含所有需要按下的额外按键。对于简单的情况，我们用 e 和 E 来替换我们之前禁用的 Neo-tree 键位绑定，改为新的 mini.files 键位绑定。第三个键位绑定稍微复杂一些，其中的 f 表示这个动作将在 Space 模式的 file/find 子菜单中可用，而 m 则指示了这个菜单中将使用的字母。

对于回调函数，我们使用 Lua 函数，它们总是以 function 开始，以 end 结束。这些都是匿名（未命名）函数，它们的括号中不接受任何参数。在函数体内，我们调用特定的代码来按照我们想要的方式打开 mini.files。其中的两个函数，是我直接从 LazyVim 的默认 mini.files 配置中复制过来，第三个则是我通过组合 Neo-tree 和 mini.files 配置中的代码拼凑而成。LazyVim 全局对象是一个很方便的库，包含了许多用于辅助配置的实用函数。LazyVim.root 函数用于查找项目的根目录，并返回一个字符串，我们将这个字符串传递给 mini.files.open。

### [5.4.2. Mini.files 选项自定义](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_customizing_mini_files_options)

正如我提到的，keys 表会与 LazyVim 为 mini.files 配置的默认 keys 表合并。类似地，大多数 Neovim 插件都可以通过一个 opts 表来配置，这个表包含了该插件的特定自定义配置。如果你提供了一个 opts 表，它会与 LazyVim 的默认配置（如果存在的话）合并。

你需要阅读每个插件的文档（通常可以在 Github 上找到，也可以通过 :help plugin-name 查看）来了解该插件具体有哪些可用的选项。你还需要查看 LazyVim 为该插件设置的默认配置，以便理解它们将如何合并。

在我的情况下，我向 mini.files 传递了以下 opts 数组：

```lua
return {
  "echasnovski/mini.files",
  keys = {
    -- the keybindings from above
  },
  opts = {
    mappings = {
      go_in = "<Right>",
      go_out = "<Left>",
    },
    windows = {
      width_nofocus = 20,
      width_focus = 50,
      width_preview = 100,
    },
    options = {
      use_as_default_explorer = true,
    },
  },
}
```

mini.files 中的 mappings 表用于覆盖在 mini.files 视图打开时生效的默认键位映射。这与我们之前定义的用于打开 mini.files 的全局键位映射是不同的。在我的情况下，我将 go_in 和 go_out 映射到方向键而不是 h 和 l，这是因为我之前提到的左手 Dvorak Kinesis 键盘的特殊性。我不建议你做这样的更改；对于大多数人来说，h 和 l 会更好用。

window 选项的设置是因为我使用的是 32 英寸的 6k 显示器，这意味着我可以设置比正常更大的资源管理器列宽。关于这些和其他选项的更多信息，请参考 :help mini.files。

现在你对在 LazyVim 中配置插件有了一些了解。与从头开始配置插件相比，这种方式既有更简单的一面，也有更复杂的一面：

更简单是因为你只需要修改非默认值，而不是设置整个配置，并且 LazyVim 提供了合理的默认设置。

但也更复杂，因为你有时需要考虑选项和键位绑定是如何合并的，如果一开始就有一个完整的配置对象，就不需要考虑这个问题了。对于那些在 LazyVim 中有复杂默认配置的插件来说，这种合并可能会变得相当棘手。我们稍后会看到一些例子。

## [5.5. 修改现有选项](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_modifying_existing_options)

当我们想要修改 LazyVim 中的插件设置时，有时候事情没那么简单。LazyVim 默认的"合并"方式可能不够灵活，特别是当插件的设置涉及到函数而不是简单的配置项时。

为了解决这个问题，在 Lazy.nvim 的插件配置中，opts（选项）不一定要是一个固定的配置表，它可以是一个函数。这个函数会接收到 LazyVim 原本的配置，你可以在这个函数里直接修改这些配置。

举个具体例子： nvim-cmp 是一个在你输入代码时提供自动补全提示的插件。它很好用，但在 LazyVim 的默认设置中，按回车键会选中补全建议。对我来说这很烦人，因为我在写文章时经常需要按回车换行，但每次按回车都可能不小心选中了一个我不想要的补全。

LazyVim 的文档里提供了几种修改这个行为的方法，nvim-cmp 的说明文档里也有一些其他解决方案。下面我会展示我是怎么修改这个设置的：

```lua
return {
  {
    "hrsh7th/nvim-cmp",
    opts = function(_, opts)
      local cmp = require("cmp")
      opts.mapping = vim.tbl_extend(
        "force",
        opts.mapping,
        {
          ["<Right>"] = cmp.mapping.confirm({ select = true }),
          ["<CR>"] = function(fallback) cmp.abort() fallback() end,
        }
      )
    end,
  },
}
```

首先，这里说的 opts 函数会接收到 LazyVim 默认的配置作为它的第二个参数。就像是你收到了一份已经写好的配置菜谱，现在你要在上面做一些修改。

我用了 Neovim 提供的 tbl_extend 函数来修改这些配置。具体做了两件事：

1. 添加了一个右方向键（<Right>）来确认补全建议 - 这个设计是参考了 fish shell 的操作方式
2. 把回车键（<CR>）的功能改成了取消补全 - 这样按回车就不会选中补全建议了

说实话，这种改配置的方式确实比直接从头写一个完整的配置要麻烦一些。就像是你想改一道菜的做法，与其改别人的菜谱，不如直接写一个自己的菜谱来得简单。

但是！如果要我从零开始写所有配置，那就更麻烦了。这就像是与其修改大厨的菜谱，自己从头开始研究怎么做菜要困难得多。

所以我觉得这是个值得的权衡 - 因为 LazyVim 在很多地方的配置都比我自己写的要好。就像是虽然要改动大厨的菜谱有点麻烦，但至少保证了菜的基本味道不会差。

## [5.6. 安装第三方插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_installing_third_party_plugins)

安装第三方插件其实和配置 LazyVim 自带的插件差不多，但有一个好处：你不用担心你的设置会和默认配置打架（因为根本就没有默认配置需要合并）。

具体步骤很简单：

1. 在 plugins 目录下创建一个新的 Lua 文件
2. 文件名最好能反映这个插件是做什么的
3. 在文件里，你要返回一个 Lua 表（table），这个表里：
   - 第一项必须是插件的 GitHub 地址和名字
   - 后面可以跟上其他配置，比如 opts 和快捷键设置等

来看个实际的例子： 我喜欢用 guess-indent.nvim 这个插件，它能根据我正在编辑的文件内容自动设置缩进宽度。这个插件是由 GitHub 用户 nmac427 维护的。

所以我的 plugins/guess-indent.lua 文件是这样写的：

```lua
return {
  "nmac427/guess-indent.nvim",
  opts = {
    auto_cmd = true,
    override_editorconfig = true
  },
}
```

opts 表里该放什么完全取决于插件本身的要求。比如我看了 guess-indent.nvim 的说明文档后，发现有两个选项是我想设置的。

现在大多数 Lua 插件的文档都会告诉你要调用一个 setup 函数，并传入一个包含配置的 Lua 表。如果你要设置的插件没有专门的 Lazy.nvim 使用说明也别担心：你只要把原本要传给 setup 函数的那些配置放到 LazyVim 插件管理器的 opts 里就行了。

我推荐一个很好用的第三方插件：chrisgrieser/nvim-spider。这个插件很巧妙地改进了 w、e 和 b 这些命令，让它们能够在 CamelCase 和 snake_case 的单词内部导航。

我在 plugins 目录下创建了一个 nvim-spider.lua 文件，内容如下：

```lua
return {
  "chrisgrieser/nvim-spider",
  opts = {},
  keys = {
    {
      "w",
      "<cmd>lua require('spider').motion('w')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to start of next of word",
    },
    {
      "e",
      "<cmd>lua require('spider').motion('e')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to end of word",
    },
    {
      "b",
      "<cmd>lua require('spider').motion('b')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to start of previous word",
    },
  },
}
```

这个插件不会自动设置快捷键，所以我在插件配置中加入了 keys 表。这个数组不会传给插件本身，而是由 Lazy.nvim 插件管理器解析后添加到全局快捷键中。把快捷键配置和插件配置放在一起是个好习惯，这样所有相关配置都在同一个地方。

我看了 nvim-spider 的说明文档后，觉得它的默认选项就挺好的，所以就传了个空的 opts 表。

想找优质的第三方插件，最好的地方就是 github 上的 rockerBOO/awesome-neovim 仓库。这个列表维护得很好，而且（最重要的是）会定期更新，所以很少有过时或无人维护的插件。

实际上，LazyVim 已经自带了大多数最优质的插件（内置的或作为扩展的），所以你需要额外添加的插件不会太多。不过如果你遇到"要是 LazyVim 能做到..."这样的想法，答案很可能是：它已经可以做到了，相关插件就在 Awesome Neovim 仓库里。

## [5.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_summary_5)

在这一章中，我们学习了 LazyVim 是如何与更广泛的 Neovim 插件生态系统集成的。LazyVim 提供了合理的默认插件和配置，同时也让你能轻松地根据自己的需求进行定制。

我们了解到内置插件、额外插件和未知的第三方插件虽然处理方式略有不同，但都遵循一致的配置方法。我们还通过实例学习了如何安装一些第三方插件。

现在你已经知道了：

- 如何打开文件

- 如何配置插件

接下来我们要回到模式编辑（modal editing）的基础部分。你已经知道了：

- 如何在普通模式（Normal）和插入模式（Insert）之间切换
- 如何在代码中导航

在下一章，我们将介绍一些基本的编辑功能，这些功能模糊了"导航"和"插入文本"之间的界限。

# [第六章：基础编辑](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_basic_editing)

通过前面学习的导航快捷键，以及能够随心所欲地进入和退出插入模式，你在 Vim 中的编辑体验已经接近于传统非模态编辑器的水平了。

不过，对于一个软件开发者来说，仅仅会移动光标和插入文本是远远不够的。我们更多时候需要编辑文本：删除代码、修改代码、重构代码、移动代码。这些才是我们日常工作中最常做的事情。

当然，你可以通过移动到目标位置然后进入插入模式来完成这些操作。在插入模式下，删除键和退格键的功能和其他编辑器是一样的。但是，Vim 提供了更多高效的工具。

最棒的是，在要使用到的这些强大的编辑命令中，你其实已经掌握了大部分需要的基础知识！

## [6.1. Vim 命令的思维模型](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_the_vim_command_mental_model)

你已经学过的导航命令，比如 s、f、hjkl 和 web 等，统称为动作命令（motion commands）。它们的作用是将光标从当前位置移动到新位置。

大多数动作命令前面都可以加上数字（count），所以导航模式总是遵循 <数字><动作> 的格式。数字通常用来重复执行某个动作特定次数，但有些命令会把这个数字当作绝对值使用，比如用于"跳转到指定行"的 Shift-G。如果没有指定数字，默认值通常是 1。即使是使用标签的 Seek 命令也允许在前面加数字...虽然这个数字会被忽略！

<数字><动作> 命令在导航时很有用，到目前为止我们也只是把它用于导航。但是，如果把它和动词（verb）组合使用，就可以对光标位置和动作目标位置之间的文本进行操作。

动词总是放在最前面，所以命令结构永远是 <动词><数字><动作>。导航可以看作是"默认"动词，所以如果省略动词，光标就会移动到动作指定的位置。我们将在本章讨论几个重要的动词。

但这个模型还可以更复杂！动词前面也可以加数字。这样语法就变成了 <数字><动词><数字><动作>。不过说实话，我从来没有在一个命令中同时使用过这四个部分。通常我们要么用 <数字><动词><动作>，要么用 <动词><数字><动作>。

这个模型的好处在于，它让你可以分而治之地学习，并且能够重复利用已掌握的知识。你先学习了动作命令，然后学习了数字，现在要学习动词。将来如果你学习新的动作命令或动词，都可以把它们和已知的动词、动作组合使用，而且它们的行为方式都是可预测的。

> 很多插件都试图模仿这种策略，而且大多数都做得不错。我对 Neo-tree 主要的不满是它没有遵循 <动词><动作> 的思维模型，而 mini.files 做到了这一点。同样，有些人认为 Seek 模式违反了 Vim 的思维模型，因为在 Seek 模式中使用数字没有意义。我的观点是，Seek 模式只是超越了数字的概念，但它仍然可以和动词很好地组合，所以它仍然是一个有效的 Vim 模型。

### [6.1.1. 关于插入模式的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_a_note_on_insert_mode)

和所有模型一样，这个模型也不是完美的。比如，你可以在 i、I、a 和 A 命令前面加数字，但很明显"进入插入模式"既不是动作也不是动词。

举个例子，如果你输入 5ifoo<Escape>，Neovim 会帮你插入 foofoofoofoofoo。这看起来可能用处不大，但如果你想在标题下面画一条由 80 个星号组成的分割线，用 80i*<Escape> 就非常方便！

但是，这种带数字的 i "非动作"命令不能像你学过的导航命令那样与动词组合使用。所以了解这个模型的局限性很重要。

现在你已经明白了如何将已经掌握的动作命令与动词组合来执行导航以外的操作，接下来你只需要学习一些动词就可以了。

## [6.2. 删除文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_deleting_text)

我之前已经预示过几次了，即使没有预示，你可能也能猜到删除文本的动词是 d。

当 <动作> 命令会将光标移动到代码中的特定位置时，d<动作> 会删除光标位置到目标位置之间的所有文本。以下是一些例子：

- dh 删除光标左边的字符
- d3w 删除三个单词
- 3dw 分三次删除一个单词
- d^ 删除从光标到行首的内容
- d2fe 删除从光标位置到光标后第二个 e 之间的所有文本（包括第二个 e）
- d2Ta 删除从光标到光标前第二个 a 之间的所有文本（不包括第二个 a）
- dsfoos 删除从当前光标位置到使用 Seek 模式查找 foo 时出现的标签 s 之间的文本。注意，Seek 模式总是跳转到你搜索的单词的开头。这意味着如果找到的 foo 在当前光标位置之后，oo 不会被删除，但 f 会被删除。但如果找到的 foo 在当前光标位置之前，foo 的所有三个字母都会被删除

如果以上任何操作让你感到困惑，可以暂时忽略 d，回顾第三章来复习这些动作命令。

所以 d 可以和你已知的所有动作命令配合使用，也可以和你还不知道的所有动作命令配合使用，甚至可以和你尚未安装的插件定义的所有动作命令配合使用。

当删除命令执行完成后，Neovim 仍然会保持在普通模式，你可以立即执行任何其他的 <动词><动作> 组合。

## [6.3. 修改文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_changing_text)

另一个常见的任务是编辑文本。比如替换一个单词，更正拼写，删除段落剩余部分并替换成新内容等。

这些操作可以通过组合删除动词和插入模式来完成（例如 dwi 会删除一个单词并进入插入模式）。不过，你可以使用 c 动词来节省一次按键，c 表示"修改"（change）。如果你把上面例子中的 d 都换成 c，就相当于"删除文本并立即进入插入模式"。以下是一些例子：

- ch 删除光标左边的字符并进入插入模式
- c3w 删除三个单词并进入插入模式
- 3cw 分三次删除并修改单词
- c^ 删除从光标到行首的内容并进入插入模式
- c2fe 删除从光标到第二个 e 之间的文本并进入插入模式
- c2Ta 删除从光标到前面第二个 a 之间的文本并进入插入模式
- csfoos 删除从光标到 Seek 模式找到的 foo 之间的文本并进入插入模式

这样你就可以立即输入新的文本来替换被删除的内容。当你完成编辑并按下 <Escape> 后，Neovim 会返回到普通模式。

## [6.4. 操作到当前行末](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_operating_to_end_of_the_current_line)

从光标位置删除或修改到当前行末（保留行首内容）是非常常见的操作。在源代码编辑中，这些操作的频率比你想象的要高，所以有一个专门的快捷方式。

是的，你可以使用 d$ 和 c$ 来删除或修改到行末，因为 $ 是"跳转到行末"的动作命令。这符合我们之前学习的思维模型。但是，由于这是一个如此常见的操作，你可以使用大写的 D 或 C 来"取巧"，少按一个键。

但是没有相应的"删除到行首"的快捷动词，所以你只能使用 d^ 或 d0。其中：

- ^ 是跳转到第一个非空白字符的动作
- 0 是跳转到行首第一列的动作（不管是否是空白字符）

所以总结一下：

- D = d$ （删除到行末）
- C = c$ （修改到行末）
- 删除到行首需要用 d^ 或 d0
- 修改到行首需要用 c^ 或 c0

## [6.5. 对整行进行操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_operating_on_entire_lines)

另一个常见的操作是修改或删除整行文本。这种操作非常频繁，以至于有专门的"整行"动作命令。这些动作通过重复动词来实现。这又是一个 vim 思维模型有点失效的地方，因为动作的解释取决于动词。

实际使用中，这意味着：

- dd 删除整行
- cc 删除整行并进入插入模式

这些命令很容易输入，所以是很好用的简写方式。

你可以将这些特殊动作与数字组合使用：

- d3d 删除三行
- 3dd 删除一行三次（这种方式打字更快，因为你不需要把手指从 d 键移开就能按两次）

是的，这两种方式的结果是一样的，但模型允许你使用其中任何一种。需要注意的是，在某些情况下，这两种格式可能会有细微的行为差异，不过在实践中我从未遇到过意外情况。

这种整行操作的设计使得处理整行文本变得非常高效，这在编程时特别有用，因为我们经常需要删除或修改完整的代码行。

## [6.6. 修改单个字符的快捷方式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_some_shortcuts_for_modifying_individual_characters)

修改单个或特定数量字符是另一个常见操作。你可以使用 dl 删除光标下的字符，或用 4dl 删除当前字符及后面的三个字符。但是，由于这个操作非常频繁，有一个不需要动作（或者说动作是隐含的）的快捷动词：x。例如，如果你想把英式拼写改为美式拼写，可以用 x 删除 "behaviour" 中多余的 u。单个字母会被删除，然后你会回到普通模式继续操作。

x 命令可以和数字配合使用，如果你想从光标位置开始删除五个字符，只需使用 5x。

如果你需要向反方向删除（删除光标前的字符），使用大写的 X。这个命令也可以带数字，会删除光标左边指定数量的字符。我很少使用这个命令，因为需要按 Shift 键就已经是两次按键了，用 hx 或 d4h 也可以做到。

如果你想把一个字符替换成另一个字符，使用 r 命令。这个命令会短暂进入插入模式让你输入一个字符，然后立即返回普通模式。对于常见操作（拼写错误很常见，对吧？不只是我吧？）来说，这比像 cle<Escape> 这样的操作要少按很多键。r 命令也可以带数字，但行为可能不太有用：它会用同一个字母替换光标下的字符及其后面指定数量的字符。这个功能唯一可能有用的场景是当你从某处复制密码提示时，需要把密码中的所有字符都替换成 *。

另一个常见操作是删除当前行末尾的换行符。在行内任何位置使用 J（"**J**oin Lines"）命令。我经常使用这个命令。如果你需要合并多个连续的行，J 可以带数字。它通常会正确处理空白（用单个空格替换缩进），但如果你需要在不修改空白的情况下连接行，使用两字符动词 gJ。

总结一下：

- x：删除光标下的字符
- X：删除光标前的字符
- r：替换光标下的字符
- J：连接行（处理空白）
- gJ：连接行（保留空白）

## [6.7. 大小写操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_manipulating_case)

如果你需要将字符或一系列字符转换为大写，使用动词 gU（第二个字符是大写 U）加上任何标准导航动作。我觉得这个动词有点令人困惑，因为 g 通常用于 Go To（跳转）动作。但在这里（如同上面的 gJ），它是一个动词。

你可以把它理解为"跳转并转换为大写"，其中 U 是 Uppercase 的缩写。

相反的操作是使用小写的 gu 加动作，可以将光标位置到动作目标之间的所有文本转换为小写。这个设计虽然有点奇怪，但符合 Vim 的惯例：gu 表示一个动作，而 gU 表示相同的动作但更"大"。

重复命令 gUgU 和 gugu 与其他重复动词（dd、yy、cc）类似，将大/小写转换应用到整行。不过这个按键序列相当烦人，所以使用可视模式（我们将在第 8 章介绍）可能更好 - 用 V 选择一行，然后使用可视模式的 U 或 u 命令。

我觉得这些命令用处不大。我更常用 ~ 命令，它可以反转光标下字符的大小写。

> 如果你经常需要进行大小写转换工作，可以看看 coerce.nvim 插件。它没有包含在 LazyVim 的额外功能中，所以你需要自己配置，但可能值得花这个功夫。

总结命令：

- gU{动作}：转换为大写
- gu{动作}：转换为小写
- gUgU 或 gugu：转换整行
- ~：反转当前字符大小写
- 可视模式：V + U/u

## [6.8. 重复命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_repeating_commands)

LazyVim 没有多光标模式。虽然有支持多光标的插件，但根据我的经验，它们工作得并不是很好。Neovim 开发者已经将多光标功能列入了他们的开发计划，所以我希望他们能开发出一个很好地融入 Vim 思维模型的范式。

> （ethan）我觉得 [vim-visual-multi](https://github.com/mg979/vim-visual-multi) 挺好的

在此期间，Neovim 提供了几种不同的工具来在代码中的多个位置执行操作。我们这里会介绍基本的重复操作，其他有用的技巧将在后面的章节中介绍。

当你执行任何动词后，你可以导航到文档中的另一个位置，然后用一个键重复那个动词：.（这是一个句点，在这个上下文中通常被称为"点重复"）。

这突显了为什么 d 和 c 需要是独立的动词，而不是使用类似 d<motion>i 这样的组合。当你使用 c 时，删除动作和你插入的文本都会被记住，所以你可以用 . 命令重复整个更改。例如，如果你想把所有名为 i 的变量替换成更好的名字 index，你可以跳到第一个 i 处，输入 clindex<Escape> 来"将一个字符改为 index"。然后你可以使用导航命令去到下一个 i。现在只需输入 . 来重复这个更改，然后继续找下一个实例。

像动作和动词一样，. 命令也可以带数字。不过，. 的数字使用有一些细微差别。它不是简单地重复命令 <count> 次，而是会替换被重复命令的数字。

这意味着如果你使用动词 3dd 删除三行，然后下一个操作是 2.（"2点"），第二个操作将删除两行，而不是六行。

关键点：

- . 命令可以重复上一个修改操作
- 特别适合配合 c（change）命令使用
- 数字会替换原命令的数字，而不是重复次数
- 这是在没有多光标模式下的一个重要替代方案

## [6.9. 录制命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_recording_commands)

Vim 的命令录制和回放系统非常强大。你可以轻松地录制任意序列的导航、编辑和插入命令，然后在任何想要的位置按需重复该序列。

要开始录制，按 qq。抱歉，我没有什么帮助记忆 q 命令的方法。我感觉这可能只是因为它是键盘上最后一个可用的键！

之后，输入你想要录制的任何导航、编辑和插入命令序列。删除单词、插入文本、更改文本、搜索单词（不要使用 Seek 模式，因为回放机制不知道要跳转到哪个标签）。实际上，在 Vim 中你能做的几乎任何事情（甚至包括 : 命令）都可以被录制并在之后重放。

当你完成录制时，只需再次按 q。录制的内容就会被存储起来，随时可以重放。

主要要点：

- 使用 qq 开始录制
- 可以录制几乎所有 Vim 操作
  - 导航命令
  - 编辑命令
  - 插入命令
  - 搜索命令（除了 Seek 模式）
  - 冒号命令
- 再次按 q 结束录制
- 录制的命令可以随时重放

### [6.9.1. 追加录制](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_appending_to_a_recording)

如果你完成部分录制后，发现需要一些额外信息或在完成录制前需要进行编辑，你可以像平常一样用 q 停止录制，然后做你需要做的事情。

当你准备继续录制时，使用 qQ 进入追加录制模式。这里的主要提示是，你需要确保光标位置在一个合适的位置，使得合并后的录制内容是有意义的。这通常意味着要回到停止录制时的位置，当然这也可能取决于你在此期间做了什么改动。

### [6.9.2. 回放录制](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_playing_back_a_recording)

回放最近保存的录制内容最简单和最快的方法是使用大写的 Q。

> 可以使用寄存器（这是一个愚蠢的名字，源自人类汇编编程的黑暗时期，用于表示存储位置）同时存储和替换多个录制。我们将在第 8 章详细讨论寄存器。

关键点：

- 追加录制
  - 使用 qQ 继续录制
  - 需要注意光标位置的合适性
  - 确保合并后的录制内容有意义
- 回放录制
  - Q 快速回放最近的录制
  - 可以使用寄存器存储多个录制
  - 寄存器相关内容将在第 8 章详细介绍

## [6.10. 撤销和重做](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_undo_and_redo)

显然，这些是整本书中最重要的操作！使用 u 键来撤销你最近的更改。注意，"最近的更改"可能包含相当多的文本，特别是如果你长时间没有退出插入模式。例如，我在一次插入会话中写完了整个段落。如果我按 u，整个段落都会消失。

不过没关系，因为我可以用 Control-r 重做。像大多数开发者一样，我经常使用这两个功能。（你知道吗？在打字机时代，秘书们的打字测试必须达到 100% 的准确率，因为那时候没有退格键或删除键。）

Neovim 实际上在跟踪你的整个历史记录方面做得非常出色，而不仅仅是最近的一系列更改。所以如果你做了一系列更改到达状态 B，然后撤销回到状态 A，之后又做了一系列更改到达状态 C，你仍然可以回到状态 B（即：从 C 状态撤销回到 A 状态，然后重新应用 B 的更改回到 B 状态）。

这有点像 git 分支的概念，只不过你的历史记录是针对每个按键自动跟踪的。不过，使用原始的 Neovim 命令处理撤销历史的分支可能会感觉很笨拙（如果你够勇敢的话，可以阅读 :help undo-branches）。相反，我建议配置和安装 undotree 插件。

99.9% 的情况下，u 和 Control-r 就足够了，但在剩下的 0.1% 的情况下，undotree 可能会成为救星。

## [6.11. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_summary_6)

在本章中，我们扩展了对 Vim 思维模型的理解，并介绍了几个可以与我们已经熟悉的导航动作相结合的动词。

我们讨论了各种其他编辑命令，然后介绍了如何使用 . 和命令录制来重复操作。最后，我们介绍了撤销和重做功能。

在下一章中，我们将学习文本对象以及 Vim 思维模型中与操作符待决模式（operator-pending mode）相关的一些细微差别。这些结合在一起，使我们能够非常快速地对各种代码结构执行操作。

本章要点：

- 扩展了 Vim 思维模型的理解
- 学习了新的编辑动词命令
- 介绍了各种编辑命令
- 学习了使用 . 重复命令
- 掌握了命令录制功能
- 了解了撤销（u）和重做（Control-r）
- 为下一章的文本对象和操作符待决模式做准备

# [第七章：对象和操作符待决模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_objects_and_operator_pending_mode)

我们之前学习的导航和移动命令固然重要，但 Neovim 还提供了更多高级的移动命令，可以大大提升你的编辑效率。LazyVim 通过各种插件进一步扩展了这些移动命令，带来了更强大的导航功能。

比如，当你在编辑普通文本而不是源代码时，按句子和段落进行导航就会很有用。这里所说的"句子"，就是指以句号(.)、问号(?)或感叹号(!)结尾，并且后面跟着空白字符的内容。

说实话，这些句子相关的快捷键对我来说是最难记住的。因为用得不够频繁，所以还没有形成肌肉记忆，而且也没有一个好记的助记方法。

听起来很神秘是不是？接下来要说的内容请特别注意，因为很容易就会忘记。在普通模式下，要向前移动一个句子（移动到句子结束标点符号后的空白字符之后），按 ) （右括号）。要移动到当前句子的开头，使用 (（左括号）。重复按括号可以在句子之间移动，如果想一次移动多个句子，可以在按键前加上数字。

我其实不太喜欢用 ( 这个命令，因为按理说它应该是用来移动到括号的位置才对！但事实并非如此，它是用来在句子之间移动的。由于在日常软件开发中，句号、感叹号和问号很少表示"句子"的结束，所以我平时用得不多，只有在写书的时候才会经常用到（虽然我一直告诉自己不要再接写书的活了，但总是控制不住）。

不过，我倒是经常使用段落移动命令。在这里，"段落"指的是两个空行之间的所有内容。这个概念在编程环境中很实用，因为大多数开发者都会用空行来分隔逻辑相关的代码块。使用大括号 { 和 } 可以在段落之间上下移动。如果需要一次跳过多个段落，和其他命令一样，可以在按键前加上数字。

同样，你可能会觉得 { 应该是用来跳转到花括号的，但它实际上是用来跳转到空行的，这一点确实有点让人困惑。不过一旦习惯了，你可能会经常用到它。

## [7.1 Unimpaired（成对）模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_unimpaired_mode)

LazyVim 提供了一系列可以通过**方括号**访问的移动命令。完全掌握这些命令需要一些时间，但好在你只需按一下 [ 或 ] 就能调出命令菜单。和句子、段落移动命令类似，方括号命令也允许你移动到上一个或下一个"某物"，具体是什么取决于你在方括号后面按的键。

这些成对的导航技巧通常被称为"Unimpaired（成对）模式"，这个名字来源于著名的 Vim 插件作者 Tim Pope 开发的一个基础插件 [vim-unimpaired](https://github.com/tpope/vim-unimpaired)。虽然 LazyVim 没有直接使用这个插件，但保留了这个插件的核心理念（用 [ 和 ] 作为前缀，提供许多成对的操作）。

当你输入 ] 并暂停等待菜单时，会看到如下选项：

<img src="mymedia\unimpaired-menu-dark.png" alt="unimpaired menu dark" style="zoom:50%;" />

这些选项并非都与导航相关，其中有一个选项是因为我启用了相应的 Lazy Extra 才会显示。我们这里先介绍与移动相关的命令，其他的会在后面的章节中详细讲解。

首先，用于处理 (、< 和 { 的命令比看起来要复杂得多。它们并不是简单地跳转到下一个（如果你用了 ]）或上一个（如果你用了 [）括号、尖括号或花括号。如果你只想这样做，直接用 f( 或 F( 就可以了。

相反，这些命令会跳转到下一个未匹配的括号、尖括号或花括号。这意味着像 [( 或 ]} 这样的按键实际上是"跳出"的意思。所以如果你在一个被 {} 包围的代码块中间，无论这个代码块内部有多少其他用花括号分隔的代码块，你都可以用 ]} 轻松跳到当前块的结尾，或用 [{ 跳到开头。这在各种编程场景中都很有用，所以值得花时间去熟悉它。

例如，考虑如下代码：

```python
def outer_function() {
    if (condition) {
        for (i = 0; i < 10; i++) {
            print("hello") ▊    # 光标1
        } ▊    # 光标2
    }
}
```

在光标 1 的情况中：当你按 [{ 时，光标会向上跳到一个未匹配的 { 中，即 "for (i = 0; i < 10; i++) **{**" 中的 { 处。

在光标 2 的情况中：当你按 [{ 时，光标会向上跳到一个未匹配的 { 中，即 "if (condition) **{**" 中的 { 处，而不是 "for (i = 0; i < 10; i++) **{**" 中的 { 处。

作为快捷方式，你也可以使用 [% 和 ]%，其中 % 键基本上就是"当前包围我的任何括号"的占位符。它们会跳转到当前所在的括号、花括号、尖括号或方括号的开头或结尾。

有一点很重要，和其他括号不同，[[ 和 ]] 并不会从方括号中跳出，所以如果你需要跳出方括号，使用 [% 和 ]% 是唯一的选择。

> （ethan）基于以上规则：
>
> - 像：[}、]{ 这样的跳转命令是没有意义，不会跳转的。
> - 当光标不在任何包围对的内部，基于方括号的包围对跳转也是没有意义，不会跳转的。

### [7.1.1 按引用跳转](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_by_reference)

你可能会认为 [[ 和 ]] 是用来跳出方括号的，但实际上这两个容易输入的组合键被保留用于一个更常用的操作：跳转到光标下变量的其他引用处（在同一文件中）。

这个功能通常依赖于当前编程语言的语言服务器，所以比简单的搜索要智能得多。它只会跳转到该函数或变量的实际使用位置，而不会跳转到其他变量、类型或注释中恰好包含这个单词的位置（这是搜索操作可能会发生的情况）。

> （ethan）实际试下来，感觉这个功能更多的是依赖于treesitter？因为他只能在单文件中跳转（不同于基于 lsp 的 References，可以在整个项目中跳转）。

> 当你移动光标时，LazyVim 会自动高亮文件中该变量的其他实例，这样你就能轻松看到 ]] 或 [[ 会将光标移动到哪里。
>

### [7.1.2 按语言特性跳转](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_by_language_features)

[c、]c、[f、]f、[m 和 ]m 这些按键绑定允许你通过跳转到上一个或下一个类/类型定义、函数定义或方法定义来在源代码文件中导航。这些功能的实用性在一定程度上取决于你使用的编程语言以及该语言的语言服务配置方式，但在常用语言中都能很好地工作。

默认情况下，这些按键绑定都会跳转到上一个或下一个类/函数/方法的开头。如果你想跳转到结尾，只需要加上 **Shift** 键：[C、]C、[F、]F、[M 和 ]M 就能带你到达那里。

注意，这些和"跳出"行为是不同的：如果你在当前编辑的函数内部有一个嵌套函数或匿名回调函数，]F 按键绑定会跳转到嵌套函数的结尾，而不是跳转到当前函数之后的那个函数的结尾。

我个人不太经常使用这些按键绑定，因为还有其他方式可以在文档中导航符号，我们稍后会讨论这些方法。但是，如果你正在编辑一个大函数，想要快速跳转到文件中的下一个函数，用 ]f 可能比计算要按多少次 j，或者用 Control-d 然后按 S 进入查找模式要快得多。

### [7.1.3 跳转到缩进结束处](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_to_end_of_indention)

如果你正在处理基于缩进的代码（如 Python）或深度嵌套的基于标签的标记语言（如 HTML 和 JSX），你可能会发现 mini.indentscope 这个额外插件很有用。你可以通过访问 :LazyExtras 并搜索 indentscope 来安装它。

这个插件提供了 [i 和 ]i 这对按键绑定。

LazyVim 配置了一个名为 indent-blankline 的插件，它可以帮助你可视化文件中的缩进层级。这里有一个我最近在处理的 Svelte 组件的例子：

<img src="mymedia\indent-guides-dark.png" alt="indent guides dark" style="zoom:50%;" />

这段 Svelte 代码使用两个空格作为缩进。每个缩进层级都有一条（在我的主题中是）灰色的垂直线，帮助你直观地看到该缩进层级的起始和结束位置，而"当前"的缩进层级会用不同的颜色高亮显示。

如果启用了 mini.indentscope 插件，当你移动光标时，这些线条会有一个漂亮的动画效果。更重要的是，它添加了 [i 和 ]i 这两个 unimpaired 命令，用于跳出当前缩进层级；它会跳转到当前高亮行的顶部或底部。

我在编辑 Python 代码和 Svelte 组件时经常使用这个功能。在其他语言中，我使用这个功能的频率较低，因为 [% 和 ]% 通常能更好地帮我到达下一个目标位置。不过，即使在大量使用括号的语言中，缩进指示线的视觉反馈也非常有帮助；虽然我可能会对跳转到哪个花括号感到惊讶，但缩进指示线总是很明显的。

### [7.1.4. 跳转到诊断信息](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jumping_to_diagnostics)

说实话，我在写代码的时候总是会引入很多错误。根据不同的编程语言，LazyVim 要么是已经预先配置好了，要么可以配置成能给我提供大量的错误反馈，这些反馈通常以波浪下划线的形式显示。

> 如果你没有看到波浪下划线，建议你回到第一章，选择一个更好的终端。 

这些波浪下划线通常是由编译器、类型检查器、代码检查工具，甚至拼写检查器（取决于编程语言）生成的。有些表示错误，有些是警告，还有一些是提示。虽然其中可能有一些干扰项，但大多数都是帮助你改进代码的机会。

由于我在写代码时特别擅长制造问题，所以我经常需要"跳转到下一个波浪线"。这些标记统称为诊断信息（diagnostics），可以使用 [d 和 ]d 在它们之间跳转。如果你只想关注错误，而忽略提示和警告，可以使用 [e 和 ]e。类似地，[w 和 ]w 这两个快捷键用于在警告之间导航。

如果你正在编辑的文件启用了拼写检查（或者你通过 <Space>us 手动启用了它），可以使用 [s 和 ]s 在拼写错误之间跳转。这一点在我刚开始写这本书时让我有点困惑，因为我原以为 ]d 会带我跳转到拼写错误的波浪下划线处，但实际上需要用 ]s。

最后，如果你在代码中使用了 TODO 或 FIXME 注释，可以使用 [t 和 ]t 在它们之间跳转。

需要注意的是，与之前大多数的 ] 和 [ 快捷键不同，诊断跳转不能与动作命令组合使用。比如，d[d 并不能删除从当前位置到最近的诊断信息之间的内容。这（可能）只是 LazyVim 在定义快捷键时的一个疏忽。

### [7.1.5. 跳转到 Git 修改](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jumping_to_git_revisions)

这是我最喜欢的方括号组合快捷键：[h 和 ]h 允许你跳转到下一个 git "hunk"（代码块）。如果你不熟悉这个词（或者你认为这个词指的是帅哥），"git hunk" 指的是文件中那些包含了尚未暂存或提交的修改的区域。

我的很多编辑工作都涉及在一个大文件的三四个地方进行修改。例如，我可能需要在文件顶部添加一个导入语句，在文件的其他地方修改一个函数调用的参数，然后在第三个地方修改接收该参数的函数。一旦开始编辑，我可能需要在这些位置之间来回跳转。]h 和 [h 非常适合这种情况，而且我不需要记住跳转历史或添加命名标记（本质上是书签）。

更棒的是，LazyVim 会用简单的视觉标记显示文件中哪些行被修改过，这样你就能知道它会跳转到哪里。让我们看看这个截图：

<img src="mymedia\git-hunks-dark.png" alt="git hunks dark" style="zoom:50%;" />

在左侧，行号的右边，你可以看到一些标记：绿色的竖条表示我插入了两行代码，橙色的竖条表示我修改了一行，还有一个小红色箭头表示我删除了一行。（另外，在我的修改引入错误的那一行，行号左侧还显示了一个波浪线诊断标记和一个红色的圆圈带叉号的图标）。如果我把光标放在文件顶部，按三次 ]h，就可以在这三个位置之间跳转。

和诊断跳转一样，[h 和 ]h 也不能与动作命令组合使用。

## [7.2. 文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_text_objects)

将动作命令与移动命令组合使用很有用，但更常用的是将这些动作命令与文本对象结合使用。Vim 本身就带有几个常见的文本对象，比如单词、句子和括号内的内容。而 LazyVim 则添加了大量其他文本对象。

> （ethan）文本对象的引入：
>
> 1. 什么是文本对象？ 想象你在编辑一篇文章，文章中有：
>
>    - 单词
>    - 句子
>    - 段落
>    - 引号中的内容
>    - 括号中的内容 
>
>    这些都是"文本对象"，它们是**有明确边界的文本单位**。
>
> 2. 为什么需要文本对象？ 想象这些场景：
>
>    - 你要删除一个单词，但光标在单词中间
>    - 你要修改引号里的内容，但光标不在开头
>    - 你要复制整个段落，但不想手动选择
>
>    没有文本对象时，你需要：
>
>    1. 移动到目标开始位置
>    2. 选中到结束位置
>    3. 执行操作
>
>    有了文本对象后，你可以：
>
>    1. 直接告诉编辑器："删除这个单词"、"修改这个引号里的内容"、"替换这个引号里的内容及这个引号"

文本对象的语法结构是 <动作><上下文><对象>。这里的动作命令就是你之前学过的那些用于移动的命令，比如 d、c、gU 等。

<上下文> 一般只有 a 或 i。你知道，这两个按键在普通模式下都是用来进入插入模式的。但是当你已经输入了一个动作命令（比如 d 或 c）后，你其实已经不在普通模式了！

这时你处于所谓的"**操作符待决模式**"（Operator Pending Mode）。你熟悉的那些导航按键在操作符待决模式下通常也是可用的，这也是为什么你可以在动作命令后执行移动命令的真正原因。但是如果插件维护者忘记定义操作符待决模式的键位映射，就会出现可以导航但无法执行动作命令的情况。

在操作符后切换到插入模式是没有意义的，所以 a 和 i 这两个按键在这里有完全不同的含义。通常，你可以把它们理解为 "around"（周围）和 "inside"（内部）（虽然在我脑子里总是简单地把它们读作 "a" 和 "in"）。它们的区别在于：a 操作会选择 inside 所选择的所有内容，再加上一些周围的上下文，具体包含什么取决于定义的对象。

举个例子，一个常见的对象是括号：(。如果你输入命令 di(，会删除（光标所在的、或者下一个）一对匹配的括号内的所有文本。但如果你输入 da(，则会删除括号内的所有文本以及两端的 ( 和 )。

要查看 LazyVim 中的许多可能的文本对象，输入 da 并暂停。这是我看到的内容：

![operator pending dark](https://lazyvim-ambitious-devs.phillips.codes/images/book/chapter-7/operator-pending-dark.png)

接下来让我们详细介绍其中的大部分内容。

### [7.2.1. 文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_textual_objects)

**操作符** w、s、p 分别用于对整个单词（word）、句子（sentence）、段落（paragraph）执行操作，它们的定义如前所述：单词是连续的非标点符号，句子是以 .、? 或 ! 结尾的内容，段落是由两个换行符分隔的内容。

这些对象在 around 和 inside 上下文之间的区别在于是否会影响**周围的空白字符**。

例如，考虑下面这段文本，假设我的光标当前位于第二个句子中 handful 这个词中间的 | 字符处：

```tex
This snippet contains a bunch of words. There are a hand|ful of
sentences.

And two paragraphs.
```

如果我想在那个位置删除 handful 这个词，我可以输入 bde 来跳到词的开头，然后删除到词的结尾。或者我可以使用 inside word 文本对象，输入 diw。

无论哪种方式，我都会在 a 和 of 之间留下一个多余的空格，因为 diw 是在词的内部操作，不会触及周围的空白。

如果我改用 daw，它会删除这个词和周围的一个空格字符，这样之后 a 和 of 之间就会正确地只有一个空格。

还有一个 W（大写）操作符，它的含义类似于用大写 W 进行单词导航：它会删除两个空白之间的所有内容，而不是将标点符号解释为词边界。

同样，我可以在相同的光标位置使用 dis 和 das 来删除整个"There are a handful of sentences."这个句子。前者不会触及 The 之前或句号之后的任何空白，而后者会正确地处理空白。

最后，我可以用 dip 或 dap 删除整个段落。区别在于，在前一种情况下，被删除段落后的空行仍然存在，而在 around 模式下，它会删除多余的空行。

通常，当我使用 c 动作命令来更改单词、句子或段落时，我会使用 i，因为我想用其他的，需要周围带空白的内容，来替换它。但当我用 d 删除文本对象时，我会使用 a，因为我不打算替换它，所以我希望空白表现得就像那个对象从未存在过一样。

### [7.2.2. 引号和括号](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_quotes_and_brackets)

**操作符** "、'、` 用于操作被双引号、单引号或反引号包围的文本。如果你使用命令 ci"，你将在（光标所在的，或下一个）两个引号之间进入插入模式，其中字符串内的所有内容都被删除。但如果你使用 da"，它还会删除引号本身。

作为快捷方式，你可以使用字母 q 作为文本对象，LazyVim 会自动判断（光标所在的，或下一个最近的）引号是单引号、双引号还是反引号，并删除该对象。我个人不使用这个功能，但我想它可能会在处理双引号时节省一次按键。

同样，如果你想对圆括号、花括号、尖括号或方括号中包含的整个块应用动作命令，你只需输入其中一个括号字符即可。考虑这些例子：di[、da(、ci{ 或 ca<。与引号一样，i 版本会保留周围的括号，而 a 版本会删除整个内容。

选择最近的括号或圆括号类型的快捷方式是 b 对象（助记符是 "bracket"）。

这些实际上可以使用计数，所以你可以删除"第三个外围花括号"而不是"最近的外围花括号"。不过我总是记不住要把计数放在哪里！如果你的记忆力比我好，语法是在 a 或 i 之前放置计数。例如，d2a{ 会删除第二近的花括号及其内的所有内容。为了更好地理解，这里有一个可视化的例子：

```javascript
class Foo {
    function bar() {
       let obj = {fizz: 'buzz'}
    }
}
```

如果我的光标在 fizz 和 'buzz' 之间的冒号上，你可以预期以下效果：

- di{ 会删除 fizz: 'buzz' 但保留周围的花括号。
- c2i{ 会删除整个 let obj = 行，并让我的光标在定义函数体的花括号内进入插入模式。
- c2a{ 会做同样的事情，但也会删除那些花括号，所以我留下的是一个没有函数体的 function bar()。
- d3i{ 会删除整个函数，只留下一个空的 Foo 类。

你也可以删除某些标点符号之间的内容。例如，ci* 和 ca_ 在处理 Markdown 文件中标记为粗体或斜体的文本内容时很有用。

如果你想操作整个缓冲区，使用 ag 或 ig 文本对象。所以 cag 是删除所有内容并重新开始的最快方法，而 yig 会复制缓冲区，这样你就可以把它粘贴到 pastebin 或聊天机器人中。g 可能看起来是一个奇怪的选择，但它与 gg 和 G 跳转到文件开头或结尾的事实有一个对称性。如果你需要一个助记符，可以把 yig 理解为"yank in global"（在全局中复制）。

### [7.2.3. 语言特性](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_language_features)

LazyVim 添加了一些有用的**操作符**，可以对整个函数或类定义、对象以及（在 HTML 和 JSX 中的）标签执行命令。总结如下：

- c：作用于类或类型
- f：作用于函数或方法
- o：作用于"对象"（这个助记符有点牵强），如代码块、循环或条件语句
- t：作用于 HTML 类型的标签（适用于 JSX）
- i：作用于"作用域"，本质上是一个缩进级别（仅当安装了前面提到的 mini.indentscope 额外插件时可用）

### [7.2.4. Git Hunks](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_git_hunks)

还记得我们在 Unimpaired 模式中讨论的 git hunks 吗？你可以用 h 对象对整个 hunk 进行类似的操作。所以快速撤销添加的一种方法就是输入 dih。但你可能不会经常这样做，因为有更好的方法处理 git，我们将在第 15 章中讨论。

### [7.2.5. 下一个和上一个文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_next_and_last_text_object)

如果你已经在你想要操作的对象内部，那么文本对象特性是很棒的，但 LazyVim 配置（使用一个叫做 mini.ai 的插件）使得你甚至可以操作光标位置附近的对象。

安装后，可以通过在要访问的对象前加上 l 或 n 来访问下一个和上一个文本对象。

再次考虑 Foo.bar Javascript 类：

```javascript
class Foo {
    function bar() {
       let obj = {fizz: 'buzz'}
    }
}
```

如果我的光标在 function bar 行的 { 上，我可以输入 cin{ 来删除 fizz: 'buzz' 对象的内容，并将光标放在那里进入插入模式。我可以用一个额外的 n 键来省掉其他的导航过程。我认为这是一个非常巧妙的功能，但我总是忘记它的存在...希望在这里写下它能帮助我记住！

## [7.3. 查找周围对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_seeking_surrounding_objects)

提供了 Seek 模式的 flash.nvim 插件还有另一个绝妙的功能：文本对象的终极解决方案。在指定动作命令后，你可以使用 S 键（不需要 i 或 a）来显示光标周围主要代码对象的成对标签。

举个例子，我们再次使用 Foo 类。我把光标放在冒号上并输入 cS。插件识别出光标周围的各种对象，并在每个对象的两端放置标签：

<img src="mymedia\seek-object-dark.png" alt="seek object dark" style="zoom:50%;" />

这个图像中的标签是绿色的，（通常）按照从"最内层"到"最外层"的字母顺序排列。与 Seek 模式的主要区别是每个标签都是成对的；有两个 a 标签，两个 b 标签，以此类推。文本对象就是这些标签之间的内容。

如果我接下来按 a（或回车，接受默认值），那么我将更改定义 obj 的花括号内的所有内容。如果我按 b，它还会替换这些花括号。按 c 将更改整个赋值语句，而 d 将更改函数的内容。按 e 也会替换花括号，f 更改整个函数定义。g 标签是类的内容，而 h 更改整个类。

当你需要编辑对象文本，而大脑不能立即映射出这个对象的类型时，这个工具就非常有用了。

### [7.3.1. 远程查找周围的对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_seeking_surrounding_objects_remotely)

"S" 的**操作待命模式**对于操作光标周围的对象很有用，但如果你的光标当前不在你想要选择的对象内，它就不够用了。你可以使用 s 导航到对象内部，然后用 S 选择它，但你可以通过使用 R 操作符来节省一些按键。

以"Remote"（远程）作为助记符，R 很容易使用，但很难解释。它是一个操作待命操作，所以你需要先输入一个动作命令，然后是 R（和 S 一样，不需要 i 或 a）。

此时，LazyVim 本质上处于 Seek 模式，所以你可以输入搜索字符串的几个字符来查找屏幕上任何位置的匹配项。然而，flash.nvim 不会在你搜索的字符串的任何匹配处显示单个标签，而是会自动切换到周围对象模式，并显示所有围绕匹配位置的结构的成对标签。

更妙的是，你还可以在不使用周围模式的情况下对任何类型的对象执行远程查找。在这种情况下，你需要输入一个动作命令，然后是小写的 r（它仍然表示"remote"）。这也会让你进入 Seek 模式，你可以开始输入匹配字符。单个标签（普通 Seek 模式，而不是 Surround Seek 模式）会弹出，你可以输入一个字符来临时将光标移动到该标签，就像普通 Seek 模式一样。但当你的光标到达那里时，它会自动进入操作待命模式。所以你现在可以输入任何其他操作符，如 aw 或 i(。一旦操作完成，你的光标会移回到你进入远程 Seek 模式之前的位置。

举个具体例子，命令 drAth2w 会删除从标签 h 处的"At"这个词开始的两个词，然后将光标跳回到删除开始前的位置。换句话说，它相当于命令 sAthd2w<Control-o>，这会查找到标签 h 处的"At"这个词，然后删除两个词，并使用 Control-o 跳回到你之前的历史位置。远程命令稍短一些，但这是另一个我倾向于忘记使用的功能。我的大脑在意识到"删除"模式之前就进入了"移动光标"模式，所以当我意识到本可以远程完成时，已经太晚了。

## [7.4. 修改包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_operating_on_surrounding_pairs)

我们已经看到了用于操作引号或括号对内容的文本对象，但如果你想**保留内容而改变周围的配对字符**呢？

比如你想把双引号字符串 "hello world" 改成单引号的 'hello world'。或者你要把 obj.get(some_variable) 方法查找改成 obj[some_variable] 索引查找，需要把周围的圆括号改成方括号。

LazyVim 为这种操作提供了 mini.surround 插件，但默认并未安装。这是一个推荐的额外插件，如果你按照我的建议启用了所有推荐插件，你可能已经有它了。

### [7.4.1. 添加包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_add_surrounding_pair)

添加包围对**动作**的默认命令是 gsa。这会将编辑器置于操作待命模式，然后你需要输入上下文（a 或 i）和文本对象（w、s、p、"、[、{ 等）来选择要包围的文本。完成对象输入后，你需要输入想要包围它的字符，比如 "、(、)。后两者的区别在于，虽然都会用括号包围文本，但 ( 会在括号内额外添加空格。

> （ethan）如果配置了下文给出的config，则 gsa 就会失效！下文中的配置项，大致可以理解为：
>
> ;; = gsa
>
> ;d = gsd
>
> ;r = gsr
>
> ;f = gsf
>
> ...

这听起来可能很复杂，但看几个例子就明白了：

- gsai[( 会选择方括号内的内容（使用 i[）并在方括号内放置带空格的圆括号。所以如果你从 [foo bar] 开始输入 gsai[(，最终会得到 [( foo bar )]。
- gsai[) 做同样的事情，但不添加空格，所以同样的 [foo bar] 会变成 [(foo bar)]。
- gsaa[) 会将圆括号放在方括号外面，因为你用的是 a[ 而不是 i[。这次我们的例子变成了 ([foo bar])。
- gsa$" 会用双引号包围当前光标位置到行尾的所有文本。
- gsaSb' 会用单引号包围你在 S 操作后用标签 b 选择的文本对象。
- gsaraa3e* 会在以 a 开头的远程对象（标签为 a）后面的三个词的两端添加星号。

> （ethan）助记：
>
> - 可以理解为：<动作><上下文><对象><拓展>。gsa、gsd、gsr 或者符号 ;;、;d、;r 表示 <动作>，i、a 表示 <上下文>，[ 表示 <对象>，( 表示拓展。
> - 或者把 [(、["这种，当作**包围对-对象**，不过需要配合gsa、gsd、gsr这样的特定**动作**。

根据上下文，可能需要输入很多字符，但通常比独立导航到并更改配对的每一端要少按键。

### [7.4.2. 删除包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_delete_surrounding_pair)

删除配对更简单，因为你不需要指定文本对象。只需使用 gsd 后跟你想要删除的配对的指示符。

所以如果你想删除光标周围的 []，可以使用 gsd[。

如果你想删除深度嵌套的元素，你需要在 gsd 命令前加上计数。所以使用 2gsd{ 来删除当前光标位置外的第二组花括号。例如，如果你的光标在字符串 {abc {def}} 中的 def 内，输入 2gsd{ 会得到 abc {def}，保留了围绕 def 的"内部"花括号，但删除了围绕整体的第二组外部花括号。

### [7.4.3. 替换包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_replace_surrounding_pair)

替换类似于删除，只是命令是 gsr，并且在输入现有字符后需要输入你想要替换成的字符。

所以如果你有文本 "hello world" 且光标在其中，你可以使用 gsr"' 将双引号改为单引号：'hello world'。

### [7.4.4. 导航包围字符](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_navigate_surrounding_characters)

对包围对或其整个内容执行操作很方便，但有时你只想将光标移动到配对的开始或结束处。你通常可以使用 Seek 模式、Find 模式或 Unimpaired 模式命令（ 比如 **[(** ）来做这件事，但如果你需要的话，还有其他更语法偏向的命令。

最简单的一个已经内置在 Vim 中很长时间了的命令。如果你的光标当前在括号、方括号或花括号对的开始或结束字符上，只需按 % 就可以跳转到配对的另一端。如果你不在配对的括号上，在 Normal 模式中使用 %，它会跳转到最近的包围配对对象。不过这只适用于括号，所以不支持引号等任意配对。

mini.pairs 插件带有 gsf 和 gsF 键绑定，可用于将光标移动到相关字符。我不使用这些，因为 mini.ai 插件使用 g[ 和 g] 快捷键提供了类似的功能。这些快捷键都需要后面跟一个字符类型，例如 g[( 会跳回到最近的包围开括号，g]] 会跳到最近的闭方括号。如果你给它一个计数，它会跳出那么多层包围对。

### [7.4.5. 高亮包围字符](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_highlighting_surrounding_characters)

如果你只需要检查包围字符在哪里，你可以使用类似 gsh( 的命令，其中 h 表示"highlight"（高亮）。这有时可以用作删除或替换操作的预演，特别是在使用计数时，可以让你确认你要操作的确实是你想要的配对。

### [7.4.6. 额外功能：XML 或 HTML 标签](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_bonus_xml_or_html_tags)

mini.surround 插件主要用于处理字符对，但它也可以操作类似 html 的标签。

假设你有一段文本，想用 p 标签包围它。可以使用组合命令 gsaapt。即： gsa 表示"添加包围"，后跟 ap 表示"围绕 + 段落"。意思是，我们要在段落周围添加一些东西，不是引号不是括号，而是一个 t 标记。

mini.surround 会理解你想添加一个标签，并弹出一个小提示窗口来输入你想添加的标签。输入 p 作为你想创建的标签。你不需要尖括号；只需要标签名：

<img src="mymedia\surround-tag-dark.png" alt="surround tag dark" style="zoom:50%;" />

如果你想添加的标签有属性，你可以在提示中添加它们。mini.surround 足够智能，知道属性只放在开始标签上。

<img src="mymedia\surround-tag-attrs-dark.png" alt="surround tag attrs dark" style="zoom:50%;" />

### [7.4.7. 修改键绑定](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_modifying_the_keybindings)

我非常喜欢 mini.surround 的行为。我经常使用它。用得太多以至于很快就厌倦了重复输入 gs。我决定用 ; 替换 gs，这样我可以输入 ;d 或 ;r 而不是 gsd 或 gsr。对于添加包围，我决定利用双击按键容易输入的特点，所以我用 ;; 代替 gsa 或者 ;a。

为了让这正常工作，我还必须修改 flash.nvim 的配置来移除 ; 命令。（默认情况下，; 键可以用作 f 和 t 键的 "查找下一个" 行为，但由于 flash 的设计方式，你不需要单独的键入 ; 命令，只需再次按 f 或 t 即可）。

如果你想和我做同样的事，只需在 config/plugins 目录下创建一个新的 Lua 文件，名字随意（我的是 extend-mini-surround.lua）。

文件内容如下：

```lua
return {
  {
    "echasnovski/mini.surround",
    opts = {
      mappings = {
        add = ";;",
        delete = ";d",
        find = ";f",
        find_left = ";F",
        highlight = ";h",
        replace = ";r",
        update_n_lines = ";n",
      },
    },
  },

  {
    "folke/flash.nvim",
    opts = {
      modes = {
        char = {
          keys = { "f", "F", "t", "T" },
        },
      },
    },
  },
}
```

由于我们要修改两个插件，我在外层 Lua 表中放了两个 Lua 表，Lazy.nvim 足够智能，能将其解析为多个插件定义。第一个将映射传递给传入 mini.surround 的 opts。这些将替换 LazyVim 为该表定义的默认键绑定（以 gs 开头的那些）。

第二个定义也传递了一个自定义的 opts 表。它用一个只定义 f、F、t 和 T 的新表替换了包含 ; 和 , 的默认键。

> 如果我知道 ; 被 flash.nvim 重新绑定，我就可以通过阅读 LazyVim 网站上的 flash.nvim 配置并查看需要覆盖什么来找到这个解决方案。但是我不知道 ; 在哪里被定义！最后不得不在 LazyVim GitHub Discussions 上寻求帮助。那里的人真的很乐于助人，如果你有任何问题，我鼓励你来打个招呼。

## [7.5. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_summary_7)

本章我们学习了一些由 LazyVim 通过重新实现 Unimpaired 模式提供的高级代码移动技术。然后我们了解了什么是文本对象，并快速学习了 LazyVim 提供的众多文本对象。

主要内容包括：

1. **Unimpaired 模式**
   - 提供了一系列成对的命令来进行代码导航和操作
   - 使用 [ 和 ] 作为前缀的各种命令
2. **文本对象**
   - 理解了文本对象的概念
   - 学习了如何使用 i 和 a 来操作文本对象内部或包含边界
   - 掌握了 LazyVim 提供的各种文本对象类型
3. **S 动作及其变体**
   - S 动作可以即时选择文本对象
   - R（远程）变体用于操作光标之外的对象
   - r 变体提供了不使用周围模式的远程查找
4. **包围对操作**
   - 使用 mini.surround 插件处理配对字符
   - 学习了添加（gsa）、删除（gsd）和替换（gsr）包围对的操作
   - 掌握了处理 HTML/XML 标签的特殊功能
   - 了解了如何自定义键绑定来优化工作流程

下一章我们将学习：

- 剪贴板交互
- 寄存器的使用
- 用于文本选择的全新可视模式

这些功能将进一步提升我们的文本编辑效率。

# [第八章：剪贴板、寄存器和可视化模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_clipboard_registers_and_selection)

Vim 的复制粘贴功能比你在其他编辑器中使用的操作系统剪贴板要更早，也更强大。值得庆幸的是，LazyVim 的配置已经自动设置好了 Neovim 的剪贴板系统，可以直接与操作系统的剪贴板协同工作。

实际上，你已经知道如何将文本剪切到系统剪贴板了：只需要使用删除就可以。

没错，每当你使用 d 或 c 命令时，被删除的文本会自动剪切到剪贴板中。这通常很方便，但有时也会有点烦人。在本章后面，我会向你展示如何避免保存被删除的文本的解决方法。

## [8.1 粘贴文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_pasting_text)

在 Vim 中，使用我在第一章中简单提到过的 p 命令进行粘贴文本（通常称为"putting"）。在普通模式下，单个 p 命令会将系统剪贴板中的内容放置在当前光标位置。这通常是你最近删除的文本，但也可以是从浏览器复制的 URL、从邮件复制的文本或其他任何系统剪贴板对象。

插入文本的位置可能会有点出人意料，但通常都能符合你的预期。一般情况下，如果你删除了几个单词或不是整行的字符串，它会直接插入到当前光标位置之后。但是，如果你使用了像 dd 或 cc 这样操作整行的命令，文本会被放置在下一行。可以节省一些移动导航的按键操作，这在代码编辑中是很常见的任务。

p 命令可以与数字配合使用，所以在那些不太可能发生的场景下，比如你想连续粘贴剪贴板中内容的 5 个副本，你可以使用 5p。

当你使用 p 粘贴时，光标会保持在原位，文本会插入到光标之后。如果你想在当前光标位置之前粘贴文本，可以使用大写的 P，这个转换动作可以理解为"在相反方向执行 p"。与 p 一样，文本会直接插入到光标位置之前，除非是像 dd 这样的整行编辑，这种情况下文本会被放置在上一行。

如果你已经在插入模式下，需要粘贴内容并继续输入，可以使用 Control-r 命令，然后按 + 键。r 可能不太好记，但它代表"register"（寄存器）。我们稍后会详细讨论寄存器的概念。

## [8.2 复制文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_copying_text)

复制文本需要一个新的命令：y。它的行为与 d 和 c 类似，但不会修改缓冲区内容；它只是复制由 y 后面的动作或文本对象定义的文本。

你可能会问："为什么用 y 呢"，因为它代表"yank"，这是 Vim 中"复制"的专业术语。我不知道为什么 vi 要叫它"yank"，但我猜这可能是一个反向缩写（根据缩写反向推出全称）。原作者们可能注意到键盘上的 y 键当时还没有被使用，就决定想出一个与之匹配的词。当时剪贴板或复制/粘贴的概念还没有标准化，所以他们可以自由使用任何合适的术语。

y 命令可以与你已经熟悉的所有动作和文本对象配合使用。它在配合 r 和 R 远程查找命令时特别有用。如果你需要从编辑器的其他位置（甚至是不同的窗口）复制文本到当前光标位置，yR<search><label>p 是最快的方法，而且不会在历史记录中添加不必要的跳转。

yy、Y 命令分别会：复制整行、从光标到行尾的内容，这与删除和修改文本时的对应命令类似。

LazyVim 会短暂高亮显示你复制的文本，这样你就能清楚地知道你的动作命令是否复制了正确的内容。

## [8.3 先选择文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_selecting_text_first)

到目前为止，你的 Vim 编辑体验还没有涉及到选择文本的概念。是不是觉得很奇怪？我们已经讲了 8 章了！在普通的文字处理器和类似 VS Code 的文本编辑器中，你必须先选择文本，然后才能执行删除、复制、剪切或修改等操作。考虑到在那些编辑器中选择文本有多么麻烦（你必须使用鼠标，或者使用 Shift 键加光标移动的组合，还要用额外的修饰键来进行更大范围的移动），真是让人惊讶他们是怎么完成工作的！

在 Vim 的世界里，你通常是先执行动作命令，然后用文本动作或对象来隐式选择要操作的文本。这通常是最有效的方式，但在某些情况下，先高亮显示文本再操作会更方便。

这就是可视模式（Visual mode）的用武之地。可视模式是 Vim 的一个主要模式，就像普通模式和插入模式一样。从技术上讲，可视模式有三个子模式。我们先从"字符可视模式"开始，稍后再详细介绍其他两个。

> 你可能会认为先选择文本更有意义，这样你就能看到要操作的内容。两个较新的编辑器 Kakoune 和 Helix 正在尝试这种模式。它们很酷，但我发现"先选择文本"的模式有点令人失望。编辑器无法判断任何给定的移动是要移动选区还是要扩展选区，所以你最终需要额外的按键来告诉它要做扩展。这样一来，就和在 Neovim 中按 v 进入可视模式没什么区别了。在使用 Helix 几个月后，我发现它实际上需要比 Neovim 按下更多的按键操作，所以我又换回了 Neovim。

要进入字符可视模式，在普通模式中使用 v 命令即可（你也可以像其他普通编辑器那样，通过鼠标点击并滑动来进入可视模式）。然后使用你在普通模式下习惯的大多数移动命令来移动光标。之所以说"大多数"，是因为可视模式的键位映射独立于普通模式（和插入模式），有时插件可能会忽略为两种模式都设置键位映射。不过，LazyVim 在键位映射方面做得很好，所以你很少会遇到意外情况。

一旦在可视模式下选择了文本，你可以使用平常用于删除、修改或复制的命令。不同之处在于，这些命令会立即作用于选区，而不需要额外的移动命令。你甚至可以使用像 x（与 d 作用相同）这样的单字符命令，或 r 这样的单字符命令来用相同的字符替换所有选中的字符。完成命令后，编辑器会自动切换回普通模式。你也可以使用 Escape 键或再次按 v 来退出可视模式而不执行任何操作。

你可以暂时退出可视模式而不完全失去选区。在普通模式下，使用 gv（"go to last visual selection"）命令可以返回到之前的选区。如果你正在执行一个可视操作，但突然意识到需要查找什么东西、进行编辑，或从文件其他地方复制内容，然后再回到选区时，这个功能就很有用。

在进入 v（字符可视模式）后，使用 o 命令（代表"other end"）可以将光标移动到选区的另一端。这在这种场景中很有用：选择了一段文本后，但突然发现选区的另一端还有一些内容也需要被选择。由于不能从可视模式直接进入插入模式，所以 o 命令被重新用于这个目的。

### [8.3.1 行可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_line_wise_visual_mode)

v 命令对于精细的选择很有用，但如果你知道你的选择将在行边界开始和结束，你可以使用（大写的）V 来进入行可视模式。现在无论你将光标移动到哪里，光标所在的整行都会被选中。

除了选择整行外，行可视模式的主要区别在于，当你使用操作剪贴板的命令时（包括 d、c 和 y），这些行会以行模式被剪切或复制。当你之后粘贴它们时，它们会出现在下一行或上一行，而不是直接出现在光标之后。

### [8.3.2 块可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_block_wise_visual_mode)

块可视模式是 Vim 独有的一个很棒的功能。它允许你以可视方式进行选择和操作：在垂直方向上连续、但在水平方向上不连续的文本块。例如，我在下面的截图中选择了四行中每行的几个字符：

<img src="mymedia\visual-block-dark.png" alt="visual block dark" style="zoom:50%;" />

要进入块可视模式，可以使用 Control-v 命令。

在普通文本中，块可视模式可能看起来不是很有用，但当你需要在 csv 文件或 markdown 表格中剪切和粘贴表格数据列时，它就很方便了。我不经常使用这个功能，但当我需要它时，我觉得没有其他方法能如此高效地完成我需要的操作。

> 如果你使用 Control-v + $，你会得到块可视模式的一个小变体，其中选区会延伸到块中每一行的末尾。当你需要选区延伸到行尾时，这个功能很有用。

块可视模式也可以用作多光标的（不太完美的）替代方案。如果你在选择可视块后使用 I 或 A 命令，然后输入一些文本并按 Escape，你输入的文本会被复制到可视块（整列）的开头或结尾。这个功能的一个常见用途是在 Markdown 中有序列表的开头添加 * 字符，或者为需要的块注释添加边框。

## [8.4. 寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_registers)

寄存器是一种存储文本字符串以供后续使用的方式（可以参考汇编语言中寄存器的定义）。从这个角度来说，它们和剪贴板没有什么不同。实际上，Vim 中的系统剪贴板就是一个被 LazyVim 设置为默认寄存器的寄存器。

但是 Vim 有几十个其他的寄存器。这意味着你可以拥有多个自定义剪贴板，每个都包含完全不同的文本序列。这个功能非常有用，比如当你在重构代码时，需要在多个调用点粘贴几个不同代码片段的副本。

寄存器有几种不同的类型，但我们先介绍**具名寄存器**的概念。有超过二十多个具名寄存器，对应字母表中的每个字母。

要在普通模式下访问寄存器，使用 " 字符（即 Shift-<Apostrophe>）即可呼出寄存器页面，后面再跟你想访问的寄存器名称。然后输入你想对该寄存器执行的命令和动作。

所以如果我想删除三个单词并将它们存储在 a 寄存器中而不是系统剪贴板中，我会使用命令 "ad3w。"a 用于选择寄存器，d3w 是删除三个单词的普通命令。如果之后我想在其他地方粘贴同样的文本，我会使用 "ap 而不是只用 p，这样文本就会从 a 寄存器而不是默认寄存器中粘贴。

"ad<motion> 总是会用你选择的文本动作或对象替换 a 寄存器的内容。不过，你也可以使用大写的寄存器名称，通过多个删除命令来构建寄存器内容。所以 "Ad<motion> 会将你删除的文本追加到已有的 a 寄存器中。

当我需要将代码从一个函数复制到另一个函数，但源函数中有一段条件语句在目标函数中不需要时，我发现这个功能很有用。我可以使用 "ay 复制条件语句之前的文本，再使用 "Ay 追加条件语句之后的文本，然后用 "ap 一次性粘贴所有内容。

我还可以配合之前讲到的 S 命令： "byS<label> 将文本复制到 b 寄存器中。现在我可以随时使用 "ap 和 "bp 从 a 或 b 寄存器中粘贴。

如果你忘记了把文本放在哪个寄存器中，只需按 " 并等待，就会弹出一个显示所有寄存器内容的菜单。如果这个菜单不好导航，你也可以使用 <Space>s" 命令打开一个选择器对话框，允许你搜索所有寄存器。只需输入你要粘贴的寄存器中包含的几个字符，使用常用的选择器命令导航此列表，然后按 Enter 将文本粘贴到最后的光标位置。

**要在插入模式或命令模式下显示相同的菜单，使用 Ctrl-r 而不是 "。**

如果你在 <Space>s" 选择器对话框中，你会注意到除了具名的字母寄存器外还有许多其他寄存器。接下来我会逐一讨论这些寄存器。

### [8.4.1 剪贴板寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_clipboard_registers)

在 LazyVim 中，默认情况下，名为 * 和 + 的寄存器始终与默认寄存器（未命名寄存器，或者说叫 " 寄存器）相同，它们代表系统剪贴板的内容。

要理解这一点，我们需要了解一些历史：vi 有寄存器，然后操作系统开始关注剪贴板的概念，vi 用户也希望能够将内容复制到系统剪贴板。在默认（非 LazyVim）的 Vim 配置中，如果你想将文本复制到系统剪贴板，你必须在 y 之前输入 "+。在现代工作流程中，你经常需要将内容复制到浏览器、AI 聊天客户端和电子邮件中，这三个额外的按键（Shift、' 和 +）可能会变得很烦人。

除此之外，一些操作系统（通常是基于 Unix 的系统）实际上有两个操作系统剪贴板：一个用于你选择的文本的隐式剪贴板，另一个用于你通过 Control-c 显式复制的文本（在大多数程序中）。操作系统允许你通过（通常是）中键点击在其他地方粘贴它。他们和 LazyVim 中 *、+、" 寄存器的关系是：

```tex
操作系统中，鼠标选中的文本 -> * 寄存器

操作系统中，Ctrl+C 复制的文本 -> + 寄存器                  -> " 寄存器

LazyVim 中，不指定特定的寄存器时的 y、d、c等操作
```

我建议保持 LazyVim 的同步剪贴板配置，但如果你已经养成了使用传统 Vim 方式的肌肉记忆，或者你厌倦了删除的文本随意覆盖系统剪贴板，你可以禁用这个集成，让这三个寄存器按照上述方式独立运行，而不是链接在一起。要实现这一点，使用 space f c 打开 options.lua 配置文件并添加以下行：

```lua
vim.opt.clipboard = ""

# 默认配置为：
# vim.opt.clipboard = "unnamedplus,unnamed"
# 其中：
# unnamed 使 * 寄存器与默认寄存器同步
# unnamedplus 使 + 寄存器与默认寄存器同步
```

如果你不想让删除（d）或更改（c）操作覆盖剪贴板内容，可以使用"黑洞"寄存器 "_ （这是一个下划线）。所以输入 "_d<motion> 可以删除文本而不将其存储在任何寄存器中，包括系统剪贴板。

如果你想将一个寄存器的内容复制到另一个寄存器，你可以使用 ex 命令 :let @a = @b，其中 a 和 b 是你想**复制到**和**复制自**的寄存器名称。这个操作最常见的用途是将系统剪贴板的内容（可能来自其他程序）复制到另一个具名寄存器中，这样在下次执行复制操作时就不会丢失内容。例如，:let @b = @+ 会将系统剪贴板的内容复制到 b 寄存器中。

### [8.4.2 最近复制或最近插入的文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_last_yanked_or_last_inserted_text)

当你执行 y 命令而不指定目标寄存器时，文本总是会同时存储在 "0 寄存器和默认寄存器中。而且无论你执行多少次删除或更改操作来改变默认寄存器，它都会保留在 "0 中，直到下一次复制操作。

所以如果你复制了文本 abc 然后删除了文本 def，p 命令会粘贴文本 def，但你仍然可以使用 "0p 粘贴 abc。

你还可以使用 ". （句点）寄存器来粘贴最近插入的文本的副本。所以如果你在文档某处输入命令 ifoo<Escape>，然后移动到文档的其他位置并输入 ".p，它会在新的光标位置插入单词 "foo"。如果你插入了想要重复使用的文本，你可能偶尔会想要将 ". 寄存器复制到一个具名寄存器中。则可以使用前面讨论过的 :let @c = @. 命令来实现这一点。

### [8.4.3 删除寄存器（或者说编号寄存器）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_delete_numbered_registers)

编号寄存器本应该非常有用，但我觉得它们相当令人困惑。寄存器 "1 到 "9 总是按升序包含你最近更改或删除的文本。所以在删除操作后，"1 中的内容会移到 "2，"2 移到 "3，以此类推，而 "9 中的内容会被丢弃。

我永远记不住最近删除的顺序，所以通常需要使用 " 菜单来查看编号寄存器的内容。以这种方式存储最近删除的文本很方便，我可以这样找到它。不过，我一般使用 yanky.nvim 插件（本章后面会讨论），所以编号寄存器对我来说用处不大。

还有一个"小删除寄存器"，可以使用 "- 访问。每当你删除任何文本时，它都会存储在编号寄存器中，但如果该文本少于一行，它也会存储在这个减号寄存器中。我很少使用这个功能，因为我的大多数更改都小于一行。

### [8.4.4 当前文件名](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_current_files_name)

当前正在编辑的文件名存储在 "% 寄存器中。它总是相对于编辑器的当前工作目录（通常是启动 Neovim 时所在的文件夹）。我唯一会访问这个寄存器的情况是，使用 :let @+ = @% 将文件名复制到系统剪贴板，以便能粘贴到 GUI 应用或终端中。

## [8.5 录制到寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_recording_to_registers)

还记得我在第 6 章中提到的录制命令吗？qq 开始录制，Q 回放录制内容？其实那时我说得有点过于简化了。

实际上，录制的命令是存储在具名寄存器中的。在那一章里，我随意选择了 q 寄存器，所以用 qq 来开始录制。但你同样可以使用 qa 将其存储在 a 寄存器中，或使用 qf 存储在 f 寄存器中。

qQ 命令用于"追加录制"操作，这类似于使用大写字母 "A<command> 来追加到寄存器。在这种情况下，Q 仍然是一个任意的名称。你可以使用 qA 或 qZ 等命令将录制内容追加到 q 以外的具名寄存器中。

当你在代码库中的不同位置需要进行多种不同的重复性修改时，拥有多组录制内容会非常方便。

无论使用哪个寄存器，Q 命令总是回放最近录制的命令。如果你想回放其他指定寄存器中的内容，需要使用 @ 命令，后跟寄存器名称。因此，如果你使用 qa 录制，就用 @a 回放。作为快捷方式，@@ 将始终重播你最近播放的寄存器内容（这与 Q 不同，Q 始终回放最近的录制）。

### [8.5.1 编辑录制内容](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_editing_recordings)

需要明确的是，录制的内容被放在普通寄存器中。所以如果你使用 qa 录制一系列按键到寄存器中，然后使用 "ap 粘贴该寄存器，你实际上会看到你录制的 Vim 命令列表。

如果你在录制时出错需要修改按键序列，这会很有用。录制完成后，使用例如 "a]p（指定使用 a 寄存器，在下一行粘贴并自动缩进）将其粘贴到新行。此时它就是一行普通文本，只不过恰好包含 vim 命令。你可以修改它来添加其他 Vim 命令，因为它们都只是普通的按键序列。

举个例子，假设我录制了一个命令 qadw2wdeq，它将录制到 a 寄存器（qa），内容为：删除一个词（dw），向前跳过两个词（2w），然后删除下一个词（de），最后用 q 结束录制。但录制完成后，我意识到我应该跳过 3 个词，而不是两个词。

我可以使用 "ap 来粘贴录制的内容，它会显示为：dw2wde。然后使用 f2 跳到数字 2，接着用 r3 将其替换为 3。现在我可以使用 "ayiw 将寄存器的内容替换为 dw3wde。

如果我想回放这个修改后的命令，只需像往常一样使用 @a 即可。

## [8.6 Yanky.nvim 插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_yanky_nvim_plugin)

Yanky.nvim 提供了一些优质功能，比如优化复制时的文本高亮显示，在粘贴后保持光标位置以便继续输入，但其主要特性是更好地管理你的剪贴板历史。LazyVim 还为它配置了几个新的键位绑定，使文本粘贴更加便捷。

该插件默认并未启用，但它是推荐的额外插件之一。如果你在第 5 章按照我的建议安装了所有推荐的额外插件，你可能已经启用了它。如果没有，请前往 :LazyExtras，找到 yanky.nvim 并按 x。然后重启 Neovim。

现在 Yanky 已启用，访问剪贴板历史最简单的方式是使用 <Space>p。它会弹出一个选择菜单，显示所有最近的剪贴板条目。最多可以存储一百个条目，这比编号寄存器提供的要多得多，而且它会存储你的复制内容，而不仅仅是删除和更改操作。如果你需要粘贴一些不再在剪贴板中的内容，<Space>p 可能是找到它的最快方式。

另一个非常有用的键位绑定是 [y。如果你在粘贴操作后立即使用这个命令，刚粘贴的文本将被替换为最近一次复制之前剪切或复制的文本。如果你再次按下它，它会在历史记录中再往前一步，最多可以回溯 100 步。所以如果你不确定某个删除操作在哪个编号寄存器中，或者想访问不再在 "0 寄存器中的复制文本，你可以使用 p[y[y[y... 直到找到你真正想要粘贴的文本。如果你回溯太多，可以使用 ]y 向前反向循环。

LazyVim 还创建了一些有用的键位绑定来改进文本粘贴，特别是在处理缩进方面。最有用的两个是 [p 和 ]p。

这些命令会将剪贴板中的文本粘贴到当前行的上方或下方，具体取决于你使用 [ 还是 ]。你可能认为这与前面描述的自动行级粘贴相同，但由于两个原因，它略有不同：

1. 无论使用什么命令剪切或复制剪贴板中的文本，它都会在新行上粘贴（而自动行级粘贴，需要被复制的文本是一整行）。
2. 它会自动调整新行上文本的缩进以匹配当前行的缩进。

因此，如果你要将代码移动到嵌套块中并需要更改缩进，就可以使用 ]p 而不是依赖行级粘贴。这样你就不需要在之后进行格式化了。（虽然在 LazyVim 中格式化并不难，它会在保存时自动进行）。

你还可以使用 >p、<p、>P 和 <P 在粘贴代码时自动添加或删除缩进（> 表示增加一级缩进，< 表示减少一级缩进）。

## [8.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_summary_8)

本章全部内容都围绕着选择和复制文本。我们学习了用于复制文本的 yank 动作，然后深入研究了可用于选择文本的各种可视模式。

接着我们了解到 Vim 有多个"剪贴板"，称为寄存器，以及如何对这些寄存器进行剪切、复制和粘贴操作。我们甚至更详细地讨论了如何使用寄存器来录制多个独立的命令序列，最后介绍了 yanky.nvim 插件，它可以让你的粘贴操作更加便捷。

在下一章中，我们将学习处理多个打开文件的各种方法，以及如何通过折叠来显示和隐藏代码。

# [第9章：缓冲区和布局](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_buffers_and_layouts)

无论你使用什么编程语言，同时处理多个文件都是不可避免的。而且经常需要在同一个文件的不同区域之间切换。

和其他代码编辑器（除了记事本）一样，Neovim 提供了一套强大的多文件处理系统。LazyVim 配置了功能强大的缓冲区、文件和窗口管理系统，虽然初看起来可能很熟悉，但实际上比普通编辑器要强大得多。

## [9.1 一些术语](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_some_terminology)

在不同的窗口管理系统中，相同的词语可能代表不同的含义。如果你阅读过 tmux、emacs、kitty、vim 和 i3 的文档，就会发现像"window"（窗口）、"pane"（面板）、"tab"（标签页）和"layout"（布局）这样的词有着多种不同的定义。

为了让你在阅读本书和大多数 Vim 及其插件的帮助文件、教程和文档时不会感到困惑，我会坚持使用 Vim 中的术语定义。不过这可能会导致你在使用其他软件时感到困惑！

下面的列表按照从最宽泛到最具体的顺序排列，但要注意这些元素之间的关系更像是一个图而不是树状结构，并不是严格的层级关系。

- **Server（服务器）**

  Neovim 可以以服务器模式运行，并且可以连接多个客户端。这意味着你可以在同一个 Neovim 实例中打开多个视图，这些视图可以来自不同的终端、GUI 软件、网页浏览器，甚至是 VS Code 扩展。通常你不需要考虑 Neovim 服务器的问题，本书后面也不会再提到它。不过现在你知道了，如果你想做一些特别的操作，比如连接到已存在的 Neovim 实例来打开提交信息，而不是在新窗口中打开 Neovim，这是完全可能的。

- **Client（客户端）**

  指你实际运行的 Neovim 应用程序。通常连接到它自己独立的服务器，但也可以配置为连接到已存在的或远程的服务器。当你输入 nvim 命令时启动的就是一个客户端，其他客户端还包括像 Neovide 或 VimR 这样的 GUI 程序。

- **Tab（标签页）**

  一个客户端可以有多个标签页。每个标签页都是一个相对独立的全屏布局。你可以在每个标签页中显示不同的缓冲区，也可以设置不同的窗口分割配置。任何时候只能看到一个标签页。这与 VS Code 和许多其他环境的设计理念很不同，在那些编辑器中，每个分割区域都有自己的一组标签。在 lazyVim 的默认配置中，可以使用 <Space><Tab><Tab> 来新建一个 Tab：

  <img src="mymedia\space-tab-tab.png" alt="space-tab-tab" style="zoom:50%;" />

- **Window（窗口）**

  也被称为"pane"（面板）或"split"（分割），窗口是屏幕上用于查看缓冲区的一个区域。每个标签页都有一个或多个窗口。通常所有窗口都是完全可见的，窗口之间不会重叠。例外情况是浮动窗口，比如当你打开选择器或 Lazy Extras 时弹出的窗口。如果缓冲区的内容无法在窗口中完全显示，窗口可以滚动。

- **Buffer（缓冲区）**

  这是 Vim 中表示当前打开并可以查看/编辑的文件的术语。一个缓冲区可以在多个窗口中显示，这意味着你可以同时查看同一个文件的不同部分，或者在多个标签页中查看同一个缓冲区。如果一个缓冲区在两个地方显示，它们的内容是完全相同的（除了滚动位置）。无论一个文件在多少个窗口或标签页中显示，**底层只会有一个对应的缓冲区**。

- **Fold（折叠）**

  在查看缓冲区时，你可以将文件的某个部分（例如函数、类或缩进层级）"折叠"成一行，从而隐藏其内容。这样你就可以同时查看同一个文件中的两个不相连的部分，而将它们之间无关的信息隐藏起来。

- **File（文件）**

  指存储在磁盘上的文件。每个缓冲区最多链接到一个文件，但也可以有不链接到任何文件的缓冲区（有时称为"scratch"缓冲区，这个术语借鉴自 Emacs）。如果缓冲区没有保存，其内容可能与磁盘上的文件内容不同。

到目前为止，在本书中你的所有操作都是在单个标签页的单个窗口中进行的，可能同时打开了多个缓冲区。现在，事情将变得更加有趣。

## [9.2. Buffers](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_buffers)

如果你使用过 Telescope、Neo-tree 或 mini.files 打开多个文件，你可能会认为缓冲区就是标签页。在下面的视图中，我打开了三个缓冲区，但当前只有一个是可见的：

<img src="mymedia\buffer-line-dark.png" alt="buffer line dark" style="zoom:50%;" />

是的，我知道它们看起来就像是其他软件中的标签页，这是因为 LazyVim 将 buffer line 配置成了 tabs 的样式。有了这个缓冲区线，你可能不会经常需要使用（真正的）Vim 标签页，因为在 Vim 中，标签页是一个完全不同的概念。

无论你打开了多少个窗口，都只有一个缓冲区线。在下面的截图中，我打开了三个缓冲区，其中两个在并排的**窗口**中可见。但编辑器顶部仍然只有一个缓冲区线。

<img src="mymedia\buffer-line-split-dark.png" alt="buffer line split dark" style="zoom:50%;" />

这意味着缓冲区是一个"全局"概念。整个 Neovim 客户端只有一个缓冲区集合，你可以从任何窗口（或标签页）访问这些缓冲区。

当然，你可以用鼠标在缓冲区线上单击来选择不同的缓冲区。但是既然 LazyVim 提供了这么多使用键盘访问缓冲区的方式，为什么要使用鼠标呢？

### [9.2.1 在打开的缓冲区之间导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_navigating_between_open_buffers)

切换缓冲区最简单的方法是使用 H 和 L（即 Shift-h 和 Shift-l）键。到这个时候，你应该已经非常熟悉 h 表示向左移动光标，l 表示向右移动光标了吧。如果你同时按下 shift 键，就会将当前活动窗口中显示的缓冲区切换为左侧或右侧的缓冲区。

此外，你也可以使用 [b 和 ]b 命令，它们的功能是一样的。

令人烦恼的是，这些键位绑定默认不接受计数。所以你不能用 2L 向右跳转两个标签页。这让我很困扰，因为我知道底层的 :bnext 和 :bprev 命令是支持计数的。

原来 LazyVim 将这些键位，映射到了底层插件 bufferline.nvim 提供的 BufferLineCycleNext 命令，而据我所知，这个插件不支持计数。

经过研究，我发现 BufferLineCycle* 命令的存在，是因为该插件可以对 buffer list 配置某种排序机制。但 LazyVim 并没有配置使用这个机制。所以我们可以改用传统的命令。要实现这一点，在你的插件配置文件夹中创建一个新文件，命名为（类似）extend-bufferline.lua：

```lua
return {
  "akinsho/bufferline.nvim",
  keys = {
    {
      "L",
      function()
        vim.cmd("bnext " .. vim.v.count1)
      end,
      desc = "Next buffer",
    },
    {
      "H",
      function()
        vim.cmd("bprev " .. vim.v.count1)
      end,
      desc = "Previous buffer",
    },
    {
      "]b",
      function()
        vim.cmd("bnext " .. vim.v.count1)
      end,
      desc = "Next buffer",
    },
    {
      "[b",
      function()
        vim.cmd("bprev " .. vim.v.count1)
      end,
      desc = "Previous buffer",
    },
  },
}
```

当使用计数调用键位绑定时，vim.v.count1 变量会被设置，所以可以在回调函数中访问它，并通过字符串连接（.. 运算符）传递给 Vim 命令。重启 Neovim 后，你就可以使用像 3L 这样的命令在缓冲区线上向右跳转三个缓冲区。

在缓冲区之间跳转时，另一个你会想要使用的键位绑定是 <Space><Backtick>（空格 + 反引号`）。这个命令可以在当前文件和当前窗口最近打开的文件之间切换。在 Vim 术语中，这被称为"交替文件"。

如果你打开了大量缓冲区，缓冲区线可能会变得非常拥挤。到某个时候，它会在缓冲区栏的侧边显示两个箭头，表示有"隐藏"的缓冲区。当你在缓冲区间导航时，它总是会确保活动的缓冲区是可见的。这是一个非常满的缓冲区线，左侧隐藏了四个缓冲区，右侧隐藏了两个：

<img src="mymedia\buffer-line-full-dark.png" alt="buffer line full dark" style="zoom:50%;" />

如果你打开了很多缓冲区，使用 Telescope 或 Fzf.lua（取决于你启用了哪个）来搜索打开的缓冲区可能会更容易。弹出可过滤、可滚动的缓冲区列表的键位绑定是 <Space><comma>（空格 + 逗号）。它的内容与缓冲区线完全相同，但交互方式不同。

对于有大量文件的大型项目来说，这很有用，因为使用 <Space><Space> 搜索文件可能会很困难。将你实际需要访问的相对较少的文件作为活动缓冲区打开，这样就可以在 <Space><comma> 缓冲区列表中轻松过滤。

另外，你也可以使用 Neo-tree 来导航打开的缓冲区。如果你启用 Neo-tree 侧边栏，你会看到它有一些"手风琴"式的部件（新版的 LazyVim 的 Neo-tree 可能有不一样的界面），名为 Neo-Tree、Neo-Tree Git 和 Neo-Tree Buffers。Neo-tree 有多种用于树形界面导航的源，不过 LazyVim 只预配置了这三个。

要在这些手风琴（Neo-tree 称之为"源"）之间切换，你可以用鼠标点击不同的标题，或使用 < 和 > 键（光标需要在 Neo-tree 范围内）循环切换。另外，你也可以使用 <Space>be 键序列直接显示"Buffer Explorer"。

一旦 Neo-Tree Buffers 视图可见，它看起来会像这样：

<img src="mymedia\neotree-buffers-dark.png" alt="neotree buffers dark" style="zoom:50%;" />

> 如果你打开的缓冲区不在当前的工作目录下，那它们就不会在 Neo-tree 中显示。你需要使用选择器（空格 + 逗号）来访问这些缓冲区。
>

> 如果你习惯一直打开 Neo-tree 侧边栏，你可能想禁用屏幕顶部的缓冲区线。因为它们显示的是相同的信息，没有理由在屏幕空间（这最宝贵的资源）上同时显示两者。不过要注意，这样做，同时也会禁用某些用于管理缓冲区的键位绑定。
>

### [9.2.2 关闭缓冲区](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_closing_buffers)

关闭当前缓冲区，而不关闭它当前打开的分割窗口是一个常用的操作。这个操作的键位绑定是 <Space>bd，其中 <Space>b 会弹出一个包含缓冲区相关功能的菜单，d 表示"delete"（删除）。当你这样做时，你并不是真的在删除底层文件；你只是从 Vim 的内存中删除这个缓冲区：即关闭它。

如果你当前聚焦在 Neo-tree 的缓冲区视图上，你也可以直接按 <Space>bd 关闭他。

我觉得关闭缓冲区是一个太常见的任务，不应该需要按三个键，所以我在之前定义的 extend-bufferline.lua 的 keys 数组中添加了以下内容（使用 <leader><delete> 关闭当前缓冲页）：

```lua
    {
      "<leader><delete>",
      LazyVim.ui.bufremove,
      desc = "Close current buffer"
    },
```

以下是一些其他可用于关闭缓冲区的命令：

| 键位绑定      | 描述                           | 助记符                     |
| ------------- | ------------------------------ | -------------------------- |
| <Space>bD     | 关闭缓冲区及其所在的窗口分割   | Delete 缓冲区，但更"大"    |
| <Space>bl     | 关闭标签行中右侧的所有缓冲区   | 方向导航 l                 |
| <Space>bh     | 关闭标签行中左侧的所有缓冲区   | 方向导航 h                 |
| <Space>bo     | 关闭除活动缓冲区外的所有缓冲区 | "only"（仅保留）这个缓冲区 |
| **<Space>bP** | **删除所有未固定的缓冲区**     | **"P" 是 "p" 的反义**      |

最后一个命令需要一些说明。你可以使用 <Space>bp 在任何活动缓冲区上切换"固定"状态。你会看到缓冲区名称左侧出现一个图钉图标。这个固定功能的唯一目的是在你想要使用 <Space>bP 关闭所有"不太重要的"（未固定的）文件时保持它打开。我个人不使用缓冲区固定功能，所以对我来说，<Space>bP 是"关闭所有缓冲区"的快捷方式；当我完成一个任务准备开始另一个任务时，这很有用。

你也可以通过 Telescope 或 FZF 缓冲区选择器界面（通过 <Space> + 逗号（,）打开选择器界面）关闭缓冲区。如果你使用 FZF，只需按 Control-x 就可以关闭光标所在的缓冲区。**如果你使用 Telescope，Alt-d 键位绑定应该有相同的功能。**

现在你已经了解了所有关于缓冲区的知识，让我们来讨论窗口。

## [9.3. Windows](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_windows_2)

在大多数现代环境中，"窗口"指的是操作系统级别的窗口，比如运行 Neovim 的终端。由于 Vi 早于这些环境出现，他们可以使用"窗口"这个词来指代在其他环境中现在更常被称为"面板"或"分割"的概念（例如 tmux）。

窗口管理命令都集中在 <Space>w **子模式菜单**中：

<img src="mymedia\window-menu-dark.png" alt="window menu dark" style="zoom:50%;" />

我们将在接下来的章节中介绍其中的许多命令。

> 这个菜单也可以用 Control-w 访问。从历史上看，这是 Vim 和 Neovim 默认启用的键位绑定，尽管 LazyVim 为其添加了一些额外的键位绑定。不过，<Space>w 更容易输入。
>

### [9.3.1 创建窗口分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_creating_window_splits)

在 LazyVim 中可以随时创建窗口。要将当前窗口"垂直"分成两半，使用 <Space>wv 键位映射。

当你创建一个分割时，新的窗口会打开另一个视图，并继承活动中的缓冲区内容，并排显示。一旦分割打开，你可以使用任何缓冲区管理命令或我们之前讨论过的打开文件的工具来切换该窗口中的缓冲区。

要在两个窗口之间创建水平分割（一个在上，一个在下），使用 <Space>ws。这个助记符不幸只是"split"（分割）。他们无法重用 <Space>wh，因为它已经用于切换窗口。

> vertical split：垂直分割
>
> horizontal split：水平分割

LazyVim 还允许你使用 <Space>| （其中 | 是 Shift-Backslash 时的垂直线）创建垂直分割，使用 <Space><->（其中 - 是减号） 创建水平分割。我觉得 <Space>ws 和 <Space>wv 更容易输入。

### [9.3.2 在打开文件时创建分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_creating_splits_when_opening_files)

你已经知道可以通过将光标移动到文件上并按 <Enter> 在当前窗口中从 Neo-Tree 打开文件。你还可以在 Neo-Tree 中使用 s 键在垂直分割中打开它（与在普通缓冲区中使用 <Space>ws 键创建水平分割相比，这种不对称的键位映射令人恼火）。Neo-Tree 中的 S 用于创建水平分割。

如果你使用 Telescope 或 Fzf.lua 打开文件，你将使用另一组键位绑定！要在垂直分割中打开文件，使用 Control-v 键位绑定。这在 Telescope 提示区域的插入模式和普通模式下都有效，但在 Fzf.lua 中只在插入模式下有效。要在水平分割中打开，使用 Control-x（我知道，这很奇怪，对吧？）

最后，如果你使用 mini.files，你可以使用与普通窗口相同的键位绑定（<Space>wv 和 <Space>ws）在分割中打开文件。

### [9.3.3 在窗口之间导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_navigating_between_windows)

你可以通过按住 control 键并配合 h、j、k、l在窗口分割之间移动光标。如果你想跳过多个窗口到达下一个窗口，它们也可以加上数字前缀。

另外，你也可以将这些键与 <Space>w 一起使用。所以 <Space>wh 为：移动到左侧的窗口。

- [智能分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_smart_splits)

  我强烈建议使用 mrjones2014/smart-splits.nvim 插件，它可以配置为使用相同的键位绑定在 Vim 窗口和 Kitty、Wezterm 或 Tmux 面板之间导航。看看这个截图：

  <img src="mymedia\vim-kitty-splits-dark.png" alt="vim kitty splits dark" style="zoom:50%;" />我打开了三个 Kitty 终端面板。左边的运行着 Neovim，有两个上下的窗口。右边分成了两个普通的终端面板。默认情况下，如果我想在三个 Kitty 面板之间导航，我必须使用一组键位绑定，如果我想在两个 Neovim 窗口之间导航，我必须使用另一组键位绑定。使用 smart-splits.nvim 插件，我可以使用相同的键位绑定在所有窗口之间导航，不管我的光标在哪里。

  设置 smart splits 的终端集成超出了本书的范围（GitHub 该仓库中的 README 文档应该足够了），但要在 Neovim 中配置 smart-splits 插件，可以在插件目录中创建一个文件，比如 smart-splits.lua：

  ```lua
  return {
    "mrjones2014/smart-splits.nvim",
    build = "./kitty/install-kittens.bash",
    keys = {
      {
        "<A-h>",
        function()
          require("smart-splits").move_cursor_left()
        end,
        desc = "Move to left window",
      },
      {
        "<A-l>",
        function()
          require("smart-splits").move_cursor_right()
        end,
        desc = "Move to right window",
      },
      {
        "<A-j>",
        function()
          require("smart-splits").move_cursor_down()
        end,
        desc = "Move to below window",
      },
      {
        "<A-k>",
        function()
          require("smart-splits").move_cursor_up()
        end,
        desc = "Move to above window",
      },
    },
  }
  ```

  如果你使用 WezTerm 或 Tmux，你不需要 build = 这一行，但对于这三种环境，你还需要按照插件  README 中的说明在你的 Kitty、WezTerm 或 Tmux 配置中添加一些配置。

  > （ethan）可参考我的 dotfile 里，[.tmux.conf.local](https://github.com/ifoxser/dotfiles/blob/wsl-ubuntu-24.04/.tmux.conf.local) 中关于 support smart-splits 部分的配置。

### [9.3.4 关闭窗口分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_closing_a_window_split)

你可以随时使用以下三个键位绑定来关闭窗口：

- <Space>wq 关闭窗口，如果它是唯一打开的窗口，则会退出（quit）Neovim。
- <Space>wc 关闭窗口，如果它是唯一打开的窗口，则会显示错误并拒绝关闭。
- <Space>wd 删除窗口。它实际上执行的操作与 <Space>wc 完全相同，但它很好记住，因为它与"删除"打开的缓冲区的 <Space>bd 对称。

在这三种情况下，缓冲区都会继续保持在缓冲区线中打开。只有窗口分割被关闭。

如果你想关闭除活动窗口外的所有分割，可以使用 <Space>wo。助记方式：表示"只（only）保留这个窗口"或"关闭其他（others）窗口"。

### [9.3.5 调整窗口大小](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_resizing_windows)

在我非传统的观点中，调整 Vim 分割大小最简单的方法是...使用鼠标。垂直分割之间有一个垂直条，你可以点击并拖动。鼠标光标不会改变以提供任何反馈表明你可以点击和拖动它，但它确实有效。水平分割也同理。

如果你坚持使用键盘：<Space>w+ 和 <Space>w- 用于增加或减少水平分割中活动窗口的高度，<Space>w> 或 <Space>w< 用于增加或减少垂直分割的宽度。它们每次的调整只有一行或一列，所以你大概会想要在这些命令前加上大于 10 的计数，或使用下面讨论的"Hydra"模式。

要将所有内容更改为"默认"大小，使用 <Space>w=，这将使所有窗口"高度和宽度相等"。

### [9.3.6 Hydra 模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_hydra_mode)

有时，你可能想要连续执行几个窗口命令，例如在调整窗口大小或创建包含多个分割的布局时。在这些情况下，每个命令之间都要输入 <Space>w 会很繁琐，所以 which-key 插件为我们提供了 Hydra 模式。

要进入 Hydra 窗口模式，按 <Space>w<Space>。这会将窗口菜单保持"固定"打开，这样你就可以从中发出多个按键而不会自动离开菜单。例如，<Space>w<Space>vvvs 将创建四个分割（三个垂直和一个水平）。

要离开 Hydra 模式，只需按 <Escape> 即可返回到 normal 状态。

## [9.4. Tabs](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

LazyVim 的标签页系统很特别，跟我们平常用的不太一样。我来解释一下：

1. 首先，在 LazyVim 里，所有标签页共用同一个"打开的文件列表"（也就是缓冲区列表）。这点和其他编辑器不同，比如 VsCode 每个标签都是独立的。
2. 每个标签页可以有自己的窗口分布方式。比如：
   - 第一个标签页：你可以把窗口竖着分成三块
   - 第二个标签页：你可以把窗口分成四块，像网格一样排列
3. 在这些分割出来的窗口里（上面例子中总共有 7 个窗口），你可以：
   - 打开任何一个文件
   - 同一个文件可以在多个窗口中同时打开

所以说，Vim 的标签页更像是"布局方案"，而不是普通编辑器里的标签页概念。

LazyVim 有一个专门的标签页菜单，可以通过按 <Space><Tab> 访问：

<img src="mymedia\tab-menu-dark.png" alt="tab menu dark" style="zoom:50%;" />

### [9.4.1 新建标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

要新建标签页很简单：按 <Space><Tab><Tab> 就行。建好新标签页后，你可能会找不着它在哪！别急，看看屏幕上方缓冲区那一行的最右边，标签页都在那儿排着呢。

<img src="mymedia\tabs-in-buffer-line-dark.png" alt="tabs in buffer line dark" style="zoom:50%;" />

这个截图有两个标签页，在右侧标号为 1 和 2，旁边有一个 X。

> 左边的两个缓冲区不是标签页。我是不是强调太多次了？

不幸的是，除了数字外，标签页没有任何方式让自己看起来独特；无法预览每个标签页中哪些缓冲区是活动的或它们有什么布局。

### [9.4.2 将窗口移动至新建标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

如果你想把当前窗口移到新标签页：

- 按 <Space>wT（注意是大写的 T）
- 这个操作会：
  1. 关掉当前窗口
  2. 开个新标签页
  3. 在新标签页里显示同样的内容

> （ethan）看了原文，我也没有理解这样做有什么意义。Vim 的标签页更像是"布局方案"，而不是普通编辑器里的标签页概念，而且在 Vim 里，所有标签页共用同一个"打开的文件列表"。那么，关闭当前窗口分割，并在新标签页中创建相同的缓冲区，这有什么意义呢？后面我查了下，AI 有如下的说法：
>
> ------
>
> 想象你在写代码时的几个场景：
>
> 1. **不同的工作上下文**
>    - 标签页1：你在写主要功能
>      - 左边窗口放 controller 代码
>      - 右边窗口放 service 代码
>    - 标签页2：你在处理测试
>      - 左边是测试代码
>      - 右边是测试结果输出
> 2. **代码审查场景**
>    - 标签页1：查看整体代码结构
>      - 可能分成多个窗口对比不同文件
>    - 标签页2：深入某个具体功能
>      - 可能需要同时看这个功能的多个相关文件
> 3. **调试场景**
>    - 标签页1：代码编辑布局
>    - 标签页2：调试布局（日志、变量监视等）
>
> 所以说，标签页在 Vim 中的意义不是为了"打开多个文件"（这个用 buffer 就够了），而是为了：
>
> 1. 保存不同的工作布局
> 2. 快速切换不同的工作场景
> 3. 让工作流更有条理
>
> 这就是为什么有时你会想把一个窗口移到新标签页 - 你可能觉得："嗯，这个窗口的内容值得有个独立的工作区"，然后再在新标签页里**添加相关的分割窗口**。
>
> ------
>
> 但是，就我目前的使用场景而言，还没有找到标签页功能的实际应用需求。。。

### [9.4.3 在标签页中导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

要在标签页之间导航，你可以直接点击标签页上的数字，或者使用 Vim 默认的 gt、gT 键位来前往下一个或上一个标签页。另外，LazyVim 提供的 <Space><Tab>[ 和 <Space><Tab>] 键位也可以用来切换标签页。要想直接通过数字转到特定的标签页，可以在使用 gt 时加上该数字作为计数。例如 3gt 将显示标签页 3，而不是向右跳转三个标签页。

### [9.4.4 关闭标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

有几种方式可以关闭标签页：

- 只需关闭标签页中的最后一个窗口（即使用 <Space>wq），标签页就会消失。
- <Space><tab>d 键位将关闭标签页中所有的窗口以及标签页本身。不过缓冲区还是会保持打开。
- 点击标签页栏中标签页右侧的 X 图标。

## [9.5. Sessions](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_sessions)

在经过一天艰苦的编码后，你可能打开了几个缓冲区，并且将分割和标签页配置好，所有文件都在恰当的位置。如果能把代码收起来过夜，第二天回来时，所有的这些缓冲区、标签页和分割都保持原样，那不是很好吗？

LazyVim 默认启用了内置的会话管理。只需用 <Space>qq 关闭 LazyVim 就可以了。明天早上，使用 nvim 命令打开到仪表板，按 s 就可以继续了。

如果你忘记了打开仪表板，而是使用 nvim 打开了其他的文件，你可以使用 <Space>qs 将 Neovim 恢复到你上次关闭时的状态（不过，你在此期间修改和保存的任何文件仍将保持其新内容）。

当你临时用一下 Neovim 时，可以用 <Space>qd 来关闭。这样能保护你之前保存的工作状态不被覆盖。有些情况下这会自动完成，比如：写 git commit 这样的场景时系统会自动帮你处理，不用担心会丢失之前的工作环境。

## [9.6 代码折叠](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_code_folding)

Vim 的代码折叠系统几乎过于健壮，可能是因为它多年来经历了多次"最佳实践"的迭代。LazyVim 配置了当前的最佳实践，所以，你通常只需要使用到完整的折叠命令列表中的一小部分。

如果你不熟悉这个概念，代码折叠意味着：允许你通过将整个代码段折叠成一行来隐藏它们。从视觉效果上看，这与水平分割窗口，然后在分割的上下窗口中，阅读同一文件的两个部分类似，但当你使用折叠时，只有一个缓冲区的视图可见，并且它作为一个整体滚动。

考虑这段代码：

<img src="mymedia\no-folds-dark.png" alt="no folds dark" style="zoom:50%;" />

在编辑时，假设我对截图顶部的 clearExistingTimeout 函数和底部的 addTodo 函数感兴趣，但对中间两个 save 回调的内容不感兴趣。我可以折叠这些部分，我的代码会看起来像这样：

<img src="mymedia\folds-dark.png" alt="folds dark" style="zoom:50%;" />

大多数折叠操作都可以通过在普通模式下输入 z，来访问到 z 模式菜单（我们在第 3 章处理滚动时讨论了一些 z 模式操作）。要将一段代码折叠起来，使用任何你熟悉的导航操作到达该部分，然后输入 zc，表示"**c**ollapse fold"（折叠）。

要再次打开它，使用 zo，表示"**o**pen fold"（打开折叠）。

或者，如果你只想记住一个键位绑定，za 将切换折叠，如果所在的行不是折叠行，则折叠，如果在折叠行上，则展开。

如果你在多处折叠了代码，并想快速回到没有折叠的状态，使用 zR 可以打开所有折叠。我不知道 R 应该对应什么助记符，但一位早期读者帮助指出 zr 是"reduce folding"（减少折叠），所以 zR 是"Reduce folding BUT BIGGER"（减少折叠但更大）。

你甚至可以通过折叠已经折叠过的代码来嵌套折叠。如果你想递归打开折叠，使用 zO，它将展开一个折叠以及该折叠下嵌套的任何折叠。

按照 LazyVim 的配置，你对什么被折叠没有太多控制，但它通常会根据你的光标在文档中的位置做出你期望的事情。"你期望的事情"取决于你正在使用的语言的 LSP 和 TreeSitter 语法，但我发现最好就让它自己处理，不要与它争论。

如果你发现你想要更多的代码折叠控制，我建议完整阅读 :help folding。不过很有可能，你不想要更多的折叠控制，只想让 LazyVim 为你处理它！

## [9.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_summary_9)

在本章中，我们学习了 Vim 的缓冲区、窗口和标签页，以及它们不仅彼此之间不同，而且与许多其他窗口管理范式也不同。Vim 有与其他编辑器相同的概念，但它们有时以不同的方式混合或命名。

我们还介绍了代码折叠，用来更容易的处理大文件，还了解了会话管理，用来保存你的窗口配置并在之后回到它。当与 LazyVim 闪电般的启动时间结合时，这特别有用。当你不在编辑代码时，没有理由让你的代码编辑器保持打开消耗内存。

在下一章中，我们将深入研究 LazyVim 提供的一些出色的编程语言支持。这可以说是让 VS Code 变得惊人的一件事，但 Vim 社区已经从竞争对手那里学习，并最终超越了他们。

# [第10章：编程语言支持](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_programming_language_support)

Visual Studio Code 首创了语言服务器这个概念，随后其他文本编辑器也纷纷效仿。早期在 Vim 中使用语言服务器协议时，体验很差而且很笨重，需要安装一些容易出问题且配置复杂的插件。

后来，Neovim 决定直接在编辑器中内置语言服务器支持。虽然 Neovim 的内置支持还是不够完善，但随着时间推移，出现了一些稳定且简单的插件，让语言服务器的使用变得几乎自动化。LazyVim 就是这个进化过程的巅峰之作。

除此之外，Neovim 还内置了 TreeSitter 支持。TreeSitter 是一个强大的库，它可以在你编辑代码时实时解析并识别代码的语法树。LazyVim 已经配置好了所有需要的插件，让 TreeSitter 可以开箱即用。

语言服务器协议（LSP）为我们提供了很多功能，比如代码导航、函数提示、自动补全、特定的高亮和格式化功能、代码诊断等等。而 TreeSitter 则提供了更好的语法高亮、代码折叠，以及像你已经知道的 S 命令那样的基于语法的导航功能。

在 LazyVim 中，主要有两个工具用来处理语言服务器：各种语言的 Lazy Extras（懒加载扩展）和 Mason.nvim 插件。接下来我们会了解这两个工具，然后学习如何更好地使用它们提供的功能。

## [10.1 lang.* Lazy Extras](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_the_lang_lazy_extras)

我们之前已经用过 LazyVim extras 来配置插件，我也建议你安装你经常使用的编程语言对应的 extras。这些 extras 包含了预配置的插件，为常用的编程语言提供最好的支持。大多数 extras 都预装了语言服务器，很多还包含了一些对特定语言很有用的 Neovim 插件。

安装这些 extras 后，通常就能直接使用，而且你不需要学习新的快捷键。不过，建议你还是看一下这些 extras 安装的插件的说明文档（可以在 LazyVim 网站上查看 Extra 的文档，点击标题即可），以免错过某些语言特有的功能。比如，Python extra 自带了 venv-selector.nvim 插件，可以自动或手动激活各种 Python 虚拟环境。LazyVim 设置了快捷键 <Space>cv 来打开虚拟环境选择器，这里的 <Space>c 是"Code"子模式。

## [10.2. Mason.nvim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_mason_nvim)

Lazy Extras 可能不会安装你需要的所有工具。比如说，我就更喜欢用一个叫 Biome 的新型高速工具，而不是默认的 TypeScript 格式化和代码检查工具。

要安装这类工具，你可以使用 LazyVim 预装的 Mason.nvim 插件。用 <Space>cm 快捷键可以打开 Mason。弹出的窗口看起来和 Lazy.nvim 还有 Lazy Extras 的浮动窗口差不多，不过它的快捷键设置有点特别。

Mason 其实是一个很大的数据库，里面有各种编程语言支持工具，包括语言服务器、格式化工具和代码检查工具，以及它们的安装说明。

Mason.nvim 需要你的系统已经安装了一些基础工具。比如说，如果你要安装基于 Rust 的工具，你得先装好 cargo；如果要装需要 Python 支持的工具，就得先有 Python 和 pip。一般来说，如果你在用某种编程语言，你应该已经装好了 Mason 需要的工具。Mason 主要负责把这些工具安装到 Neovim 插件能找到的地方。

使用 Mason 最难的部分是知道你想安装什么工具。比如我，因为之前就在用 Biome，所以我知道需要为它安装编辑器支持。这很简单，在 Mason 的列表里找到 biome 就行了（和其他窗口一样，可以滚动、搜索，而且 Mason 把所有东西按字母顺序排列了）。

但当我开始写这本书的时候，我需要一个高级的 Markdown 格式化工具，可是我不知道该用哪个。我可以在窗口里搜索 markdown，然后按回车查看匹配项的描述和其他信息，但最后还是得用浏览器查资料，试了好几次才找到适合我的工具。

我没法告诉你哪个工具最适合你，但一旦你在 Mason 里找到了想要的工具，按 i 键就能安装光标所在位置的包。在 Mason 中你经常用到的另一个命令是 Shift-U，用来更新所有已安装的工具。其他命令可以按 g? 查看。

## [10.3 检查安装是否正确](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_validating_things_installed_cleanly)

不管你用什么编辑器，配置语言服务器、代码检查和格式化工具都会很容易出问题。虽然 LazyExtras 和 Mason 在安装这些工具时都做得不错，但我们还是需要知道如何检查它们是否正常工作。

首先说说通知功能。你应该已经看到过右上角会弹出一些通知，比如插件更新的提示。这些通知几秒钟就会消失。但有时候，我们需要重新查看这些通知。

这时就要用到 <Space>sn 快捷键了。它会打开"Noice"菜单。Noice 就是负责显示这些小弹窗的插件。一般来说，你可以：

- 按 <Space>sn + a 查看所有最近的通知
- 按 <Space>sn + l 只看最后一条通知

你也可以用 <Space>snd 来关闭当前显示的通知。不过说实话，等你按完这四个键，通知可能早就自己消失了！

第二个重要的调试命令是 <Space>cl。它会运行 :LspInfo 命令，显示：

- 当前正在运行的语言服务器有哪些
- 这些服务器分别在处理哪些文件

举个例子，当我编辑 Markdown 文档时，LSPInfo 窗口是这样的：

<img src="mymedia\lsp-info-dark.png" alt="lsp info dark" style="zoom:50%;" />

从这个窗口看，一切正常（虽然我有点意外 tailwind 服务器会和 Markdown 关联）。如果你的语言服务器出问题了，这个窗口通常能给你一些提示。

如果语言服务器出现临时问题，比如：

- 显示错误的诊断信息
- 找不到明明存在的文件

这时候用 :LspRestart 命令重启一下就好了。比如 Svelte 语言服务器经常检测不到新文件，我最近经常要用这个命令，所以我还专门给它设置了快捷键。

还有两个特别有用的命令：

1. :checkhealth
2. :LazyHealth

这两个命令都能显示已安装插件的健康状况：

- :checkhealth 是 Neovim 的命令，插件可以注册健康检查信息
- :LazyHealth 专门显示 LazyVim 相关的信息

这两个命令的输出有很多重叠，但是：

- :LazyHealth 的输出更容易读懂
- :checkhealth 的信息更全面

所以我一般先用 :LazyHealth，如果找不到答案再用 :checkhealth。

不要期望所有检查都是绿色的，这样会把自己逼疯的。比如我的 checkhealth 输出就有很多来自 Mason 的警告：

<img src="mymedia\lazy-health-dark.png" alt="lazy health dark" style="zoom:50%;" />

只有我最近用过的工具（以及出于某种原因的Ruby）是已安装的。对于那些我平时不需要编辑的语言，就会显示警告。所以如果你不写 Java 代码，就没必要费心去解决 java 的警告。

## [10.4. 诊断功能](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_diagnostics)

语言服务器有很多有用的功能。它可以：

- 进行代码检查，找出代码中的问题
- 格式化代码
- 提供上下文相关的代码导航
- 提供文档说明

我们会在这章和下一章详细讨论这些功能。

在第七章中，我们已经简单接触过诊断功能。当时我们学习了如何使用 unimpaired 快捷键在错误信息之间跳转：

- [d、[w、[e：跳转到上一个诊断处
- ]d、]w、]e：跳转到下一个诊断处

诊断信息通常会以波浪线（在某些不支持波浪线的终端上，他是下划线）的形式出现在代码下方。当你跳转到这些位置时，通常会弹出一个小窗口，告诉你这里出了什么问题。

比如看这个截图，我打错了一个单词导致了一个错误：

<img src="mymedia\diagnostic-dark.png" alt="diagnostic dark" style="zoom:50%;" />

我把"tracingMiddleware"拼错了。在这一行，我可以看到一条错误提示。当我用 ]d 跳转到这个错误时，会弹出一个窗口。这个窗口有时候会显示比行内提示更详细的信息。

另外，导入正确拼写变量的那一行也显示了一个提示，告诉我这个变量没有被使用。

诊断信息用不同的颜色表示严重程度，这样你就能判断是否值得修复。我通常会尝试修复或消除所有诊断信息，因为如果有太多干扰信息，诊断功能就会变得不那么有用。

如果在导航到诊断位置时窗口没有弹出，只要你的光标位于带下划线的文本范围内，就可以使用 <Space>cd 快捷键来调出窗口。

### [10.4.1. Trouble 和 Quick Fix（todo）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_trouble_and_quick_fix)

你还可以使用 Trouble 来导航诊断信息。Trouble 是 LazyVim 的一个插件，它提供了增强版的 Quickfix 功能。（如果你是 Vim 新手，可能不知道 Quickfix 是什么，他其实是vim/neovim原生的一个功能，本质上是一个特殊的列表窗口，用于收集和展示各种位置信息，比如搜索结果、编译错误、代码诊断等）

对于 **Quickfix**，想要列出当前文本的诊断信息，使用 <leader>xq

![image-20241222124955823](mymedia\quickfix_preview.png)

> （ethan）如果当前文本确实有诊断信息，比如一些错误、警告，但是使用 <leader>xq 打开的窗口中却没有任何显示，可以先在命令模式中键入：lua vim.diagnostic.setqflist()，将所有诊断发送到 quickfix。

对于 **Trouble**，想要列出当前所有已打开的 Buffer 的诊断信息，使用 <leader>xx，若只想列出当前 Buffer 中的诊断信息，使用 <leader>xX。

![image-20241222125126406](mymedia\trouble_preview.png)

在 Lazyvim 中，将 Quickfix 和 Trouble 的功能都集成到了 Trouble 菜单中，使用 <leader>x 菜单（我猜 x 代表"fiX"）即可打开：

![diagnostics menu dark](mymedia\diagnostics-menu-dark.png)

**Trouble 作为增强版的 Quickfix，他除了能够提供导航诊断信息的功能外，还可以做很多其他的事情。**

如上所述，Trouble 窗口本质上是一个文件和行号的列表，这些位置因某些原因被标记为"感兴趣"（这些原因可能是：诊断、TODO、FIXME），具体原因取决于上下文和你如何打开它们。你可以轻松地在这些目标位置之间跳转。

- 对于 todo，按 <Space>xt ：

  ![image-20241222130205982](mymedia\trouble_todo.png)

- 对于搜索结果，在使用 telescope 时，按 ctrl + t（trouble）（如果按 ctrl + q（quickfix）则会发送到 quickfix 窗口打开）：

  ![image-20241222131130087](mymedia\trouble_search.png)

可以在 Trouble 窗口移动光标到相应行并按 Enter（或者在打开了 Trouble 窗口期间，使用 [q 和 ]q 命令）来在多个文件目标之间导航。

如果你想知道 <leader>x 菜单中的"Location List"是什么，它是一个与当前窗口（不是缓冲区）关联的 Quick Fix 窗口（意味着每个窗口都可以独立打开他）。我从不使用它，因为我的大脑一次只能处理一个问题！

## [10.5. 代码操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_code_actions)

代码操作（Code Actions）是让 VS Code 在刚推出时显得很神奇的功能之一。不是说这个概念很新，因为它已经存在很久了，而是因为它真的很好用。现在，我们已经有点把它当作理所当然了。

![image-20241221164214005](mymedia\vs-code_codeaction.png)

你可能习惯于（在 VS Code 中）用鼠标点击灯泡图标或右键点击诊断信息来访问"代码操作"。在 LazyVim 中，这当然是通过快捷键实现的。使用你习惯的快捷键导航到诊断位置（我习惯用 ]d），然后按 <Space>ca 打开菜单，其中 c 和 a 表示"code action"。接着会弹出一个选择器菜单，列出所有可以执行的操作。你可以使用方向键，或者按 <Escape> 后用 j 和 k 键在选项之间导航，也可以输入数字或任何文本来过滤。按 <Enter> 执行操作，或按 <Escape><Escape> 取消菜单（只按一次 escape 可以进入搜索框的普通模式，这样你就可以使用你现在已经熟悉的众多 LazyVim 导航快捷键）。

## [10.6. Linting](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_linting)

代码检查（Linting）主要是通过 nvim-lint 插件而不是 LSP 来处理的。在我使用 LazyVim 之前，这是一个主要的痛点，因为让 LSP 和代码检查器协同工作通常需要一些严肃的故障排除。再加上格式化，我可能要花一两天时间才能搞定。说实话，在我使用 VS Code 时也是这样。

使用 LazyVim 时，你可能根本不知道是谁在为你做代码检查。说实话，我也不知道。我的一些诊断信息来自 LSP，另一些来自代码检查器。我不会去追究错误的来源，我只管修复它们。

代码检查最困难的部分（至少在它不能自动工作时）是确保安装了适当的检查器（Mason 在这方面可以帮你），并且配置正确。如果你很幸运，你喜欢使用的语言有 Lazy Extras，那么它可能已经配置正确了。否则，你可能需要做一些调整。这些调整取决于具体的语言，但你可能需要在插件目录中的 extend-nvim-lint.lua 文件中添加类似这样的内容：

```lua
return {
  "mfussenegger/nvim-lint",
  opts = {
    linters_by_ft = {
      typescript = {
        -- lint settings for Typescript
      }
    },
  },
}
```

更多信息请查看 :help nvim-lint，如果需要进一步说明，请参考 LazyVim 关于这个配置的文档。

好消息是，一旦配置好代码检查，错误就会通过上面描述的诊断功能显示出来，你可以使用相同的快捷键、Trouble 窗口、代码操作等来处理它们。

## [10.7. Formatting](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_formatting)

和代码检查类似，代码格式化可以由某些 LSP 处理，但人们发现使用语言服务器往往比直接调用格式化工具更复杂。所以 LazyVim 自带了 conform.nvim 插件。

同样和代码检查类似，如果你够幸运，在安装适当的 Lazy Extra 和/或 Mason 工具后，它就会自动工作。但是，如果你不喜欢默认的格式化工具（或者它不工作），你就需要熟悉 LazyVim 和 conform.nvim 的文档，找出所需的具体配置。

我唯一需要手动配置的格式化工具是用于 Markdown 的 Prettier。它的配置看起来和 nvim-lint 的配置非常相似：

```lua
return {
  "stevearc/conform.nvim",
  opts = {
    formatters_by_ft = {
      ["markdown"] = { "prettier" },
    },
  },
}
```

一旦设置好了（我承认这可能并不容易），LazyVim 中的格式化通常就是一劳永逸的：保存文件时它就会自动格式化。如果你想在不保存的情况下手动调用格式化，可以使用 <Space>cf 快捷键。我不得不强调你有多幸运，因为在没有 LazyVim 的情况下，人们浪费了无数时间试图让"保存时格式化"的自动命令正常工作！

## [10.8. 配置非标准 LSP](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_configuring_non_standard_lsps)

如果你安装了一个 LazyVim 不知道的 LSP，你可能需要调整 nvim-lspconfig 插件。你至少需要让它知道你的语言服务器是可用的，可能还需要根据你的需求进行配置。例如，我最喜欢的编程语言之一是 Rescript，它没有庞大的生态系统，因此也没有 LazyVim extra。我可以很容易地用 Mason 安装语言服务器，但我还需要在 extend-lspconfig.lua 文件中添加以下内容，让 LazyVim 能够识别它：

```lua
return {
  "neovim/nvim-lspconfig",
  opts = {
    servers = {
      rescriptls = {},
    },
  },
}
```

再举个例子，css_variables 语言服务器（我在出色的 open-props CSS 框架中使用它）对 css 文件可以开箱即用，但我需要使用不同的配置来在 svelte 文件中激活它：

```lua
return {
  {
    "neovim/nvim-lspconfig",
    opts = {
      servers = {
        css_variables = {
          filetypes = { "css", "scss", "less", "svelte" },
        },
      },
    },
  },
}
```

## [10.9. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-10/#_summary_10)

在本章中，我们学习了 LazyVim 如何集成 VS Code 带给世界的语言服务器协议。它通常快速且无痛，这比手动配置 LSP 要好得多。不过，在代码检查和格式化方面可能会遇到一些麻烦。这在任何编辑器中都是如此，有时它们会帮你，有时又会妨碍你。如果你遇到困难，可以在 GitHub 上的 LazyVim discussions 组中寻求帮助（但先自己搜索排查一下，你可能不是第一个遇到这个问题的人）。

在下一章中，我们将学习更多关于使用 LSP、TreeSitter 和其他插件进行代码导航的内容。

# [第11章：在源文件间导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_navigating_source_files)

在前面的章节中，我们学习了在单个缓冲区内以及在打开的标签页和窗口之间导航的多种方法。这一章我们将详细介绍在不同的源文件之间导航的各种方法。

## [11.1. 跳转到定义](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_go_to_definition)

我认为"跳转到定义"是语言服务器给我们带来的最有价值的功能。主流的 IDE 在很久以前就已经为编译型语言提供了这个功能。但是对于像 Python 这样的动态类型语言来说，静态分析一直都很困难，这类功能往往效果不太理想。

"跳转到定义"这个功能的名字起得很贴切 —— 它可以让你的光标从当前所在的关键词直接跳转到这个关键词被定义的位置，不管这个定义在哪个文件里。

我最常用这个功能的场景是：当我在看一个函数的调用位置时，想要查看这个函数的具体实现。只需要简单地按下 gd（这也是 LazyVim 中最容易记住的快捷键之一），就能立即跳转过去。

根据你正在编辑的语言的 LSP（语言服务器）的性能，这个功能通常还能让你跳转到第三方库的文件或类型声明中，这样你就能看到更底层发生的事情。

跳转到定义是和上下文相关的，但通常都能按照你的预期工作。比如，当你的光标在一个变量上时，gd 会跳转到这个变量的初始化位置；如果光标在一个函数上，它会跳转到这个函数的定义位置。

通常，当你跳转到定义并了解到需要的信息后，你会想立即回到之前的位置。就像我们在第 3 章讨论过的，你可以使用 Control-o 轻松地返回（而 Control-i 则可以在你的跳转历史中向前移动）。

## [11.2. 跳转到引用](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_go_to_references)

与"跳转到定义"相对的是"跳转到引用"命令。当你想要看到某个函数、变量或类型在哪些地方被使用了，就可以使用 gr 命令。

与定义或声明不同，一个词通常会有多个引用位置（毕竟一个从不被使用的变量是没有意义的）。所以当你输入 gr 时，它通常不会直接跳转到某个位置，而是会弹出一个选择器，显示光标下这个词的所有引用位置。这个选择器带有 Telescope 和 Fzf.lua 提供的所有预览和过滤功能。

有时候你可能想要对每个引用都执行某些操作，比如重命名或添加参数之类的。你可以重复使用 gr 命令，或者使用 <Space>sR 快捷键来重新打开上次的搜索。不过，使用我们在第 10 章学过的 Trouble 列表通常会更有用。

要使用 Trouble 列表，先用 gr 在选择器中显示引用，然后使用 Control-t 打开 Trouble 窗口，窗口中会显示所有匹配项。这样你就可以使用 ]q 和 [q 在它们之间跳转，而不用每次都打开选择器。如果你更喜欢使用较为简单的 Quick Fix 窗口，可以在选择器中使用 Control-q 来代替 Control-t。

![image-20241221172319002](mymedia\trouble_ctrl-t.png)

Control-t 和 Control-q 在大多数选择器中都可以使用。我建议你养成使用它们的习惯，特别是当你需要一个比选择器更持久的列表时。

## [11.3. 上下文相关的帮助](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_context_specific_help)

大多数非模态编辑器在你把鼠标悬停在某个词或符号上时，都会显示帮助或"悬停"文本。这些文本的数量和价值根据 LSP 的不同而差异很大，但一般会包括函数签名和光标下单词的文档说明。

虽然可能可以设置 Neovim 在鼠标悬停时显示帮助文本，但是既然 LazyVim 提供了这么好用的键盘导航，为什么还要把手移到鼠标上呢？你可以直接使用（大写的）K 快捷键。是的，K 这个快捷键确实不太好记，但是 H 和 ? 已经被占用了。

> （ethan）我的配置中，将此功能映射成了 <Space>ck
>
> ![image-20241221173108183](mymedia\hover_doc.png)

> 实际上，K 代表 "keywordprog"，这是一个传统的 Vim 概念，在现代已经被语言服务器取代了。所以 LazyVim 就重新利用了这个快捷键。

## [11.4. 列出符号](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_listing_symbols)

另一个好用的 LSP 功能是搜索当前文件或项目中的所有符号。如果你正在编辑一个特别长的文件，需要跳转到一个离光标很远的函数，你可以使用 <Space>ss 命令（助记词是 "search symbols"）。正如双 s 所暗示的，这是一个很常用的操作。

弹出的对话框现在应该很熟悉了，因为它就是我们常用的选择器：

<img src="mymedia\telescope-symbols-dark.png" alt="telescope symbols dark" style="zoom:50%;" />

你已经知道如何使用它了。不过，我想提醒你几个让它更有用的选择器技巧：

大多数时候，当我使用这个符号选择器时，我只关心函数，有时候是类。所以上面截图中散布的字段和属性只是干扰。虽然可以配置选择器只显示特定类型的符号，但我更喜欢用一个快速技巧来把结果缩小到只显示函数：先输入（部分）单词 function。

因为选择器在结果的第二列包含了 "function" 这个词，它会很方便地过滤掉所有不包含这个词的行。很方便吧。

我可以在 "function" 这个词后面输入一个空格，告诉选择器在第一列中继续后续搜索。所以 "func api" 会过滤出所有包含 "api" 的函数。

我的第二个提示是不要忘记使用 Control-q 和 Control-t 快捷键，把选择器的结果导出到 Quick Fix 或 Trouble 列表中。它会为你过滤出的任何符号生成一个快速简单的目录窗口。

如果你想搜索整个项目中的所有符号，可以使用 "更大范围" 的助记符。<Space>sS 会执行这样的搜索。不过，要注意并不是所有的 LSP 都支持工作区符号搜索。有些只搜索当前打开的文件，即使是那些完全支持工作区符号搜索的 LSP，很多也慢得无法使用。

## [11.5. Neo-tree 也有符号大纲](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_neo_tree_also_has_a_symbols_outline)

如果你喜欢使用 Neo-tree 侧边栏来选择文件，你可能也会喜欢它基于聚焦文件的符号列表功能。不过在撰写本文时，Neo-tree 在其 Readme 中声称符号选择器是 "实验性" 的，所以在默认情况下没有显示它的快捷键。

可以使用命令 :Neotree document_symbols 在你的 Neo-tree 侧边栏中渲染符号选择器：

<img src="mymedia\neotree-symbols-dark.png" alt="neotree symbols dark" style="zoom:50%;" />

> （ethan）不过这个命令也不是开箱即用的，还需要额外的配置（请参考这个插件的文档），否则会报错。

你可以通过鼠标双击，或将光标移动到包含你想要跳转的符号的行上，按下 <Enter> 来导航到文档中的符号。你也可以使用 s 或 S 在垂直或水平分割的新视图中打开缓冲区中的给定符号。

如果你发现你对 Neo-tree 符号选择器爱不释手，你可能想要为该命令添加一个键盘快捷键。只需在你的插件目录中的文件中添加以下配置：

```lua
return {
  {
    "nvim-neo-tree/neo-tree.nvim",
    keys = {
      {
        "<leader>sO",
        "<cmd>Neotree document_symbols<cr>",
        desc = "Document Symbols (Neo-tree)",
      },
    },
  },
}
```

如果 <Space>s<Shift-O> 不适合你，可以随意使用其他快捷键。

## [11.6. ...Trouble 也有！](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_and_so_does_trouble)

你也可以使用 Trouble 插件打开符号大纲。快捷键是 <Space>cs，你可能很难找到它，因为它在 Code 菜单而不是 Search 菜单中。与大多数 Trouble 窗口不同，它默认在右侧边栏打开。它创建了一个漂亮的树状视图，你甚至可以使用我们在第 9 章讨论过的折叠快捷键来折叠和展开树节点。

<img src="mymedia\trouble-symbols-dark.png" alt="trouble symbols dark" style="zoom:50%;" />

你可以使用用于调整窗口大小的快捷键（<Space>w< 和 <Space>w>）来调整 Trouble 窗口的大小。当你将光标移动到 Trouble 窗口上时，它所在的符号会自动滚动到视图中。

使用 Trouble 窗口最快的方法是使用 Seek 模式。记住 Seek 模式可以跳转到任何当前可见的窗口，包括 Trouble。所以如果我正在编辑上面的文件，并且我的光标当前在文件的末尾附近，我可以使用 spub 进入 Seek 模式并搜索字符 "pub"。这将在 Trouble 窗口中的 publicKeyToken 上放置一个标签。如果我键入那个标签（字符），我的光标就会跳到 trouble 窗口，我的编辑器窗口会立即滚动到相关的函数，接着只需按 Enter 键就可将光标移回我正在编辑的文件。

> （ethan）如果 enable 了 aerial.nvim 插件，则 <Space>cs 会启用 aerial.nvim 插件的符号列表功能。

## [11.7. 上下文](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_context)

nvim-treesitter-context 扩展是一个帮助你了解当前文件位置的有用工具。它使用 treesitter 来确定你所在的函数和类型，然后将定义这些类型的行固定在编辑器顶部。

> 像往常一样，通过访问 :LazyExtras 并在包含 nvim-treesitter-context 的行上按 x 来启用它。

这个插件会跟踪你的光标当前所在的类或函数。如果函数或类型定义太长以至于签名滚动出屏幕，它会很贴心地将该签名复制到代码窗口的第一行或前几行，并用稍微不同的背景色突出显示。

用一张参考图片来描述会更容易理解，请看这个截图：

<img src="mymedia\context-dark.png" alt="context dark" style="zoom:50%;" />

在这张图片中，稍微有阴影的前两行是提供上下文的，而不是缓冲区的一部分。第一行告诉我我在 DexieApiClient 类中，第二行告诉我我当前正在查看该类中的 forceAddMemberToRealm 方法。

特别注意相对行号列。DexieApiClient 类的行在我当前光标位置上方 109 行，而 async forceAddMemberToRealm 行在其上方 27 行。相比之下，函数的第一个可见行只在我当前光标位置上方 13 行。

这个效果很微妙，上下文部分的定义往往正是你在编码时需要的。而如果你确实需要滚动到签名处，只需输入相对行号后跟 k，就可以直接到达。

如果你需要临时禁用上下文，使用快捷键 <Space>ut。我们还没有看到太多 <Space>u 菜单，在这里你可以切换各种用户界面效果。这主要是因为默认用户界面配置得足够好，你不会经常想要改变它！

## [11.8. 使用标记（书签）导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_navigating_with_bookmarks)

你已经知道如何使用 Control-o 和 Control-i 在历史记录中导航，以及使用各种动作在文档中有效地跳转。

Vim 还包含一个 "书签" 功能，不过它被称为 "marks"，我猜是因为 b（bookmark） 字符已经被使用了，而 m 字符在 Vim 快捷键中是空闲的。

标记是内置在 Vim 中的，而 LazyVim（像往常一样）添加了一些小改进。

就像我们在第 8 章中介绍的寄存器一样，标记可以分配给字母表中的每个字母。此外，某些标点符号代表特殊的系统设置标记，你可以跳转到这些标记，但不能设置它们。

要在某行设置标记，在任何字母、字符的前面加上字母 m。所以 ma 会在当前行设置标记 a。你可以通过左侧槽中的 a 字符看出这一行被标记为 a：

<img src="mymedia\mark-a-dark.png" alt="mark a dark" style="zoom:50%;" />

现在我可以从当前文件的任何位置使用撇号（'）后跟 a 来跳转到标记为 a 的行。

我不经常使用这个功能，因为在文件内导航时，其他工具往往比手动设置书签更有用。但是，如果我用大写字母标记了这一行（例如 mA），我就可以使用 'A 从任何打开的文件跳转到这个标记。

所以本质上，你可以在你打开的每个文件中设置多达 26 个本地标记，以及 26 个可以从任何文件访问的全局标记。

方便的是，如果我只输入一个撇号（在普通模式下），LazyVim 会弹出一个当前可用的所有标记的菜单：

<img src="mymedia\marks-dark.png" alt="marks dark" style="zoom:50%;" />

这个列表显示了我在这个文件中设置的小写标记，几个可以使用标点符号跳转到的系统标记（注意右侧有每个标记的描述，所以你不必记住它们），两个我用来跳转到 kitty 和 fish 配置文件的全局标记，以及十个数字标记。

我发现数字标记有点无用。它们基本上指向你上次关闭 Neovim 时的文件和光标位置。除非我在临时实例中编辑提交消息或拉取请求描述，否则我不经常关闭 Neovim，所以我的数字标记大多只是这些临时文件。如果我需要回到之前的位置，使用 <Space>qs 快捷键来恢复会话通常会比数字标记更有用。

按撇号键（'）时弹出的菜单通常足以找到标记，但你也可以使用 <Space>sm 快捷键在选择器中搜索标记。我通常没有足够多的活动中的书签来让这个功能有用，但如果你设置了很多全局和本地标记，并且记不住哪个字母与哪个标记相关联，使用选择器来搜索标记的内容可能会很有帮助。

当你设置了标记，你一定会被 "如何删除它？" 这个问题困扰。删除标记可能与 "如何退出 Vim" 一样是最常见的查询之一！没有删除标记的快捷键。相反，你需要使用命令 :delmarks <mark> 来删除给定的标记。这可以缩写为 :delm <mark>。所以要删除这个文件中的 a 标记，需要使用命令 :delmarks a。你不必在标记的行上就能删除标记。

> 在命令模式下，可以使用 "标记访问" 代替 "行号范围"。例如：
>
> 若想将标记 a 和标记 b 之间的文本写入文件，你可以使用 :'a,'b write somefile.txt。
>
> 额外提一点，你也可以在可视模式中选定一段文本，然后再进入命令模式，就会出现 '<,'> 字样，那是因为 '< 和 '> 代表最近一次可视选择的开始和结束。
>
> 即使选择已经取消，你也可以使用 '< 和 '> 跳转到最近一次选择的开始或结束位置。

我经常使用的另一个符号标记是 '.，它跳转到我最后插入或更改文本的位置。有时这比一系列 Control-o 按键更快。

## [11.9. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-11/#_summary_11)

在本章中，我们学习了如何使用转到定义、转到引用、以及使用各种 "文档符号" 插件来导航代码文件。

我们看到了 LazyVim 如何为我们提供文档中当前位置的上下文，以及如何查找光标下符号的文档。

最后，我们介绍了 Vim 标记，这是一个更加 "手动的" 跟踪你可能想要跳转到的位置的过程。

在下一章中，我们将学习如何在当前文件和整个项目中搜索**文本**。

# [第12章：搜索...](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_searching)

说来也奇怪，我们讲了这么多却还没有涉及搜索功能。在大多数编辑器中，查找和替换功能通常就是一个简单的对话框，里面有几个输入框，运气好的话可能还有个正则表达式的复选框。但在 Vim 中，这个功能要强大和精细得多。

LazyVim 在 Neovim 强大的搜索功能基础上做了改进，让它变得更易用也更美观。你已经知道了 Seek 模式（s）和 Treesitter 模式（S）可以用来导航和选择你能看到的内容，以及它们对应的远程操作等待模式：r 和 R。这些功能在目标文本就在眼前时很好用，但如果你需要搜索整个文件并自动滚动到搜索结果，这些功能就不够用了。

## [12.1. 在当前文件中搜索](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_search_in_current_file)

在 Vim 中搜索很简单，只需要在普通模式下输入 / 命令就可以。为什么用 / 呢？因为 / 键和 ? 键是同一个键，而搜索本质上就是在问一个问题。

> 有趣的是，很多非模态编辑器也采用了 Vi 的这个 / 搜索命令。比如，优秀的任务管理工具 Linear 就用 / 来开始搜索，GitHub 也是如此。

当你第一次在普通模式下按 / 时，可能会觉得光标不见了！别担心，它不会弹出新窗口。实际上，/ 会在当前文件的状态栏显示一个放大镜图标：

<img src="mymedia\search-dat-dark.png" alt="search dat dark" style="zoom:50%;" />

在这张图片中，我输入了 /dat。/ 启动了搜索模式，然后我搜索了 "dat"。此时我的光标在搜索框中。

如你所见，LazyVim 很贴心地高亮显示了所有（可见的）匹配结果。此外，光标所在位置往后的第一个匹配项，他会更亮一点，即"主要匹配结果"。

按回车确认搜索后，光标会跳转到主要匹配结果。像往常一样，按 Esc 可以取消搜索。

这时你已经回到了普通模式，可以正常编辑文件了。**不过要注意，所有匹配结果的高亮还在**。你可以用 n 键（next 的意思）轻松跳到下一个结果。这个命令可以接受数字前缀，比如 3n 就会跳到当前光标位置之后的第三个结果。

如果文档底部没有更多匹配结果，则会自动回到文档顶部继续搜索。如果你知道要跳过几个结果，也可以在 / 命令时直接加上数字，比如 3/something 就会直接跳到第三个 "something"。不过要计算跳过几个结果需要动点脑筋，这种场景下，还不如使用 Seek 模式。

如果你按 n 跳过头了，可以用 Shift-N 回到上一个结果。如果你一开始就知道要往回搜索，可以用 ?（也就是 Shift-/）来代替 /。

> 如果你以前用过 Vim，要注意 LazyVim 中 n 和 N 的行为和默认的 Neovim 不太一样。在 Neovim 中，它们会"重复最后一次 / 或 ? 命令"，所以如果你用 ? 开始搜索，按 n 会继续向上搜索。但是 LazyVim 的方式更容易记：n 永远是"向下找下一个"，N 永远是"向上找上一个"。

## [12.2. 忽略大小写](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_ignore_case)

默认情况下，如果你输入的搜索词全是小写字母，LazyVim 会忽略大小写。但如果搜索词中包含大写字母，就会启用大小写敏感模式。比如，搜索 in 会匹配 in 和 In，但搜索 In 只会匹配 In。

如果你明确想只搜索小写匹配项，可以在搜索词中加入 \C（注意这个 C 要大写）。

有个方便的特点是，\C 不一定要放在搜索词的开头。搜索的字符串中任何位置出现 \C 都会让整个搜索变成大小写敏感。比如，假设你要搜索小写单词 "initiate"。当你输入 in 后，发现因为忽略大小写而匹配到很多不需要的 In，你可以先加上 \C（变成 in\C），然后再继续输入 iti（即搜索框中的字符串是：in\Citi）。

如果你想临时禁用忽略大小写，可以输入命令 :set noignorecase。这个设置会持续到你退出 Neovim，或者用 :set ignorecase 重新启用为止。

如果你想永久改变这个设置，打开 options.lua 文件，在其中添加 vim.opt.ignorecase = false。注意，这样设置后，如果想让某个特定搜索忽略大小写，需要在搜索词中使用小写的 \c 而不是 \C。

\C 这个技巧一开始可能看起来有点奇怪，但想想在大多数代码编辑器中的替代方案：你得把手移到鼠标上，瞄准一个标着 wW 的小复选框并点击它，然后重新聚焦到搜索框继续输入。相比之下，你可能会觉得 \C 更快。

## [12.3. 正则表达式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_regular_expressions)

Vim 的搜索默认支持使用正则表达式，但这些正则表达式有点特别。

好吧，其实所有的正则表达式都有点特别。Vim 的正则表达式和大多数现代编程语言中常见的 PCRE 风格的正则表达式相比才显得特别。不过，如果你只是搜索文本，可能用不到 Perl 兼容表达式提供的所有复杂功能。

这本书篇幅有限，我不能详细讲解正则表达式语法，就只介绍一些常用的部分：

- `.` 匹配任意单个字符。如果要搜索真正的句点，需要用 `\.` 转义。
- `\S` 匹配任何非空白字符。
- `*` 匹配前面的表达式零次或多次。特别值得注意的是，`.*` 会匹配任意长度的任意字符串。
- `\+` 匹配前面的表达式一次或多次。（这和大多数正则表达式解析器不同，其他解析器通常不需要在 `+` 前加 `\` 符号）。它也可以和其他表达式组合，比如用 `\S+` 匹配任何不含空格的词。
- `\=` 用来匹配前面的模式零次或一次。比如 https=: 中的 "s" 是可选的。在大多数正则表达式引擎中这个模式用 `?`，实际上 `?` 在这里也可以用。但因为 `?` 在 Vim 中用来表示向后搜索，所以 `=` 更好。
- `\\` 匹配反斜杠，`\/` 匹配正斜杠。

总的来说，如果你熟悉 PCRE 风格的正则表达式，你会发现 Vim 中需要更多的反斜杠。不过，上面这些已经能覆盖代码编辑器中绝大多数的搜索需求了。

如果你想在特定搜索中"禁用"正则表达式匹配，可以在行首（或者如果只想禁用剩余部分的正则匹配，可以在中间）放置 \V。"V" 代表 "very nomagic"，如果你想被彻底搞晕的话，可以输入 :help magic 看看。这个概念太让人困惑了，以至于你会更愿意直接学习使用正则表达式（是的，我知道这听起来很矛盾。但 Vim 对 magic 的解释更让人头疼）。

如果你真的需要用正则表达式做什么特别的事，可以让 ChatGPT 帮你浏览 :help regular expressions 找到需要的语法。你要么会豁然开朗，要么会更加困惑。。。

## [12.4. 在项目中搜索](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_search_in_project)

如果你需要在整个代码库而不是单个文件中搜索某个词，可以用 <Space>/ 命令代替单独的 /。这会弹出我们熟悉的选择器，这次是以 live_grep 模式运行。

确保你已经安装了 ripgrep 并且可以在命令行中用 rg 访问它，因为选择器底层就是用它来搜索的。 输入你要搜索的字符串，结果会显示在左侧，右侧会显示文件预览，这样你就能确保找到了正确的内容：

<img src="mymedia\live-grep-dark.png" alt="live grep dark" style="zoom:50%;" />

记住，你可以按 <Esc>s 进入 Seek 模式为 Telescope 结果添加标签，从而跳转过去，或者用 Control-x 为 Fzf.lua 结果添加标签，跳转过去。我发现这在 live_grep 窗口中特别有用，因为和大多数选择器的逻辑不同，live_grep 中的空格会作为字面量空格发送给 ripgrep，而不是用来缩小搜索范围。

由于这是个选择器，你可以在它打开时按 ctrl-t 把所有搜索结果放到 Trouble 窗口中，这样你就可以在编辑时用 ]q 和 [q 导航这些结果。

比较烦人的是，这种搜索模式和 Vim 内置的搜索（按 \ 启动的搜索）完全不同。它只是把你的输入传给 ripgrep 并按 ripgrep 的方式工作。而 ripgrep 不知道 Vim 那些奇怪的正则表达式引擎。它确实支持正则表达式，但语法和 Vim 完全不同。准确地说，它用的是除了 Vim 之外几乎所有程序都在用的语法。在这里让人头疼的是 Vim，而不是 ripgrep。这一点要说清楚。

Ripgrep 本身接受很多命令行选项，但默认情况下，live_grep 功能不支持传递参数给 ripgrep 来调整你的查询。如果你想成为 live_grep 高级用户，Telescope 项目提供了一个 telescope-live-grep-args 扩展可以启用。在第 19 章会介绍如何配置这个扩展，这是 LazyVim 的抽象偶尔会妨碍使用的一个典型例子。

## [12.5. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-12/#_summary_12)

本章都是关于搜索的：用 / 快捷键进入搜索模式，用 <Space>/ 快捷键进入项目范围的搜索模式。后者的功能没有那么强大，所以我们还可以设置 telescope-live-grep-args 插件来让我们对项目范围搜索有更多控制。

当然，搜索只是故事的一半。在下一章，我们会介绍文本替换，既包括作为搜索操作的一部分，也包括更大范围的项目级替换。

# [第13章：...替换](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_and_replacing)

Vim 有一个非常强大的查找替换功能。说实话，这个功能需要一定时间才能习惯。用惯了之后，你会觉得其他编辑器的查找替换功能都不够用；但要完全掌握它，可能需要很长时间。

查找替换功能的历史其实比 Vim 和 Vi 都要久远，它最早可以追溯到传奇人物 Ken Thompson 开发的 ed 编辑器。Ken Thompson 写了第一篇关于正则表达式的论文（他还创造了很多其他基础工具）。我觉得 ed 编辑器可能是最早在实际应用中使用正则表达式的地方。

ed 编辑器中的替换功能太强大了，以至于它存活了超过半个世纪。它不仅是现代 Vim 和 Neovim 中主要的查找替换工具，在用 sed（一个 ed 的升级版本）做 shell 脚本自动化任务时也经常用到。

和往常一样，LazyVim 对这个替换命令做了增强，主要体现在：你输入时，能够实时显示修改的预览效果。

因为这是一个 ex 命令（ex 是"extended ed"的缩写，就像后来的 vi 被重写成了"vi improved"），所以你需要先进入命令模式。你可以输入 :substitute，不过大家都简写成 :s，因为：第一，它一样管用；第二，能少打字为什么不少打呢？

接着，不要按回车，输入一个 /。这个斜杠的作用是分隔你的命令（s 或 substitute）和你要搜索的内容。

然后输入你要搜索的"pattern"。这里可以使用任何 Vim 的正则表达式，就像我们在第12章讲过的普通搜索一样。

你可以看到，当我在编辑器里输入 :s/pattern 时，光标所在行的这个"pattern"会被高亮显示：

<img src="mymedia\s-pattern-dark.png" alt="s pattern dark" style="zoom:50%;" />

接下来，再输入一个 / 用来分隔搜索字符"pattern"和要替换的内容，然后输入你想要替换成的文字。LazyVim 会实时显示所有匹配项被替换后的效果预览。这里，我准备把 pattern 替换成 FOOBAR：

<img src="mymedia\s-replace-dark.png" alt="s replace dark" style="zoom:50%;" />

最后按回车确认替换。所以查找替换就是这么简单：:s/要找的内容/替换成的内容<回车>。看起来不难，对吧？

但是等等，这还没完，远没完呢。其一是，这个命令只会替换光标所在行的第一个匹配项。

> 小技巧：虽然通常我们用 / 作为替换命令的分隔符，但如果你要替换的内容中包含很多 / （比如 Unix 的路径），你可以用其他字符（比如 +）来当分隔符，这样就不用在每个 / 前面加转义符 \ 了。举个例子，你可以用 `s+/home/dustyphillips/+/home/yourname/+` 来代替 `s/\/home\/dustyphillips\//\/home\/yourname\/`（可以学习一下 sed 的命令用法）。

## [13.1. 替换范围](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_substitute_ranges)

很多 Neovim 的 ex 命令前面都可以加上一个范围，用来指定命令要作用的行。范围的语法可能有点让人困惑。说实话，到现在我要用一些不常用的范围时，还是得查看 :help range 帮助文档。

最简单的范围是 . 字符，表示"当前行"。写法是 :.s/pattern/replacement。这里 : 和 s 之间的 . 就是范围。不过一般不用特意写，因为"当前行"就是默认范围。

第二个最常用的范围是 % 字符，表示"整个文件"。如果你习惯了其他编辑器或文字处理软件的查找替换对话框，可能会觉得它默认就该搜索"整个文件"。但在 Vim 里不是这样的，如果你想在整个文件中查找替换，需要用 :%s/pattern/replacement（后面通常还要加上 /g，这个我们下一节会讲）。

你也可以指定具体的行号，比如 :5s/pattern/replacement 会替换第5行中的 pattern。不过我一般会用 5G 把光标移到第5行，然后直接用默认范围替换。

"范围"这个词暗示着你可以选择多行，确实如此，你可以用逗号分隔起始位置和结束位置。比如 :3,8s/... 会在第3、4、5、6、7、8行执行替换（范围包含首尾两行）。下面这个例子里，我设置了一个模式，只高亮第3到第8行的 hello 这个词：

<img src="mymedia\range-3-8-dark.png" alt="range 3 8 dark" style="zoom:50%;" />

你也可以用前面的章节中提到的标记（比如 'a,'b）来定义范围的起点或终点。

最常用的方式是用 '<,'> 来表示"最近的可视模式选择范围"。不过你不用手动输入 '<,'> 字符，因为当你用 Shift-V 选择了一些文本，然后按 : 时，Neovim 会自动把这个范围填到命令行里。

这意味着如果你想在当前的可视模式中，对选择的文本执行替换，你只需要选中文本然后输入 :s/...。范围会自动插入，变成 :'<,'>s/...。

如果你想挑战一下自己的理解能力，你甚至可以用搜索模式来指定范围的一端！在下面这个例子中，我开始替换时，光标在第5行：

<img src="mymedia\pattern-range-dark.png" alt="pattern range dark" style="zoom:50%;" />

这个替换命令是 :,/hello-10/s/hello/foo。里面有很多斜杠，看起来有点像 Unix 的文件路径，不过写起来其实很简单。让我们从左到右分析一下：

- : 是从普通模式进入 ex 命令的触发键
- : 和 , 之间什么都没有，所以范围的起点是当前行（这个例子中是第5行）
- 第一个 / 是一种简洁的写法，表示"范围的终点是从当前光标位置往下第一个匹配某个模式的行"
- hello-10 是用来定义范围终点的搜索模式
- 第二个 / 标记模式的结束。所以完整的范围是 ,/hello-10/，意思是"从当前行到包含 hello-10 的那一行"
- s 表示我们要在这个范围内执行替换
- /hello/foo 就是普通的替换命令，把 "hello" 替换成 "foo"

Vim 的范围还有很多其他的用法，但说实话，很多都是为了支持过时的编辑模式才存在的。你可能会发现 %、'<,'> 和 ,/pattern/ 这三种范围就能满足 95% 的使用场景。建议你先通读一遍 :help range，了解一下还有哪些语法可用。在少数情况下，如果上面提到的这些范围不够用，再去查文档就好。

## [13.2. 标志（全局和忽略大小写替换）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_flags_global_and_ignore_case_substitutions)

你可以在任何替换命令的末尾（即最后一个 / 后面）添加"标志"来修改搜索和替换的行为。最常用的标志是 g，表示"全局"（global）。你会发现大多数时候都需要加上这个标志。

默认情况下，substitute 命令只会替换每行中第一次出现的 "pattern"。比如，如果我有一个文件，里面充满了重复的 hello hello，那么 :%s/hello/foo 只会替换每行中第一个 hello：

<img src="mymedia\non-global-substitute-dark.png" alt="non global substitute dark" style="zoom:50%;" />

但如果我加上 /g，它就会替换每行中所有的 hello：

<img src="mymedia\global-substitute-dark.png" alt="global substitute dark" style="zoom:50%;" />

前面提到过，"替换文件中的所有内容"这个最常见的用法就是 :%s/pattern/replacement/g。% 表示"每一行"，g 表示"每行中的每个匹配"。

虽然有将近十个标志可用，但其他有用的只有 i、I 和（偶尔用到的）c。前两个分别用来显式地忽略大小写或禁用忽略大小写，具体用哪个取决于你的 options.lua 中是否设置了 ignorecase（在 LazyVim 中默认是开启的）。c 标志表示确认（confirm），当你要在一个很大的文件中进行替换，且想要跳过某些替换时，c 标志就会很有用。它会显示的提示每个修改，让你一个个确认或拒绝。

标志可以组合使用，比如 :%s/hello/foo/gc 会进行全局替换，并且每次替换都需要确认。

## [13.3. 实用的替换快捷方式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_handy_substitute_shortcuts)

你不需要记住这一节的内容，但当你习惯了替换操作后，可能会发现有些操作很重复很单调，你想更快地输入它们。先看看下面的这些技巧，等你对 :substitute 更熟悉了再回来查。

如果你省略掉替换命令中的模式部分（比如 :s//replacement/），它会默认使用你最后一次搜索或替换的模式。举个例子，如果你按顺序执行这些命令：

- /foo 会搜索 foo 这个词
- :s//bar 会把 foo 替换成 bar
- :s/baz/bar 会把 baz 替换成 bar
- :s//fizz 这时会把 baz 替换成 fizz

当你搜索了一个词然后决定要替换它，或者在一个文件中做了替换，然后想在另一个文件中重复这个替换时，这个技巧可以省一点敲键的时间。

如果你只用 :s 而不加任何模式和替换内容，它会重复你最后一次做的替换（包括模式和替换内容）。但要注意，它不会使用相同的范围，所以如果你想完全重复上次的替换，还需要重新输入范围。

它也不会重复标志，但你通常可以直接在 :s 后面加上标志。对初学者来说，最常用的是 :%sg，表示"在整个文件中全局重复上次的替换"。当你输入了 :s/long-pattern/long-replacement 却发现它只替换了当前行的第一个匹配时，这个命令很有用。:%sg 会按你预期的方式重复全局替换。你也可以手动键入 '<,'>sg 来在上次的可视选择范围内替换。

> 别忘了你可以使用 gv 来重新显示上次的可视选择，这样可以确认是否符合你的预期。

如果你想在替换文本中重用"模式匹配到的内容"，可以在替换字符串中使用 `\0`。当你使用的正则表达式可能匹配到不同内容时，这个特别有用。

比如，假设我有这样一个文件：

```
hello world
Hello thrift shop
Hellish world
```

出于某种原因，我想在第一个和第二个词之间加一个形容词。可以用这个命令实现：`:%s/[hH]ell\S* /\0green /`：

<img src="mymedia\replace-with-pattern-dark.png" alt="replace with pattern dark" style="zoom:50%;" />

如果你对正则表达式不太熟悉，这个命令可能看起来有点吓人，让我们分解一下：

- `%` 表示"在整个文件上执行命令"
- `s/` 表示"要执行的命令是替换"
- `[hH]` 表示"不区分大小写地匹配 h"（见注释）
- `ell` 表示"精确匹配三个字母 ell"
- `\S` 表示"匹配任何非空白的字符"
- `*` 表示"重复 \S 匹配零次或多次"，这样就能匹配到词尾
- `  /` 包含一个空格，然后结束搜索模式
- `\0` 表示"插入上面模式匹配到的内容"
- `green` 表示"直接插入这段文本"

> 注：如果你的 options.lua 中没有设置 vim.opt.ignorecase=false，[hH] 就不是必需的。另一种方法是在模式末尾加上 /i 来强制这一次搜索忽略大小写。这样 [hH] 就可以简化成 h。

你甚至可以在替换文本中重用模式的一部分。要做到这一点，把你想重用的部分放在 `\(` 和 `\)` 之间。然后在替换部分用 `\1` 表示括号中匹配到的内容。

用例子来理解更容易。如果我们还是用上面的三行示例，可以用这个替换命令 `:%s/hell\(\S*\)/green\1 and blue\1/i` 来进行下面这个看起来没什么意义的替换：

<img src="mymedia\reuse-partial-dark.png" alt="reuse partial dark" style="zoom:50%;" />

`\(\S*\)` 匹配的内容和 `\S*` 一样，但它会把结果存在一个捕获组中。然后当我们想在替换文本中重用这个捕获组时，用 `\1` 即可引用这次匹配捕获的内容。

> 从我们用数字来引用这一点，你可能猜到了可以有多个捕获组并引用它们，你猜对了！

## [13.4. 项目范围的搜索和替换](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_project_wide_search_and_replace)

LazyVim 自带了一个叫 Grug-far.nvim 的插件，用于在项目的所有文件中进行全局查找和替换。如果没有 grug-far，你可能会（不太情愿地）用 sed 在命令行中完成这个任务，sed 就是我之前提到过的 ed 的流式演进版本。

> 在运行 Grug-far 之前最好先把文件提交到版本控制系统。它的修改难以批量撤销，只能逐个文件处理。所以请先提交当前的修改，这样之后使用 git reset --hard 时，就只会撤销 Grug-far 的修改，而不会影响其他工作。

Grug-far 是一个轻量级的 UI，封装了我之前提到过的命令行工具 ripgrep。这个 UI 非常方便，因为 ripgrep 有一些比较晦涩的参数。

要显示 Grug-far 的 UI，使用快捷键 <Space>sr，这里的助记符 r 代表 replace。右侧会打开一个窗口：

<img src="mymedia\grug-far-empty-dark.png" alt="grug far empty dark" style="zoom:50%;" />

你可以用所有常规的 Vim 移动命令在这个窗口中导航，但是大多数的时候，你只需要使用 j 和 k 在各个字段之间跳转。

Search 字段下，可以接受任何正则表达式。因为底层使用的是 ripgrep，所以这里的正则表达式语法相对没那么晦涩。Files Filter（文件过滤器）字段用于将搜索限制在特定路径或文件扩展名，它接受标准的 shell glob 语法。

当你填写各项字段时，Grug-far 会在一个实时更新的窗口中即时预览你的修改：

<img src="mymedia\grug-far-preview-dark.png" alt="grug far preview dark" style="zoom:50%;" />

在输入"搜索"和"替换"文本后，你需要按 Escape 返回到普通模式。如果预览区域中的所有结果看起来都没问题，只需按 \r 执行替换。

> （ethan）不确定是我的配置冲突了，还是这个插件本身的 bug，我在 Grug-far 界面中回到 normal 模式，然后键入 \r，并不会生效，反而会应用 r 命令（即忽略 \ 字符，然后应用 r 命令准备替换光标下的字符。。。），在我的 LazyVim 中，我需要先使用 <Space> 呼出 <leader> 菜单，然后取消再按 \r 才行。

如果有些搜索结果不符合你的需求，你也可以调整它们。用任何标准的移动命令在预览窗口中导航。如果有些匹配项你不想改变，直接用 dd 删除它们就可以。另外，你也可以直接在预览窗口中编辑任何行，让它变成你想要的样子。

当你对修改后的预览结果满意时，需要使用 \s 而不是 \r 来将你的修改同步到原始源文件。

你还可以把光标放在预览结果上按 Enter 跳转到源文件。

Grug-far 会记录你最近的搜索和替换操作，你可以在 Grug-far 界面中使用 \t 快捷键重新查看它们。用标准的移动命令在它们之间导航，按 Enter 重用其中一个。

还有一些其他有用的快捷键在菜单中，你可以在 Grug-far 界面中用 g? 调出这个菜单，我就不详细说了，你可以在闲暇时自己看看。

## [13.5. 在多行上执行 Vim 命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_perform_vim_commands_on_multiple_lines)

不只有 :substitute 命令可以通过"范围"在多行上同时操作。实际上，如果你想要把几行内容写入到一个单独的文件中，你可以给 :write 传递一个范围。最简单的方法是在可视模式下选择范围，然后输入 :write <文件名>。Neovim 会自动把它转换成 :'<,'>write，并且只保存那些行。

> Neovim（目前）还没有一流的多光标支持。从历史上看，Vim 用户认为多光标模式是那些不如 Vim 模式强大的编辑器才需要的拐杖。但最近，像 Kakoune 和 Helix 这样的实验性编辑器已经证明多光标可以很好地与模态编辑集成。现代开发者喜欢多重选择，预计 Neovim 将在未来版本中提供原生的多光标支持（目前在路线图中列为 0.12+ 版本）。
>
> 目前虽然有多光标插件，但我觉得它们用起来笨拙且不稳定，建议暂时避免使用。相反，你可以使用下面讨论的命令，或者依赖其他 Vim 工具，比如重复录制（使用 q、Q 和 @@），或者使用可视块模式（Control-v）配合插入或追加来修改多行。

### [13.5.1. Norm 命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_the_norm_command)

当你第一次使用 :norm 时可能会觉得很奇怪。它允许你在多行上执行任意的 Vim 普通模式命令（包括像 hjkl 和 web 这样的导航命令，以及像 d、c 和 y 这样的修改命令）。

你甚至可以从 :norm 进入插入模式！但你需要知道一个小秘密才能退出插入模式，因为当命令菜单可见时按 <Escape> 只会关闭命令菜单。相反，你要使用 Control-v<Escape>。在插入模式或命令模式下，Control-v 快捷键的意思是"按字面意思插入下一个按键，而不是将其解释为命令"。

> 即：通常情况下，按 Escape 键会执行"退出"这个命令，但如果你先按 Control-v，再按 Escape，Vim 就会把 Escape 当作一个普通字符来插入，而不是执行退出命令。
>
> 终端通常会将 Control-v<Escape> 显示为 ^[。

举个例子，假设我们正在编辑以下文件：

```txt
foo
Bar
fizz buzz
one two three
```

出于莫名其妙的（教学目的）原因，我们想对每一行执行以下操作：

1. 在行首插入单词 "HELLO" 并在其后加一个空格
2. 将行中第一个单词的首字母大写
3. 在每行的第一个单词后插入 "BEAUTIFUL"，前后都有空格
4. 在每行末尾加上单词 "WORLD"，前面有一个空格

首先输入 `:%norm ` 来打开一个命令行，它的范围是文件中的每一行（还记得前面章节中提到过的 % 吗）。注意输入的命令是 % + norm + <space> 空格符。

然后添加 IHELLO 来在范围内每行的开头插入文本 HELLO。接着按 Control-v 然后按 Escape，来在命令行中插入 Escape 的转义字符。

接着输入 lgUl 来将光标向右移动（这会把它放在第一个单词的开头），然后将右边的一个字符大写（即下一个单词的第一个字符）。

接下来是 e 跳到单词末尾，然后输入 a BEAUTIFUL，即在那个单词后追加一些文本。再次按 Control-v 和 Escape 插入转义字符。

最后，添加 A WORLD 来在行尾进入插入模式并添加文本 WORLD。

因此完整的命令是：

```txt
:%norm IHELLO <Control-v Escape>lgUlea BEAUTIFUL<ctrl-v Escape>A WORLD
```

视觉上看起来是这样的，因为 Control-v Escape 按键会变成 ^[ 符号：

<img src="mymedia\crazy-normal-mode-command-dark.png" alt="crazy normal mode command dark" style="zoom:50%;" />

最终的结果：

```
HELLO Foo BEAUTIFUL WORLD
HELLO Bar BEAUTIFUL WORLD
HELLO Fizz BEAUTIFUL buzz WORLD
HELLO One BEAUTIFUL two three WORLD
```

当然，实际上你应该不会真的有这个场景，但希望这个例子向你展示了什么都是可能的！

第一次尝试此命令时，应该会经常出错。只需使用 u 一次性撤销整个序列，然后输入 :<Up>（即上箭头号） 再次编辑命令行。

如果命令比较复杂，你可能会在编辑时感到烦恼，因为你无法使用你习惯的 Vim 导航命令...所以现在是介绍 Vim 的命令行编辑器的好时机。

## [13.6. 命令行编辑器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_command_line_editor)

要显示命令行编辑器，可以在小的命令行窗口获得焦点时按 Control-f。或者，如果你当前在普通模式下，可以输入 q: 字符。后者与 q 字符相关的"录制到寄存器"命令无关。它实际上是"打开可编辑的命令行窗口"。

这个窗口基本上就是"普通命令行编辑器"与"普通 Vim 窗口"结合后产生的一个具有超能力的命令行窗口。

这个神奇的新窗口会出现在当前缓冲区的底部，状态栏的上方，它包含了你的整个命令行历史记录（包括搜索和替换）：

<img src="mymedia\command-line-window-dark.png" alt="command line window dark" style="zoom:50%;" />

使用 Control-u 向上滚动，你会看到你曾经输入过的每个命令。你甚至可以用 ? 来搜索它（向后搜索可能比向前搜索更有用，因为命令是按最近的使用时间排序的）。

要运行这些旧命令中的任何一个，只需将光标移动到那一行并按 Enter。砰！历史重演。

你还可以跳转到命令窗口底部（使用 Shift-G），在那里的空行上输入新命令。

这个窗口的退出方式比较特别。按 Escape 键没用，因为它在这里的作用是从编辑状态返回普通模式。要关闭窗口，你可以使用如下的方式之一：

- 按 Control-C
- 用常规的关闭命令，比如 <Space>wq
- 直接在窗口中输入 :q

更方便的是，你可以用 Vim 的常规编辑命令来修改窗口中的任何一行。具体步骤是：

1. 移动到要改的那一行
2. 用任何你熟悉的编辑方式修改它（包括 :s 替换命令等）
3. 回到普通模式
4. 按回车执行修改后的命令

## [13.7. 将 Norm 命令与录制结合使用](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_mixing_the_norm_command_with_recording)

回想一下：

- q 命令可以将一系列命令录制到寄存器中以供稍后回放。
- 而 :norm 命令可以作用到一系列的行上，来应用命令序列。
- 由于你可以用 p 来粘贴"带录制内容的寄存器"。

所以有几种方法可以将录制应用到一系列行上：

1. :<range>norm @q 将简单地在范围内的每一行上执行 q 寄存器，因为 @q 是执行寄存器 q 的命令。
2. :<range>norm <Control-r>q 会将 q 寄存器里的动作应用到每一行（因为 <Control-r>q 会把 q 寄存器里的动作复制到命令行中）。
3. q:inorm <Esc>"qp 会打开命令行编辑器窗口，插入单词 norm，然后进入到普通模式，再使用寄存器粘贴命令粘贴寄存器 q 的内容。

## [13.8. Global 命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_the_global_command)

:norm 命令必须要在连续的行内操作，因为 Neovim 中的范围必须是连续的行。比如，你不可能同时在第 1 到 4 行和第 8 到 10 行执行命令而跳过第 5 到 7 行（除非对不同范围运行两次 :norm）。

有时，你想在每个匹配某个 "patten（模式）" 的行上运行命令。这就是 :global 命令的用途。

:global 的语法是 :<range>global/pattern/command，也可以简写为 :<range>g/pattern/command。

> 这里的 **pattern** 和 Vim 中的搜索或替换模式一样，使用正则表达式语法。例如：
>
> - /foo/ 匹配包含 "foo" 的行
> - /^#/ 匹配以 # 开头的行

> 其实这里的 command 是有说法的，从技术上讲，它是一个 "ex" 命令。

最常见的例子是"删除所有匹配模式的行"，可以用 :%g/pattern/d 来实现。

:global 另一个比较常用的是：替换命令。只需在替换命令前加上 :%g/pattern，就可以让它只在匹配某个模式的行上执行替换。考虑以下示例：

```
:%g/^f/s/ba[rt]/glib
```

这看起来有点混乱！显然是为了易写而不是易读。如果我们想让它更容易读懂，可能会写成：

```
:%global/^f/substitue/ba[rt]/glib
```

这个命令的意思是：对每个以 f 开头的行执行全局操作。在这种情况下，"操作"是将每个 bar 或 bat 替换为单词 glib。"

> 可以回顾一下前面介绍的 norm 命令：
>
> - :,/foo/s/needle/haystack/，这个命令会对：从光标到第一个包含 foo 的行，执行替换操作
> - :%global/foo/s/needle/haystack/，这个命令会对：文件中每个包含单词 foo 的行，执行替换操作。

在我看来，:global 最有趣的用法是在匹配"模式"的行上运行 norm 命令。即 :global 与 :normal 混合使用，比如 :%g/pattern/norm <some keystrokes>。

举个例子，这将在每个以 "hello" 开头的行末尾插入单词 "world"：

```
:%g/^hello/norm A world
```

你也可以使用 global 在每个"不匹配模式"的行上执行命令。只需使用 g!/ 而不是 g/。

> g! 在处理日志文件时很有用，特别是当这些日志文件中的**异常信息**会随机换行显示的情况下：
>
> ```txt
> 2024-03-26T12:00:00 Something happened
> 2024-03-26T12:01:01 Something happened
> 2024-03-26T12:01:02 Something super bad happened
>   Traceback:
>     A bunch of lines I don't care about
> 2024-03-26T12:02:00 Something else happened
> 2024-03-26T12:03:58 Cool thing happened
> ```
>
> 在进一步处理之前，我可能想要删除每一行不以日期开头的行：
>
> <img src="mymedia\global-non-match-dark.png" alt="global non match dark" style="zoom:50%;" />
>
> 这可能有点晕眼。每个 \d 表示"匹配一个数字"，而最后的 /d 表示"对选定的行执行删除操作"。g! 是重要的部分；它表示"选定的行是那些**不匹配模式**的行"。

上文中用到的 :global 知识点：

两种匹配模式：

1. 对匹配模式的行执行命令：g/
2. 对不匹配模式的行执行命令：g!/

三种常见用法：

1. 删除命令（删除所有匹配"模式"的行）:%g/pattern/d
2. 替换命令（在匹配模式的行上执行替换操作）:%g/pattern/s/old/new
3. 普通模式命令（在匹配模式的行上执行普通 norm 命令）:%g/pattern/norm <commands>

虽然我不经常使用 :global 命令（比起 :norm 来说），但它的确是一个非常强大的工具，尤其是在需要对文件进行大规模修改时。

刚开始使用时，你可能需要经常查看它的语法规则。不过不要担心，只要多加练习就能熟悉。这绝对是一个值得掌握的强大工具。

## [13.9. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-13/#_summary_13)

本章主要讲解了批量编辑文本的方法。我们首先学习了使用 :s[ubstitute] ex 命令进行替换，然后介绍了如何使用 Grug-far 插件在多个文件中进行查找和替换的操作。

接着，我们学习了如何使用 :norm 和 :global 命令在多行上同时执行命令。并简要但全面地介绍了命令行编辑窗口。

在下一章中，我们将学习一些无法归类到其他章节的随机编辑技巧。

# [第14章：其他实用编辑技巧](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_miscellaneous_editing_tips)

在我们深入了解 LazyVim 提供的那些"类-IDE"功能之前，我想先分享一些能让你的编辑体验更加有趣的小技巧。这一章会包含一些零散的内容，主要是一些我没法归类到其他章节的命令和插件。

## [14.1. 字数统计](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_word_counts)

按下 g<Control-g> 可以显示一条当前光标位置相关的信息：

<img src="mymedia\word-count-dark.png" alt="word count dark" style="zoom:50%;" />

其中最值得注意的是"Word 110 of 3179"，这告诉我这一章总共有超过3000个单词。

## [14.2. 字符位置交换](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_transposed_characters)

你是不是经常打字太快，不小心把两个字符的顺序打反了？

只需要用 xp 就能把一个字符和它右边的字符交换位置。比如，你不小心打成了 ra，但其实想打的是 ar，只要把光标放在 r 上按 xp 就行了。

这不是什么特殊的自定义命令，它只是结合了"删除字符（x）"和"在光标后粘贴最后删除的内容（p）"这两个基本命令，把字符从当前位置移到了下一个位置。你也可以用类似的方法移动其他文本。比如，用 dwwP 移动一个单词，或者用 daaWp 删除一个函数参数并把它移到参数列表的后面。

## [14.3. 代码注释与取消注释](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_commenting_and_uncommenting_code)

LazyVim 附带了一个用于在旧版 Neovim 中注释和取消注释代码的插件，但从 Neovim 0.10 开始，这实际上是 Neovim 的一个原生功能。

切换注释的操作命令是 gc，后面可以跟动作命令或文本对象。比如 gc5j 会注释当前行和下面5行，而 gcap 会注释由空行分隔的整个段落。

这个命令和 S 命令配合起来特别好用，可以注释"包围对"文本对象。例如，在输入 gcSh 后，会注释被 h 标签包围的文本对象。

若要注释单行，可以用简单的快捷键 gcc。这个命令可以加数字前缀，比如 5gcc 会注释5行（比 gc4j 好输入一点）。

和大多数操作命令一样，gc 也可以作用于可视模式选择的内容，比如用 V5j 选择了当前行和下面5行后，再按 gc 即可。

gc 实际上是个开关（切换）命令，如果一行已经被注释了，它会取消注释而不是加上第二个注释。所以，连续按两次 gcc 相当于什么都没做。不过要注意，如果你选中的内容既有注释行又有非注释行，可能会导致重复注释。这通常是符合预期的：如果你临时注释了一块包含其他注释的代码，当你取消这块代码的注释时，原来的注释应该保持注释状态。

作为快捷方式，如果你想在当前行的上方或下方添加新的注释行，而不是注释当前行，可以用 gcO 和 gco。严格来说这是个新的操作命令，但为了好记，你可以理解为把 gc 和打开新行的命令（o 和 O）组合在一起。

## [14.4. 数字的增减操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_incrementing_and_decrementing_numbers)

在普通模式下，当光标位于数字上时，可以用 Control-a 来增加这个数字。这个命令很智能，会自动处理进位的问题。比如，按 Control-a 时，9 会变成 10，99 会变成 100，不管光标在数字的哪个位置都可以。

要减少数字，用 Control-x。

我曾经很讨厌这两个快捷键，因为它们用得不多，但在需要用的时候又总是记不住。所以我经常手动修改数字，一边想着"我得去查一下那个数字增减的快捷键"，但帮助文档里，只能依据快捷键来检索其作用！

后来我学会了 :helpgrep 命令，它可以搜索帮助文档。在我记住快捷键之前，我至少记住了可以用 :helpgrep Adding and subtracting 来查找它们~

其实这些快捷键是有记忆规律的：Control-a 就是"Add（添加）"，这个很好记。Control-x 稍微难记一点，但只要你记住了 Control-a，就可以用 :help CTRL-a 找到与它相关的 Control-x。虽然不知道对别人有没有帮助，但我是把 x 理解成"cross（划掉）一个数字来减少"。

用 g<Control-a> 和 g<Control-x> 可以对连续的多行数字进行递增或递减。这在处理编号列表时特别有用。比如你想做一个有 10 项的列表，先输入 `o1.<esc>` 创建一行"1."，然后输入 `9.` （`.` 是重复命令）重复这个命令9次。然后你会得到：

```
1.
1.
1.
1.
1.
1.
1.
1.
1.
1.
```

目前你的光标是在最下面的 1. 上，然后可以使用 V'[ 选中刚插入的9行，因为 '[ 标记指向最近修改文本的第一个字符。然后输入 g<Control-a> 递增这些数字：

```
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
```

用几个看起来奇怪的按键:`oi1.<Esc>9.V'[g<Control-a>`，就完成了如上的动作。

> （ethan）但是我实际试下来，有几个问题（可能是 bug？）：
>
> 1. `o1.<esc>` + `9.` 有时不会按我的预期去复制，比如会多带一个空格或者回车行。
> 2. `V'[` 没有按我的预期去选中，实际上它往上选中了更多的行。
> 3. `g<Control-a>` 也没有从 1. 开始递增，而是去掉了 1. 从 2. 开始递增。

如果需要在列表中间插入新条目，添加条目后，选中后面的条目，按 Control-a 就能重新排序。

Neovim 会智能地只增加每行遇到的第一个数字。这意味着即使一行中有多个数字，也能轻松处理，比如修改书籍大纲。看看这个假设的大纲：

```
Chapter 1: Intro and Install
Chapter 2: 1 Weird modal editing trick
Chapter 3: The numbered marks 1-9
Chapter 4: Navigating things
...
```

假设我想把第1章分成两章："Intro"和"Install"。我可以直接插入新章节：

```
Chapter 1: Intro
Chapter 2: Install
Chapter 2: 1 Weird modal editing trick
Chapter 3: The numbered marks 1-9
Chapter 4: Navigating things
...
```

然后用 <Shift-V>} 选中原来编号为 2 及其后面的章节。按 Control-a 时，只有章节号会递增，而"1 Weird trick"中的 1 和 "marks 1-9"中的 1-9 不会受到影响：

```
Chapter 1: Intro
Chapter 2: Install
Chapter 3: 1 Weird modal editing trick
Chapter 4: The numbered marks 1-9
Chapter 5: Navigating things
...
```

### [14.4.1. Dial.nvim 扩展](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_the_dial_nvim_extra)

如果你觉得这些增减快捷键就像厨房里那种一个月才用一次的单一功能工具，不妨考虑从 :LazyExtras 安装 editor.dial 扩展。

安装了 dial.nvim 插件后，能让你增减更多有趣的内容。我主要用它来切换布尔值（Control-a 和 Control-x 都能在 true 和 false 之间切换），它还能递增单词（"first"递增到"second"）、月份（"December"递增到"January"）、版本号、Markdown 标题等。如果需要，你还能添加自己的模式（请自行参阅这个插件的 readme）。

## [14.5. 修改缩进](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_changing_indentation)

在普通模式下，可以用 > 和 < 来增加或减少缩进。最常用的是双击这些键（<< 和 >>）来改变当前行的缩进。不过，你也可以配合动作命令来使用，比如：>Sx（缩进由 x 标签标识的语法树实体）和 >ap（缩进整个由空行分隔的段落）。> 和 < 也可以和可视化模式配合使用。

不过这些动作命令在使用计数时，可能会有点让人有点困惑。你可能以为 2>> 会把当前行缩进两个层级，但实际上它会把两行各缩进一个层级。

如果你想一次性改变多个缩进层级，需要使用 v。比如：要把当前行缩进五个层级，最快的方法是用 v5>，这比输入十个 > 要方便得多。这对任何可视选择都有效，比如可以用 va{5> 把整个代码块缩进五个层级。

通常，你想要的只是"让代码按照这个编程语言的规范正确缩进"。如果配置好了 conform.nvim，最简单的方法就是：直接保存文件。LazyVim 默认开启了"保存时格式化"，如果能找到格式化工具就会使用它。你也可以用 gq 配合动作命令（最常用的是 gqag 来格式化整个文件）或用可视模式配合 gq 来应用格式化。

不过，如果你不想保存文件，或者没有使用 conform.nvim，也可以用 = 命令。= 的行为会根据编程语言略有不同，但通常会对可视选择（或动作选择）的行应用缩进引擎。这些行都会按照某种"正确"的标准进行缩进。

在插入模式下也可以调整缩进。Control-t 和 Control-d 快捷键会在插入文本时增加和减少当前行的缩进。记忆方法是"add tab（添加制表符）"和"dedent（减少缩进）"。

## [14.6. 重排文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_reflowing_text)

在写这本书的时候，我经常用到 gw 命令。它会在（默认）每行的八十个字符处（可以用 :set textwidth=<number> 配置）智能的重新换行（w 表示 wrap），且不会打断单词。比如：

<img src="mymedia\no_reflow-txt.png" alt="image-20241228152346912" style="zoom:50%;" />

选中这段文本，使用 gw 命令后：

<img src="mymedia\reflow-txt.png" alt="image-20241228152550226" style="zoom:50%;" />

使用 gww 命令可以重排当前行，让它在适当的位置换行，或者用 gwip 来重排整个段落。推广来说，gw 可以配合任何动作命令或可视选择。要重排整个文件，可以使用 gwig。

这个命令严重依赖换行符的存在。结合如下的例子：

<img src="mymedia\reflow-txt-newline.png" alt="image-20241228154432478" style="zoom:50%;" />

> （ethan）对于中文句子，gw 命令的数量计算是符合预期的。不过对于"单词"的定义，中文和英文不同，所以执行 gw 命令时，可能不会符合预期。

## [14.7. 通过外部程序过滤](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_filtering_through_external_programs)

你还可以把文本通过管道传给任何遵循 Unix 规范的外部程序：即从 STDIN 读取输入并输出到 STDOUT 的程序。要这样做，先在可视模式下选择要处理的文本，然后输入 ! 符号。这会打开命令窗口，并用"可视选择"作为范围，此时命令窗口会出现 '<,'>! 字符。然后再输入一个环境变量中存在的命令，选中的文本就会被该命令的输出替换。

这里有一些例子，假设你安装了一些常见的 Unix 工具：

- !grep -v a：会用同样的文本替换选择的文本，但会删除包含字母"a"的行。
- !tr -s ' '：会调用 tr 命令，把多个连续的空格替换成单个空格。
- !jq：会用 jq 格式化 json 文本。
- !pandoc -f markdown -t html：是个快速把简单的 Markdown 转换成 HTML 的好方法。
- !./my-custom-script：会将选中的文本传递给你编写的自定义脚本。
- !python ./something.py：会通过你写的 Python 脚本处理选中的文本。

> 如果你只想运行 shell 命令，但不想修改文本，不提供范围就行。比如 :**!**mkdir foo 会运行 mkdir 命令但不会影响到你的文本内容。

我觉得这个功能用得太少了实在可惜。很多内置在 Neovim 中或通过插件提供的功能，完全可以通过管道输入输出的命令行程序来实现。举个例子，我觉得 Neovim 自带的 :sort 命令让编辑器更加臃肿了，其实用 !sort 运行外部排序工具一样能完成工作。

## [14.8. 拼写检查](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_spell_check)

你可以用 <Space>us 开启或关闭拼写检查。开启后，拼写检查器检查到的错误，会用类似诊断的波浪线标记出来。若你想在拼写错误之间跳转，需要用 [s 和 ]s 而不是（诊断快捷键）[d 和 ]d 。

要让 Vim 给出拼写建议，使用 z= 命令。这个快捷键很难记住。。。如果你能记住它在 z 菜单而不是 Space 菜单里，至少还能在菜单中再次找到它。拼写建议会以编号菜单的形式弹出，输入拼写建议的编号前缀，即可应用它：

<img src="mymedia\spell-suggest.png" alt="image-20241228180558170" style="zoom:50%;" />

## [14.9. 插入模式下的快捷键](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_insert_mode_keybindings)

如果你在插入模式下想执行一个普通模式的动作，执行完后立即再次返回插入模式，可以用 Control-o 命令。执行一个普通模式的命令后，你会立即回到插入模式。我觉得这个功能意义不大，因为 Control-o + <命令> 需要按两次键，而 <Escape> + <命令>i 也差不多。

在插入模式下，按 Control-a 会插入你在上一次插入模式中输入的文本。这类似于访问 ". 寄存器。

要在插入模式下访问其他寄存器，可以使用 Control-r。这会弹出寄存器菜单，你可以按相应的键来插入相应寄存器中的内容。所以插入模式下的 Control-a 类似于 Control-r + . 命令。若要将系统默认剪贴板的内容插入，用 Control-r 然后按 +。

Control-u 快捷键会删除：自进入插入模式以来,**"当前行"**中添加的所有字符。所以在单行编辑中，它类似于撤销操作，但如果你的插入包含了 <Enter>，那么"撤销"只会作用于当前行。

有些人喜欢在插入模式下，将一些不常用的字符序列绑定成命令。最常见到的建议，是把 jk 绑定到 Escape，或者把 ;; 绑定到 Control-o，你可以使用任何你喜欢的组合。前者让你不用按 Escape 或 Control 就能切换到普通模式，后者让你可以临时执行一个普通模式的操作，并返回插入模式。就按键次数而言它们并不会节省多少，但就方便而言，这些键更容易按！

如果你想尝试这个，打开你的 keymaps.lua 文件并添加以下行：

```lua
vim.keymap.set("i", "jk", "<Esc>", { desc = "Normal mode" })
vim.keymap.set("i", ";;", "<C-o>", { desc = "Normal mode single operation" })
```

这里要注意的是第一个参数 "i"。这告诉 Neovim 此键位映射应该在插入模式而不是在普通模式（"n"）下生效。你也可以用 "o" 来表示操作符待决模式，用 "v" 表示可视选择模式，等等。

> 在普通文本和代码编辑中，除了 <Space> 或 <Enter>，"**;**" 后面很少跟其他的字符。所以，用它来当作插入模式下的快捷键前缀是一个不错的选择。 

不过，不要用这种技术来实现代码补全，如下为不建议的示例：

```lua
vim.keymap.set("i", "for;", "for (int i = 0; i < n; i++) {}", { desc = "for loop" })
```

对于这个需求，最好使用abbreviations（缩略语）或代码片段，这是接下来两节的主题。

## [14.10. 缩略语（和文件类型配置）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_abbreviations_and_filetype_configuration)

Vim 的"缩略语"功能在很早的时期就存在了。它是一种简单的方法，可以让你在不离开插入模式的情况下，用"快捷词"展开成完全不同的内容。

要创建一个临时的缩略语，只需使用命令 :iabbr <快捷词> <展开内容>。你可以将 Vim 的"键位绑定语法"，应用在 <展开内容> 中，来表示特殊的字符（或动作），如 <Enter> 和 <Tab>，你甚至可以用 <Left> 这样的命令来重新定位光标位置。比如，考虑这个命令：

```lua
:iabbr ifmain if __name__ == "__main__":<Enter>main()<Left>
```

它会在插入模式下，把文本 ifmain<Space> 展开成以下内容，并把光标放在 main 后的括号内：

```python
if __name__ == "__main__":
    main( )
```

iabbr 中的 i 表示它会在插入模式下工作，abbr 是 abbreviate（缩略语）的简写。

注意：我不需要在 <Enter> 后显式的添加缩进。因为 Python 的缩进引擎会自动的处理。还要注意：我在 ifmain 后输入的 <Space> 被插入到了括号之间。因为展开的过程为：

1. 输入 ifmain<Space>
2. 展开成 if __name__ == "__main__":<Enter>main()
3. 执行 <Left> 移动到括号内
4. 触发展开动作的空格，被插入到光标位置（也就是 <Left> 移动到的位置：main() 的括号内）

如果你需要展开缩写但不想添加空格，可以使用 Control-] 快捷键来触发展开。

如果你需要插入 ifmain 这些词而不想展开它们，输入 ifmain + <Escape> 返回到普通模式即可。

这个缩略语只会存在到我关闭编辑器为止。要让它永久生效，需要把它添加到 LazyVim 配置中。通常，缩写只在单个文件类型的上下文中有意义，所以我在 autocmds.lua 中用这样的语法收集它们：

```lua
vim.api.nvim_create_autocmd("FileType", {
  pattern = { "python" },
  callback = function()
    vim.cmd('iabbr ifmain if __name__ == "__main__":<Enter>main()<Left>')
    vim.cmd("iabbr frang for i in range():<Enter><Esc>F(a")
    -- 其他的 Python 缩略语
  end,
})
```

frang 缩写展示了另一个巧妙的技巧：你可以用字符串 <Esc> 来进入普通模式并移动光标。我用 F( 命令来找到前面的左括号，然后用 a 在 range() 的括号内进入插入模式。

Vim 的缩略语功能已经存在很久了，而且工作得很好。我仍在使用它们（可能因为我比较老派），但现在流行的做法已经转向使用代码片段（Snippets）了。

## [14.11. Snippets（代码片段）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_snippets)

LazyVim 自带 blink.cmp 插件，它提供了高速补全界面。除了补全功能外，它还连接到 Neovim 0.10 的内置"代码片段"功能。可以加载出 [VS Code](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_create-your-own-snippets) 风格的代码片段界面。

默认情况下，blink.nvim 会在你输入时弹出一个简单的菜单，显示出一系列的补全选项。比如，我在 Python 文件中输入 if，会看到这样的界面：

<img src="mymedia\blink-cmp-dark.png" alt="blink cmp dark" style="zoom:50%;" />

列表会显示出可能的补全选项。我可以用方向键在列表中上下移动光标（这里不能用 j 和 k，因为我仍在插入模式）。大多数的补全选项都会弹出一个预览框，显示出文档或补全的示例。

这个代码片段是由 FriendlySnippets 插件创建的。这是一个随 LazyVim 一起提供的"庞大的实用代码片段集合"。

我可以按下 Control-y 键来确认补全（或者使用 Enter 键），代码片段就会插入到编辑器中：

<img src="mymedia\snippet-inserted-dark.png" alt="snippet inserted dark" style="zoom:50%;" />

要注意的是：编辑器现在处于"选择模式"。这是一个不常见的模式，它表面上类似于可视模式。据我所知，在 LazyVim 的默认配置中，除了代码片段场景外，没有其他方法可以进入选择模式！所以我们不会在代码片段上下文之外详细讨论这个模式。

这个模式的关键点是："condition"当前被高亮显示，我可以立即开始输入来覆盖它，几乎就像在插入模式一样。一旦"condition"被新的输入覆盖，我可以按 <Tab> 键，在选择模式下，这意味着"跳转到代码片段中的下一个字段"，即 pass 字段！

<Tab> 键只有在 snippets 知道它"在一个有字段的代码片段"中时才会这样工作。

### [14.11.1. 自定义代码片段](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_defining_new_snippets)

如果 FriendlySnippets 的代码片段不能满足你的需求，你可以使用现在无处不在的 VS Code 代码片段语法自定义代码片段，并在 snippets 中加载它们。这里有一个快速示例，展示如何为 Svelte 组件创建一个样板代码片段：

1. 创建 ~/.config/nvim/snippets/ 目录来存放你的代码片段。这是 blink.cmp 默认查找代码片段的位置。

2. 创建 ~/.config/nvim/snippets/package.json 文件。它起到了一个"目录表"的作用，记录着每个语言和其对应的代码片段文件。在这个例子中，我们将添加 svelte 的代码片段：

   ```json
   {
     "name": "personal-snippets",
     "contributes": {
       "snippets": [
         { "language": "svelte", "path": "./svelte.json" }
       ]
     }
   }
   ```

   若不确定某个语言的类型是什么，可以打开该文件，并在命令模式中输入 set ft，即可显示这个语言的类型，比如：

<img src="mymedia\language-type.png" alt="image-20241228201210447" style="zoom:50%;" />

3. 创建"path"中的文件，即 svelte.json。给它以下内容：

   ```json
   {
     "Boilerplate Component": {
       "prefix": "scri",
       "description": "Basic svelte boilerplate",
       "body": [
         "script lang=\"ts\">",
         "  $1",
         "</script>",
         "",
         "${2:<div></div>}",
         "",
         "<style>",
         "  $3",
         "</style>"
       ]
     }
   }
   ```

如果你不熟悉 VS Code 的代码片段语法，如下为示例的解释：

- prefix 是你在插入模式下，用来触发代码片段的字符串。在这个例子中是 scri。
- description 是在预览窗格中描述它的字符串。
- body 是定义代码片段实际内容的地方。它是一个字符串数组，每个数组元素代表一行代码。当触发代码片段时，这些行会按顺序插入到编辑器中。
- $1、${2:<div></div>}、$3 代表代码片段中的"跳转点"。
- ${2:<div></div>} 表示一个带有默认内容的跳转点，内容可以被覆盖，或者按 <Tab> 跳过它（即使用默认内容：<div></div>）。

## [14.12. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-14/#_summary_14)

本章介绍了各种编辑技巧，从字数统计和字符转置开始，然后讨论了注释管理、缩进和格式化。

最后，我们介绍了古老但依然实用的缩略语功能，以及 LazyVim 自带的新式代码片段引擎。

在下一章中，我们将讨论一个完全不同的主题：LazyVim 中的版本控制。

# [第15章：源码控制](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_source_control)

LazyVim 内置了多种源码控制的功能，同时你还可以使用一些优秀的第三方插件。这些插件中，有些支持多种版本控制软件（比如 svn 等），有些则专注于 git。在这本书中，我们假设你使用的是 git。

## [15.1. 内置终端（加一点吐槽）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_the_integrated_terminal_a_rant)

说实话，我真的无法理解为什么 Neovim 要内置一个终端模拟器。想想看，一个运行在终端中的编辑器居然还自带终端，这不是很奇怪吗？这样的设计甚至可以让你：打开一个终端，然后打开 Neovim，再在 Neovim 中打开终端，最后在这个终端中再次打开 Neovim。

如果你想把事情搞得更复杂，你还可以在这些终端中嵌套使用 ssh 连接。

说实话，我并不需要编辑器里的终端。我已经有了一个很棒的终端了。当我需要新的终端窗口时，我只需要使用 Kitty 的分屏、标签页和窗口功能就够了。通过 smart-splits 插件，我可以在编辑器和终端之间无缝切换，而且 Kitty 甚至可以在 ssh 连接时自动安装自己。

其实还有一个比较传统的访问终端的方式，那就是按 Control-z。可惜这个快捷键现在不那么流行了。按 Control-z 会"挂起" Neovim。如果你不了解这个功能，可能会以为编辑器在没有保存的情况下关闭了，因为窗口消失了，你回到了终端界面。

别担心！编辑器只是被挂起了，你可以在输出中看到 'nvim' has stopped 这样的提示：

<img src="mymedia\suspended-neovim-dark.png" alt="suspended neovim dark" style="zoom:50%;" />

如这个截图所示，你可以在任何 shell 中使用 jobs 命令查看已停止（或正在运行）的后台任务列表。使用 fg（foreground 的缩写）命令可以重新启动被挂起的 Neovim 进程。如果你有多个挂起的任务，可以使用 fg %# 命令来选择特定的任务 ID（例如，fg %1 会运行 Job ID 为 1 的任务）运行至前台。

这个功能并不是 Neovim 独有的。Control-z 这个技巧适用于（几乎）所有长时间运行的 shell 命令。你甚至可以使用 bg 命令（而不是 fg）让挂起的任务在后台继续运行（不过如果后台的任务输出内容到 stdout，可能会让你感到困惑）。

有了终端分屏和 Control-z，编辑器根本不需要内置终端。但既然 Neovim 已经内置了终端，我想我还是应该解释一下如何使用它。

## [15.2. 内置终端（这次是正经的）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_the_integrated_terminal_for_real_this_time)

在 LazyVim 中，你可以随时使用 Control-/ 快捷键打开终端。终端会显示在所有编辑器窗口的前面（除非你启用了 Edgy 扩展，这种情况下终端会显示在编辑器的下半部分）。再次按 Control-/ 可以关闭终端。

Neovim 的终端窗口是一个"特别的终端"和"Vim 窗口"的混合体。

然而，与文本编辑的插入模式不同，按 Escape 键并不会让你进入普通模式，尽管你的手指可能已经习惯性地按 Escape 键了。这样的设计其实是有道理的，因为在很多的终端程序中，也有可能会要用到 Escape 键，如果 Neovim 占用了这个键就不合理了。LazyVim 设置了快速按两下 Escape 键（<Escape><Escape>）来从终端模式切换到普通模式，或者你也可以使用默认的但不太好按的组合键：<Control> + \ + n。

进入普通模式后，你可以使用任何导航键（包括查找和搜索模式）在终端窗口中移动。如果你需要复制一些终端的输出文本到剪贴板，这个功能就很有用。

按下 a 或 i 键会让你回到"终端模式"，在这个模式下，你的每个按键都会直接发送给终端中正在运行的程序（通常是你的 shell）。

> 如果你想在命令行中使用 Vim 的 Normal 模式进行编辑（这适用于所有终端，不只是 Neovim 内的终端），你可以配置你的 shell 使用"Vi 模式"，现代的很多 shell 都支持这种模式。在这种模式下，你可以用 Escape 键进入一个类 Vim 的 Normal 模式。这样你就可以使用 w 和 b 这样的命令来导航，以及使用 d 和 c 这样的基本命令来编辑命令行。

虽然有一些第三方插件试图让 neovim 中的终端体验更加一致和愉快，但在我看来，这些都不太值得费心。我只需要按 cmd-enter 就能打开一个新的 Kitty 终端面板，获得完全正常的终端体验。

## [15.3. 检查你的 Git 状态](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_checking_your_git_status)

LazyVim 预先配置了一些精心设置的插件，这些插件能让你的版本控制工作变得更加轻松。

其中最简单的一个功能是使用文件选择器列出：自上次提交以来发生变化的文件。这个功能的操作方式与其他文件选择器操作类似，但它只会列出在 git 中有修改的文件。

你可以用 <Space>gs 打开它。我经常用它在当前正在开发的文件之间切换。实际上我更喜欢用它，而不是在第 9 章中讨论过的缓冲区选择器（那个只是显示已打开的文件）。

这张 Fzf.lua 的截图，显示了自上次提交以来修改过的两个文件：

<img src="mymedia\fzf-gitstatus-dark.png" alt="fzf gitstatus dark" style="zoom:50%;" />

> 提示：可以安装 delta-pager 命令行工具，以获得更漂亮、更直观的差异显示。

预览窗格显示了我添加、删除的差异。在左侧，你可以看到我选中了 page.svx 文件，右侧则显示了该文件中的一些更改预览。

需要特别注意的是结果窗格中的 + 和 - 列。这些符号可能会让人困惑，因为它们并不直接反映文件或文件的内容是被添加还是删除。实际上：

- **+** 列显示的是暂存区的文件状态。即当你执行 git add 后,文件状态会出现在 + 列。
- **-** 列显示的是工作区的文件状态。即当你新建、修改了一个文件，但还没有执行 git add 时，这些改动的文件就会显示在 - 列。

这些列上又会显示不同的符号，表示每个文件的 git 状态，它们的含义可能很难记住。不过符号本身很直观：

- **~** 表示该文件被修改。
- **-** 表示该文件被删除。
- **?** 表示这是一个未跟踪的新文件。
- **+** 表示这是一个已跟踪的新文件。

如果符号出现在第一列，表示该文件已经暂存。如果出现在第二列，则表示该文件尚未暂存。如果 ~ 同时出现在两列中，说明文件的某些部分已暂存，而其他部分尚未暂存。

除了让你有效地查看 git 状态外，这个选择器还允许你（操作）暂存整个文件。要暂存（即：git add）文件，选中该文件并按 <Left> 键（即左箭头键）将其移到"已暂存"列。要取消暂存（即：git restore --staged），使用 <Right> 键（即右箭头键）。如果你想丢弃（即：git restore）文件中的所有更改，使用 <Control-x>。

> 取消暂存（即：git restore --staged）和丢弃更改（即：git restore）的区别：
>
> **取消暂存：**git restore --staged <文件> 
>
> - 作用区域：**暂存区** → **工作区**
> - 效果：将文件从暂存区移回工作区
> - 你的修改内容**不会丢失**
> - 相当于撤销 git add 的操作
>
> **丢弃更改：**git restore <文件> 
>
> - 作用区域：**工作区** → **版本库**
> - 效果：将文件恢复到最后一次提交的状态
> - 你的修改内容**会丢失**
> - 这是个不可逆操作

### [15.3.1. 其他的 Pickers](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_other_pickers)

Fzf.lua 还提供了"提交历史"的**选择器**（<Space>gc），它类似于日志浏览器，还有用于切换分支的**选择器**。后者出于某些原因默认没有设置快捷键，但如果你喜欢用"选择器"来完成这个任务，可以为 :FzfLua git_branches 绑定一个快捷键。

你可以通过 :FzfLua 来显示所有已安装的"选择器"列表，然后输入 git 筛选出 git 相关的"选择器"。

## [15.4. Neo-tree 中的 Git 文件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_git_files_in_neo_tree)

Neo-tree 也有一个 Git 状态查看器。你可以用 <Space>ge 打开它，其中 e 表示"explore"（浏览）。它的优点是可以在文件夹层次结构中显示所有变更的文件。这里有上一个例子中相同的两个文件在 Neo-tree 中的显示效果：

<img src="mymedia\neotree-gitstatus-dark.png" alt="neotree gitstatus dark" style="zoom:50%;" />

在 Neo-tree 中，要暂存和取消暂存文件，将光标移到对应的行上使用 ga（git add）和 gu（git unstage）。此外，快捷键 A 会暂存所有未暂存的文件。

你也可以用 gc 来提交当前状态。这会弹出一个简陋的文本输入窗口，完全不适合输入正常长度的提交信息，所以我建议避免使用它。

使用 gp 可以将当前分支推送到远程仓库。我建议使用后面将要讨论的 lazygit 集成，但如果你经常使用 Neo-tree，这些命令也是可用的。

## [15.5. 当前焦点文件的状态](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_status_of_the_currently_focused_file)

每个缓冲区都有一些细微的"变更指示"。看这个截图：

<img src="mymedia\git-signs-dark.png" alt="git signs dark" style="zoom:50%;" />

注意左侧边栏，在行号右侧。它包含一个绿色条、一个红色三角形和一个橙色条。这些指示器分别表示这些行被添加、删除和修改。

此外，在状态栏中，文件进度指示器的左侧，我们可以看到这些图标，它们总结了相同的信息：

<img src="mymedia\git-statusbar-dark.png" alt="git statusbar dark" style="zoom:50%;" />

## [15.6. 从编辑器中暂存](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_staging_from_the_editor)

你可以直接从编辑器中将文件添加到 git 的索引（使其准备好提交）。在 <Space>gh 菜单（助记符是"git hunks"）中，有很多有趣的子命令：

<img src="mymedia\hunks-menu-dark.png" alt="hunks menu dark" style="zoom:50%;" />

你可以使用 <Space>ghS 暂存整个文件。

如果你想暂存一个文件中的部分内容，可以导航到你想暂存的代码块（可以使用 [h 和 ]h），并按 <Space>ghs。

> （ethan）具体来说：
>
> 1. hunk 是文件中发生更改的连续区域。
> 2. 一个文件可以包含多个 hunk。
> 3. hunk 不是 git 特有的概念。这种差异展示方式是 Unix diff 工具发明的，后来成为了标准。
>
> 举个例子：
>
> ```git
> # 这是第一个 hunk
> @@ -10,12 +10,13 @@
> - 这是原来的文字
> + 这是修改后的文字
> 
> # 这是第二个 hunk
> @@ -25,27 +25,28 @@
> - 这里删除了一行
> + 这里添加了新内容
> + 还加了另一行
> ```
>
> hunk 的使用场景：当你在同一个文件中同时进行多个不相关的修改，想把这些不同的修改分开提交，使得每个提交都更有意义。
>
> 不分场景的将整个文件全部提交，并不是一个好习惯。但如果你是少数的正确使用 git 的人之一（请成为这样的人），你会经常使用 <Space>ghs 命令。

你可以用 <Space>ghr 来重置单个代码块（hunk），将其恢复到暂存区的状态。如果需要重置整个文件，可以使用"更大范围"的命令：<Space>ghR（就相当于你对这个文件执行了：git restore <file> 命令）。这些重置操作会直接修改文件内容，请谨慎使用（不过通常可以按 u 键来撤销操作）。

> （ethan）如下为 **git restore <file>** 和 **git restore --source=HEAD <file>** 的区别。前者是将暂存区的内容恢复到工作区，后者是将上一次的提交内容恢复到工作区。
>
> ```mermaid
> graph LR
>  %% 定义三个存储区
>  R[(本地仓库<br>HEAD)] 
>  S[(暂存区<br>Index)]
>  W[(工作区<br>Working Dir)]
> 
>  %% 定义基本的 git add/commit 流向
>  W -->|git add| S
>  S -->|git commit| R
> 
>  %% git restore 的两种主要用法
>  S --->|"git restore <file>"<br>默认行为| W
>  R .->|"git restore --source=HEAD <file>"<br>指定来源| W
> 
>  %% 样式
>  style R fill:#d4ffdd,stroke:#333
>  style S fill:#d4e5ff,stroke:#333
>  style W fill:#ffe6f9,stroke:#333
> ```
> 不过，基于 <Space>ghR 这个名字：Gitsigns reset*_buffer，我合理怀疑，当初作者设计插件时，是受到了传统 git checkout 命令的影响。因为：
>
> 1. git restore 是在 Git 2.23.0（2019年）才引入的相对较新的命令（而这个插件存在的时间更早）。
> 2. 在这之前，开发者都是使用 git checkout -- <file> 来重置文件。
> 3. 而 git checkout -- <file> 的行为确实是将文件恢复到最后一次提交的状态（相当于现在的 git restore --source=HEAD <file>）。
> 4. 这也解释了为什么这个功能被命名为 "reset_*buffer" 而不是 "restore*_buffer"。
> 
> 所以这里可能存在一个有趣的历史遗留问题：命令的实际行为（git restore）和命名（reset_*buffer）反映了不同的 Git 历史阶段。这提醒我们在使用这类命令时，最好先验证其具体行为，而不是仅依赖命令名称来判断。

如果你不小心暂存了一个代码块，想取消暂存的话，可以使用 <Space>ghu 取消暂存。与重置不同，**这个操作不会改变文件内容**；更改仍然存在，只是不再被暂存了。

## [15.7. Git 信息快捷键](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_git_information_keybindings)

blame line 命令（<Space>ghb）可以将光标所在行的最后一次提交信息（git commit）显示出来，想要退出显示，只需将光标导航到其他处即可。这对回答"这行代码当时为什么要这么做"很有帮助：

<img src="mymedia\git-hunk-blame-line.png" alt="image-20250101151929776" style="zoom:67%;" />

> （ethan）blame line 命令（<Space>ghb）对应于 git 的命令：
>
> 1. git blame -L <行号>,<行号> <文件> 
> 2. 获取这行的 commit-hash
> 3. git show -U0 <commit-hash> -- <文件路径>
> 4. 找到想 blame 的行号，获取该行上的改动

预览代码块命令（<Space>ghp）会临时显示代码块的原始版本和修改版本（一个在上一个在下），这样你就能准确看到具体改动了什么。比如：

<img src="mymedia\git-hunk-preview.png" alt="image-20250101011608677" style="zoom:67%;" />

> （ethan）预览代码块命令（<Space>ghp）对应于 git 的命令：
>
> 1. git diff -U0 HEAD <file>
> 2. 找到想 diff 的行号，获取该行上的改动内容

Diff this 命令（<Space>ghd 和 <Space>ghD）做同样的事情，但是使用并排视图显示，我们将在本章后面详细的讨论这个。

就我个人而言，我经常使用这些命令，以至于觉得需要按这么多按键才能调出它们有点麻烦。所以我在 plugins 目录下创建了一个 extend-gitsigns.lua 文件，将这些命令从 <Space>gh 映射为 <Space>h：

```lua
return {
  "lewis6991/gitsigns.nvim",
  keys = {
    {
      "<leader>hb",
      "<cmd>Gitsigns blame_line<cr>",
      desc = "Blame Line"
    },
    {
      "<leader>hs",
      "<cmd>Gitsigns stage_hunk<cr>",
      desc = "Stage Hunk"
    },
    {
      "<leader>hS",
      "<cmd>Gitsigns stage_buffer<cr>",
      desc = "Stage Buffer"
    },
    {
      "<leader>hr",
      "<cmd>Gitsigns reset_hunk<cr>",
      desc = "Reset Hunk"
    },
    {
      "<leader>hR",
      "<cmd>Gitsigns reset_buffer<cr>",
      desc = "Reset Buffer"
    },
    {
      "<leader>hu",
      "<cmd>Gitsigns undo_stage_hunk<cr>",
      desc = "Undo Stage Hunk"
    },
    {
      "<leader>hd",
      '<cmd>lua require"gitsigns".diffthis()<CR>',
      desc = "Diff This",
    },
    {
      "<leader>hD",
      '<cmd>lua require"gitsigns".diffthis("~")<CR>',
      desc = "Diff This~",
    },
  },
}
```

这些内容是我从 LazyVim 官网上的 git-signs 配置中复制后，再将 map 调用转换为 keys = 格式。

## [15.8. Lazygit](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_lazygit)

Lazygit（尽管与 LazyVim 和 Lazy.nvim 共享 "Lazy" 命名，但实际上是由完全不同的开发者开发的）是一个用于与 git 交互的终端 UI 工具。如果你想使用它，需要通过包管理器单独安装（比如 brew install lazygit）。

LazyVim 预先配置了使用快捷键 <Space>gg 在终端窗口中显示 lazygit。我不会详细的介绍如何使用这个第三方程序。它几乎可以做任何 git 命令行能做的事情，而且界面更加用户友好。

Lazygit 需要一些时间来熟悉，但它有帮助菜单和快捷键助记符，所以学习曲线相对平缓。

有趣的是，在使用 LazyVim 之前，我（在命令行中）就已经频繁的使用 lazygit 了。但是现在，我已经改用到刚才讨论过的 <Space>h 菜单。

现在，我大部分 git 工作都是用的 [Graphite](https://graphite.dev/) 工具，它简化了我过去使用 lazygit 的许多工作流程（特别是 rebasing）。我现在仍然使用 lazygit，只是频率少了很多。

## [15.9. Diff 模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_diff_mode)

Neovim 自带一个功能强大但稍难掌握的 Diff 查看模式。它可以并排显示文件"修改前"和"修改后"的对比，甚至可以配置显示"父版本"和"变更状态"。

**打开 Diff 模式：**

有几种不同的方式可以进入 Diff 模式。最基础的方式是：在命令行打开两个文件时指定：

```shell
nvim -d file1 file2
```

这会在 Diff 视图中并排打开指定的文件。但在 Git 管理的开发场景中，你可能想要查看的是，当前文件与暂存区之间的差异，这可以通过快捷键 <Space>ghd 完成。或者使用 <Space>ghD 来显示当前文件与最后一次提交之间的差异。

使用这些命令后，会打开一个右侧为"工作区"、左侧为"暂存区"/"仓库区"的视图：

<img src="mymedia\git-diff.png" alt="image-20241229221428986" style="zoom:50%;" />

**关闭 Diff 模式：**

一旦你进入 Diff 模式，想要回到之前的模式可能会有点棘手。当你进入 Diff 视图，并排预览差异时，即使关闭 buffer（close current buffer），它也会保持这种窗口布局。所以你需要按照这样的步骤来关闭 Diff 模式：

1. 将光标移动到左侧的 Diff buffer（"暂存区"/"仓库区"）。

2. 关闭当前窗口（<Control-w>q）。

<img src="mymedia\close-git-diff.png" alt="image-20241229223937126" style="zoom:50%;" />

> 相关命令：
>
> - 命令模式中输入 diffoff，它会为当前缓冲区禁用"Diff 视图"。
> - <Space>bd（Delete buffer）。
> - <Control-w>q（Quit a window）。

还有一点需要说明的是，默认情况下，diff 视图会将两个文件中相同的代码折叠成一个折叠区。使用代码展开命令 zo 可以将其展开。

### [15.9.1. 编辑 Diffs](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_editing_diffs)

编辑 Diff 之前，我们先介绍一下如何在"差异块"之间跳转，这很重要。因为 <Space>ghs、<Space>ghr、<Space>ghu 命令都是基于"差异块"来工作的，若你直接使用 jkhl 来导航，很有可能将光标移动到非"差异块"上，从而导致这些命令出现未知的错误，如下为"差异块"之间跳转方式：

在 Diff 模式中，**[h 和 ]h**、**[c 和 ]c** 都可以在更改的"差异块"之间跳转（c 可以助记为 "change"）。其中[c 和 ]c 需要特殊说明一下（可以参考 Lazyvim 的配置说明：[gitsigns](https://www.lazyvim.org/plugins/editor#gitsignsnvim)）：

- 普通模式中，[c 和 ]c 表示在类或类型之间跳转（前面的章节有说明）；[h 和 ]h 在 hunk 间跳转。
- Diff 模式中，[h 和 ]h 和 [c 和 ]c 都可以在 hunk 间跳转。

当你使用 <Space>ghd 命令来查看当前文件（工作区）与暂存区的 Diff 视图后，你可以继续**编辑**右侧的文件（工作区）进行修改。

> （ethan）一般不在 <Space>ghD 命令后编辑 Diffs，原因是：
>
> 1. <Space>ghD 命令比较的是仓库区(HEAD)和工作区的差异，主要用于预览变更，而不适合编辑场景：
>    - 仓库区的更改需要通过正式的 commit 流程，不能直接修改。
>    - 在此视图下使用 stage/unstage 命令的效果有限，无法提供良好的视觉反馈。
> 2. 从 Git 工作流程来看，<Space>ghd 更适合日常开发：
>    - 开发过程中最频繁的操作是在"工作区 ↔ 暂存区"之间。
>    - 所有操作都是可逆的，可以通过 stage/unstage 随时调整。
>    - 任何编辑或暂存操作都能在两侧视图中获得即时的视觉反馈。

如前面说明的，右侧是"工作区"文件，左侧是"暂存区"文件。在 Lazyvim 中，并没有直接禁止编辑暂存区文件，但这样做会混淆 Diff 模式的机制，所以请遵守从右侧进行编辑。

如果你想"编辑"左侧的文件，可以在右侧使用 <Space>ghs、<Space>ghr 和 <Space>ghu 来暂存、重置、取消暂存，以达到间接的"编辑"左侧文件。

当使用 Diff 视图时，我发现暂存、重置、取消暂存，这些快捷方式挺符合我的思维模式。然而，Neovim 还内置了两个有点奇怪的命令，你可能偶尔需要用到，他们分别是 :diffget 和 :diffput。这些命令的简写形式是 :diffg 和 :diffp，可以节省几次按键。

这些命令常用于可视模式（或者带上范围），它们本质上意味着（在某个范围内）：让这个文件与另一个文件相同，或让另一个文件与这个文件相同。考虑这两个略有不同的文件：

<img src="mymedia\diff-mode-dark.png" alt="diff mode dark" style="zoom:50%;" />

- Diff1：暂存的文件中缺少单词"Two"，我在工作区添加了它。
- Diff2：暂存的文件多了"Four Point Five"行，我在工作区删除了它。
- Diff3：暂存的文件中，单词 Six 拼写错了，我在工作区修改了它。

基于以上的场景，我们来学习几种使用 :diffg 和 :diffp 的方法。 

虽然你可以在任意一侧的文件上使用这些命令，但通常，你只要在一侧的文件上处理即可。在以下的例子中，假设我都在右侧（工作区）处理。

- Diff1：若我想暂存工作区的"Two"，我可以在"Two"行上输入 :diffp，这意味着"让这个文件与另一个文件相同"。
- Diff2：若我想将已暂存的"Four Point Five"取消掉，也就是说"让右侧文件与左侧文件相同"。要从右侧窗口做到这一点，我可以使用 Shift-V 进入可视行模式，选择包含 Four 和 Five 的行以及这两行之间代表已删除的空白红色区域，接着再输入 :diffg 或 :diffget。这意味着"获取另一个窗口的内容并使我的窗口与之匹配"。（由于 :diffget 和 :diffput 接受范围参数，所以 '< 和 '> 可以传递给他们）
- Diff3：...

如果你习惯使用上述 Diff 界面，但对于：找出项目中所有的差异文件，感到繁琐（虽然可以使用 fzf 的选择器命令 <Space>gs），那你可以配置 [diffview.nvim](https://github.com/sindrets/diffview.nvim) 插件，它有一个很友好的界面，可以同时看到所有的差异文件，并方便的查看这些文件差异。

## [15.10. 将 Vim Diff 配置为合并工具](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_configuring_vim_diff_as_merge_tool)

很多人都讨厌解决合并冲突。不过对我来说，有了 Diff 模式和 rebase 功能，这个过程反而变得有点享受。诀窍就是配置一个稍微复杂点的 ~/.gitconfig 文件（当然，还需要一个够大的显示器）。

显示器的问题我帮不了你，但是 .gitconfig 文件可以这样配置：

```ini
[diff]
    tool = vimdiff
[merge]
    tool = vimdiff
    conflictstyle = zdiff3
[mergetool "vimdiff"]
    cmd = nvim -d $LOCAL $BASE $REMOTE $MERGED \
          -c '$wincmd w' -c 'wincmd J'
```

把"冲突样式"配置成"zdiff3"，这样可以自动处理相同的代码行，让 diff 的结果更容易阅读。[diff] 和 [merge] 中的"tool ="配置，指定 Git 使用最后一行配置的 vimdiff 作为合并工具。

最后一行的命令会打开 Neovim，并创建四个窗口，然后自动聚焦到合适的窗口中。

为了演示这个过程，我创建了一个新的 Git 仓库，里面有两个分支，它们之间有冲突的修改。当我尝试把一个分支 rebase 到另一个分支上时（我一般使用 rebase 而不是 merge commit，因为这样可以独立处理每个变更带来的冲突。这也是为什么对我来说，每个 commit 只包含一种改动很重要！），果然出现了这个错误：

```shell
✦ ❯ git rebase main
Auto-merging file
CONFLICT (content): Merge conflict in file
error: could not apply f611b6f... Uppercase
Could not apply f611b6f... Uppercase
```

要解决这个冲突，我们需要运行 git mergetool。因为前面的 Git 配置，它会打开 Neovim 并显示四个不同的 diff 窗口：

<img src="mymedia\mergetool-dark.png" alt="mergetool dark" style="zoom:50%;" />

上面是三个并排的窗口，下面是一个大窗口（也是最痛苦的地方）。

**左上角窗口：**显示"本地（local）"的改动。"本地"的具体含义取决于你是如何进入冲突状态的。在典型的 rebase 流程中，它通常表示"main 分支的当前状态"。所以当发生冲突时，这里其实包含的是"其他人的改动"，所以叫"本地"反而有点不太准确。

**中间窗口：**显示改动的"共同祖先"或"基础（base）"版本。也就是说，这是在你或"其他人"做出任何改动之前的文件状态。很多合并工具教程都不会提到这个窗口，但我觉得它对于理解：基础版本与两侧窗口的变化对比时很有帮助。

**右上角窗口：**显示"远程（Remote）"的改动，这个名字和"本地"一样可能会产生误解。在 rebase 流程中，它通常指"我在要 rebase 到 main 分支上时所做的改动"。

**底部窗口：**显示"文件的当前状态"，在 rebase 失败时会包含混乱的冲突标记。这是唯一一个你应该进行编辑的文件。

如果有很长的相同代码段，这四个文件都会使用代码折叠功能。另外，当你在下面的文件中滚动或移动光标时，上面的文件也会同步滚动，保持对齐。上面三个窗口中会有一条下划线，表示 diff 工具认为这是相对于下面窗口光标位置的"当前行"。

大多数 rebase（解决冲突）流程都是：

1. 先用 vag + :%diffg N 选择一个基础版本。即让底部窗口的内容和上面某个窗口的内容一致。
2. 然后通过 :diffg N 来选择性的逐个获取差异块进行合并。
3. 最后手动编辑需要特殊处理的部分。

> （ethan）vag 是一个复合命令，它由两部分组成：v（进入可视模式） + ag（一个文本对象，表示"整个文件"）。所以 vag 的意思是"选择整个文件的内容"。

问题是，由于打开了多个窗口，:diffg 不知道应该从哪个窗口获取内容：

<img src="mymedia\mergetool-buffer-error-dark.png" alt="mergetool buffer error dark" style="zoom:50%;" />

这时我们需要使用命令 :%diffg 2。这里的 2 是缓冲区编号。当你直接从命令行运行 merge-tool 时，缓冲区会按被打开的顺序进行编号。所以 1 是左边的缓冲区，2 是中间的，3 是右边的，4 是下面的窗口。如果你不确定，可以用 <Space> + <comma>（逗号） 快捷键查看缓冲区列表：

<img src="mymedia\mergetool-buffer-numbers-dark.png" alt="mergetool buffer numbers dark" style="zoom:50%;" />

在这个列表中，第一列就是缓冲区编号。这个数字会随着你打开的 buffer 数量增加而递增，所以如果你编辑了一段时间，这个数字可能会很大。但是当你在终端中使用 git mergetool 时，它通常会打开一个全新的 Neovim 实例，编号就会是 1-4。

运行 vag 和 :%diffg 2 命令后，底部窗口会和中间窗口一样，也就是回到了创建任何分支之前的状态。如果用 vag 然后 :%diffg 1，它就会和 main 分支一样；用 vag 后跟 :%diffg 3，就会和"我的分支"一样。然后你就可以查看缓冲区窗口之间的差异，使用 :diffg N 从某个窗口（N）中获取相应的改动。最后，若还有要手动处理的地方，再编辑即可。

合并冲突总是会有点压力，但是我发现用如上的四窗口视图时，通常能更容易理解发生了什么变化、以及为什么会有这些变化。不过说实话，我只有在遇到特别棘手的合并情况时才会用它。平常我都是用 git-conflict.nvim 插件。

## [15.11. Git-conflict.nvim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_git_conflict_nvim)

虽然 merge-tool 在处理特别复杂的合并时很有用，但对于简单的冲突，我觉得直接编辑带有"冲突标记"的文件会更快。Git-conflict.nvim 这个插件提供了语法高亮和一些快捷键，可以帮助我们更方便地处理冲突。

参考如下的配置（复用之前设置的 <Space>h 前缀（用于暂存代码块）加了一些新的命令）：

```lua
return {
  "akinsho/git-conflict.nvim",
  lazy = false,
  opts = {
    default_mappings = {
      ours = "<leader>ho",
      theirs = "<leader>ht",
      none = "<leader>h0",
      both = "<leader>hb",
      next = "]x",
      prev = "[x",
    },
  },
  keys = {
    {
      "<leader>gx",
      "<cmd>GitConflictListQf<cr>",
      desc = "List Conflicts"
    },
    {
      "<leader>gr",
      "<cmd>GitConflictRefresh<cr>",
      desc = "Refresh Conflicts"
    },
  },
}
```

启用这个插件后，当你打开一个有冲突的文件时，它会用不同的颜色高亮显示"冲突标记"。在我的示例文件中长这样：

<img src="mymedia\git-conflict-dark.png" alt="git conflict dark" style="zoom:50%;" />

"冲突标记"包含了三部分内容：

- 上面是"当前"代码（HEAD，即当前分支的内容）。
- 中间是原始或基础代码（合并冲突前的原始版本）。
- 下面是"新"代码（要合并的内容）。

我可以用 ]x 快捷键快速跳转到下一个冲突（这个例子中只有一个冲突）。然后可以用以下快捷键来解决冲突：

- <Space>ho：选择当前分支的版本。
- <Space>ht：选择要合并进来的版本。
- <Space>hb：保留两个版本。
- <Space>h0：回到中间的原始版本。

> o 和 t 这两个快捷键可能不太好记。从技术上讲，它们代表"ours（我们的）"和"theirs（他们的）"，但由于你执行 merge 或 rebase 的顺序不定，它们并不能准确的表示：是自己的提交，还是别人的提交。我是这样记的：在字母表中 o 在 t 之前，所以它对应冲突中上方的改动。当然，你也可以把它们重新映射到更容易记住的快捷键上。

在大多数情况下，你可能还需要手动编辑来让代码正确，这很正常。因为没有哪一个冲突管理插件，可以用 AI 来语义理解这些改动的意图，所以这部分工作还是需要你自己来完成！

大约 90% 的情况，这个插件就足够我解决冲突了。只有在遇到特别棘手或复杂的情况时，我才会使用 mergetool。

## [15.12. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-15/#_summary_15)

本章介绍了在 LazyVim 中与 git 和版本控制交互的多种方式。你可能不会用到这里的所有功能，但我想全部展示出来，让你可以自己决定使用哪一个。

也许你想使用 Lazygit，或者你更愿意留在编辑器中使用 git-signs 和原生 Vim diff 提供的功能。也许你想安装一些额外的插件，比如 git-conflict.nvim 或 diffview.nvim 来优化你的使用体验（其他值得关注的插件包括 Neogit 和 mini.git）。

或者，你根本不想在编辑器中操作这些内容，而是更倾向于切换到终端模式，使用原生 git 或像 graphite 这样的封装工具。无论哪种方式适合你，LazyVim 都提供了你需要的集成功能。

在下一章中，我们将承认现在已经不是 2020 年了，来谈谈人工智能吧。

# [第16章：配置 AI](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-16/#_configuring_artificial_intelligence)

> （ethan）本人目前用不到，暂不翻译，感兴趣的可以自行阅读原文。

# [第17章：Debugging](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-17/#_debugging)

> （ethan）本人目前用不到，暂不翻译，感兴趣的可以自行阅读原文。
>

# [第18章：Testing](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-18/#_testing)

> （ethan）本人目前用不到，暂不翻译，感兴趣的可以自行阅读原文。
>

# [第19章：LazyVim 配置全指南](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_comprehensive_guide_to_lazyvim_configuration)

我们在第5章中介绍了基础的插件配置。在后面章节中介绍特定插件的配置时，我也零散地讲解了一些处理复杂情况的方法。

本章会先简单回顾一下之前的内容，然后教你如何查找、配置那些不在 LazyExtras 中的 Neovim 插件。

## [19.1. 插件目录](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_plugins_directory)

正如第5章所述，插件是由 Lazy.nvim 这个插件管理器来管理的。它会自动加载（这里的加载，指的是**读取和解析**）你配置文件夹中 lua/plugins 目录下的所有 *.lua 文件。通常，这个目录的位置是 ~/.config/nvim/lua/plugins。不过，如果你设置了 NVIM_APPNAME 环境变量，那么目录就会变成 ~/.config/$NVIM_APPNAME/lua/plugins。

> （ethan）Lazyvim 的配置优先级为：
>
> 1. LazyVim 核心配置最先加载。
>
> 2. 用户配置覆盖核心配置。
>
> 3. 插件特定配置最后加载。
>
> 这种分层的配置和加载机制使得 LazyVim 能够：保持快速的启动速度、提供灵活的配置选项、维持插件之间的兼容性、方便用户自定义和扩展。

这个目录下的 Lua 文件必须返回一个 Lua 表（table）。所以，它们的基本结构是这样的：

```lua
return {

}
```

这个 Lua 表可以包含一个插件的配置，也可以包含多个插件的配置。举例来说，结构可以是：

```lua
return {
  "username/plugin",
  opts = {...},
  keys = {...}
  ...
}
```

或者是多个插件的配置：

```lua
return {
  {
    "username/plugin",
    opts = {...},
    keys = {...}
  },
  {
    "username2/plugin2",
    ...
  }
}
```

就我个人而言，我习惯把每个插件放在单独的文件里，这样用 <Space>fc 快捷键搜索时比较方便。不过，如果一个插件的存在会影响到另一个插件的配置，我就会把它们放进同一个文件里使用多插件格式。

## [19.2. 插件配置的级联效果](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_plugin_specifications_cascade)

在你的配置中，同一个插件可以被多次定义，**LazyVim 会把所有配置合并在一起**。这在以下几种情况下特别有用：

- 有些人喜欢把插件的快捷键绑定和插件的选项配置分开放置。比如：

  ```lua
  -- 文件：lua/plugins/telescope.lua
  return {
    "nvim-telescope/telescope.nvim",
    opts = {
      defaults = {
        layout_strategy = "horizontal",
        sorting_strategy = "ascending",
      }
    }
  }
  
  -- 文件：lua/plugins/keymaps.lua
  return {
    "nvim-telescope/telescope.nvim",
    keys = {
      { "<leader>ff", "<cmd>Telescope find_files<cr>", desc = "Find Files" },
      { "<leader>fg", "<cmd>Telescope live_grep<cr>", desc = "Live Grep" },
    }
  }
  ```

- 有时你想把主要的插件配置放在一个文件中，然后在另一个相关插件中覆盖一些配置。比如：

  ```lua
  -- 文件：lua/plugins/completion.lua
  -- 这是主要的补全插件配置
  return {
    "hrsh7th/nvim-cmp",
    opts = {
      -- 基础补全配置
      completion = {
        -- 自动弹出补全窗口
        autocomplete = true,
      },
      
      -- 设置补全来源
      sources = {
        { name = "buffer" },    -- 从当前缓冲区获取补全
      },
      
      -- 基础快捷键设置
      mapping = {
        -- 回车确认补全
        ["<CR>"] = require("cmp").mapping.confirm({ select = true }),
        -- Tab 键在补全菜单中移动
        ["<Tab>"] = require("cmp").mapping.select_next_item(),
      },
    }
  }
  
  -- 文件：lua/plugins/lsp.lua
  -- 这是 LSP 相关的配置，我们在这里修改覆盖 nvim-cmp 的设置
  return {
    "neovim/nvim-lspconfig",
    dependencies = {
      -- 在 LSP 插件中修改 nvim-cmp 的配置。Lazy.nvim 会自动处理插件的加载顺序，它使用以下规则：
      -- 1. 首先收集所有的插件配置
      -- 2. 然后根据插件之间的依赖关系构建加载图。在这个示例中，会保证 dependencies 中的配置总是在     -- 主配置之后应用
      {
        "hrsh7th/nvim-cmp",
        opts = function(_, opts)
          -- opts 参数包含了上面文件（completion.lua）中的所有配置
          
          -- 获取现有的补全来源列表（如果 opts.sources 存在且不为 nil，就使用 opts.sources 的         -- 值，否则使用空表 {}）
          local sources = opts.sources or {}
          
          -- 在最前面添加 LSP 补全源（让它优先级最高）
          table.insert(sources, 1, { name = "nvim_lsp" })
          
          -- 更新配置
          opts.sources = sources
          
          -- 返回修改后的配置
          return opts
        end
      }
    }
  }
  ```

- 最常见的 => LazyVim 为许多插件预设了合理的默认配置，但有时你可能想用自己喜欢的快捷键或选项来覆盖这些默认值。比如：

  ```lua
  -- LazyVim 的默认配置（在 LazyVim 源码中）文件
  return {
    "nvim-telescope/telescope.nvim",
    opts = {
      defaults = {
        prompt_prefix = "🔍",
      }
    }
  }
  
  -- 你的自定义配置文件
  return {
    "nvim-telescope/telescope.nvim",
    opts = {
      defaults = {
        -- 这会与默认配置合并，而不是完全覆盖
        layout_config = {
          height = 0.8,
          width = 0.9,
        }
      }
    }
  }
  ```

## [19.3. 插件配置说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_plugin_specification)

最简单的插件配置，就是一个只包含 GitHub 用户名和仓库名（用 / 分隔）的字符串。有时候这就够用了，尤其是对于 VimScript 插件来说。如果插件不是托管在 GitHub 上的，你可以省略第一个参数，改用 dir=/path/to/a/folder 或 url=https://domain.com/path/to/plugin。以下为示例说明：

```lua
-- 最简单的方式：GitHub 用户名/仓库名
return {
  -- 这会从 GitHub 安装 https://github.com/folke/tokyonight.nvim
  "folke/tokyonight.nvim",
  
  -- 可以同时配置多个插件
  "nvim-treesitter/nvim-treesitter",
  "tpope/vim-surround",
}

-- 使用本地插件（dir）
return {
  {
    dir = "~/my-nvim-plugins/my-custom-plugin",
    -- 其他配置选项...
  }
}

-- 使用非 GitHub 的 URL
return {
  {
    url = "https://gitlab.com/someone/some-plugin.git",
    -- 其他配置选项...
  }
}
```

如果你需要把插件固定在特定版本或 git 分支上，你可以使用 branch、tag、commit 或 version 参数。对于托管在 GitHub 上的插件，你可以在 GitHub 上找到这些版本标识符的具体值。你可能很少会用到这个功能，因为通常我们都是安装插件的主分支。但如果你发现插件最近的更新导致了问题，或者你想尝试还未合并到主分支的新特性，就可以设置这些参数试试。

Lazy.nvim 的插件配置有将近二十个选项，都记录在 https://lazy.folke.io/spec 中。我们在第5章讨论过其中的一些，比如 enabled、opts 和 keys。现在我们来看看其他几个选项。

## [19.4. 插件的不同生命周期](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_plugin_lifecycle_methods)

插件生命周期中的不同阶段会调用几个不同的选项。你很少需要指定这些选项，但在控制"代码执行时机"时它们很有用，尤其是当你想把（"第三方"）插件 Readme 中的原始配置，转换成 Lazy.nvim 风格的配置时。

简单来说，"生命周期中的不同阶段会调用几个不同的选项"、"控制代码的执行时机"，指的是：

- init - 在插件加载前执行。
- config - 在插件加载后执行。
- build - 在插件安装或更新后执行。
- dependencies - 指定在本插件加载前需要先加载的其他插件。
- cmd, event, ft - 指定插件的延迟加载条件。

**需要注意的是：这是 Lazy.nvim 插件管理器定义的规范，而不是 Neovim 的原生规范。**

### [19.4.1. Build](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_build)

build 选项只在插件安装、更新时调用一次，在 Neovim 正常启动或运行时不会调用。我们在第9章的 smart-splits 配置中见过一个例子。在那个例子中，我们传入了一个插件需要的 shell 脚本的路径。插件每次安装或升级时，都会运行这个 build 命令，确保相关的 Kitty 脚本被正确安装。除了字符串路径外，build 还可以是：

- 一个 Lua 函数（此 Lua 函数可接受参数 plugin，这个 plugin 对象是由 lazy.nvim 创建和维护的，它包含了插件的完整信息，比如 dir、name 等等）。
- 任意 Lua 脚本文件的路径。
- 字符串 "rockspec"。此情况下，lazy.nvim 会寻找插件目录下的 .rockspec 文件（Luarocks 是 Lua 模块的包管理器和索引，类似于 Python 的 pypi、Javascript 的 npm 或 Rust 的 crates），使用 luarocks 进行构建。
- 以 : 开头的字符串（比如：":TSUpdate"），用于执行任意 Vim 命令。
- 普通的字符串，此时 lazy.nvim 会将其作为 shell 命令执行（比如：make）。
- 包含上述所说的一个或者多个组成的 **list**。

作为插件的使用者，一般只有插件文档中显式的要求时，才需要指定 build 函数。

### [19.4.2. Init](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_init)

init 选项在 noevim 启动时执行（如前面所说，这时 Lazy.nvim 会去解析插件配置），所以为了保持启动时间短，除非必要，最好避免使用它。它接受一个 Lua 函数作为参数，这个函数会接收到该插件的配置信息（具体来说是一个 [LazyPlugin](https://github.com/folke/lazy.nvim/blob/main/lua/lazy/types.lua) 实例，和 Build 选项中的 plugin 一样）。

Init 函数的特点：

1. **执行时机**：init 函数在插件的代码被加载（执行和初始化）之前执行。这意味着你不能使用插件内部的功能或资源，因为插件本身尚未被加载。
2. **用途和限制**：由于 init 在插件加载前执行，因此你只能进行一些基础的设置，比如定义全局变量或调整一些影响插件行为的选项。自然的，你也无法访问插件的 API 或方法，因为这些在 init 执行时尚未准备好。

在我的插件配置中，我从未真正地需要指定 init。如果我需要插件在启动时执行，我会使用 lazy=false 让它在启动时完全配置。如果确实需要多步设置，init 可能会有帮助，但以我的经验来看，很多事情 LazyVim 都为我做了，所以我从未需要它。一般只有在如下的情况中才有可能需要：

1. 需要在插件加载前设置关键变量。
2. 需要复杂的懒加载逻辑。
3. 配置纯 VimScript 插件。对于那些没有提供 Lua setup() 方法的传统 VimScript 插件，需要通过 init 设置 VimScript 全局变量（vim.g.\*）来进行配置（比如 [vim-highlighter](https://github.com/azabiong/vim-highlighter)）。

### [19.4.3. Config](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_config)

config 选项是你最可能要用到的。它在插件加载（这里的加载，指的是插件代码实际被 **执行和初始化** 的过程，和前面的"插件目录"中说的加载**（读取和解析）**是不同的概念）时被调用，具体的加载时机，取决于你如何配置，可能是启动时，也可能是首次使用时：

- 如果设置了 lazy = false，那么会在 Neovim 启动时执行调用。
- 如果没设置 lazy = false，那么就会为默认值，即 lazy = true。此时有两种情况：
  1. 配置了触发条件，比如：event、cmd、ft、keys 等等。那么就会在这些触发条件发生时，执行插件调用。
  2. 没有配置任何触发条件。那么插件会在 Neovim 启动完成后的 VeryLazy 事件触发时被执行调用。

**首先你需要理解当你不指定 config 时的默认行为：**

基于 Lua 的插件有一个事实上的标准，就是提供一个 setup 函数（Lua 插件的一个约定成俗的函数名字），这个函数接受一个"包含插件选项的**表**"作为参数。你看到的大多数插件的 README 都会指导你写类似这样的代码：

```lua
require('pluginName').setup({
    key = value,
    key2 = value2,
    -- 你可以添加更多的选项
    option1 = true,
    option2 = {
        subkey1 = "value1",
        subkey2 = "value2"
    }
})
```

> 1. require('pluginName') 加载插件模块。
> 2. .setup 调用这个模块提供的 setup 函数。
> 3. ({...}) 传入一个包含你想要的配置选项的表。

他们会告诉你把这段代码放在 init.lua 中。如果你不用 LazyVim，这些指导是没问题的，但这不适合我们。

在 Lazyvim 中，我们可以将这些插件选项写在 opts 中，比如：

```lua
return {
  "username/plugin",
  opts = {
    key = value,
    key2 = value2,
    -- 你可以添加更多的选项
    option1 = true,
    option2 = {
      subkey1 = "value1",
      subkey2 = "value2",
    },
  },
}
```

当你在插件配置中定义 opts 时，Lazy.nvim 会识别到这一点，并在内部自动调用插件的 setup 函数。也就是说，你不需要手动调用 setup，Lazy.nvim 会为你处理这一切，它会在加载插件时自动执行类似于以下的代码：

```lua
require('pluginName').setup({
    key = value,
    key2 = value2,
    -- 你可以添加更多的选项
    option1 = true,
    option2 = {
        subkey1 = "value1",
        subkey2 = "value2"
    }
})
```

这是 Lazyvim 提供的特性：

- 简化配置：使用 opts 可以减少重复代码，并使得插件的配置更清晰。你不需要每次都手动调用 setup，只需提供所需的选项。
- 合并选项：如果你在多个地方为同一个插件提供了不同的 opts，Lazy.nvim 会自动合并这些选项，确保所有配置都能生效。

如果你覆盖了 config，就不能轻易的利用这些特性了。

**不过，如果你配置的插件不标准，或者需要在启动时运行额外的代码，你就要自己指定 config：**

config 是一个接受两个参数的 Lua 函数。第一个参数和 init 接收到的 LazyPlugin 配置相同，第二个参数是 Lazy.nvim 为你创建的 opts 表，这个表可能是通过合并多个定义中的 opts 得到的。

当你想要修改 LazyVim 为某个插件提供的某个默认配置项时，而这个默认配置项，已经被 LazyVim 用 config 覆盖了，这就成了一个问题。假设 LazyVim 中有这样一个插件配置：

```lua
-- 在 LazyVim 的（一些旧的插件）默认配置中
{
  "nvim-lualine/lualine.nvim",
  config = function()
    -- LazyVim 直接使用 config 函数来设置（没有带 opts 参数）
    require("lualine").setup({
      options = {
        theme = "auto",
        component_separators = "|",
      },
      sections = {
        lualine_a = { "mode" },
        -- 其他的配置...
      }
    })
  end,
}
```

现在，如果你想要修改其中的某些配置，比如想要改变 component_separators，你可能会这样写（失效的配置）：

```lua
-- 在你的配置中
{
  "nvim-lualine/lualine.nvim",
  -- ❌ 这样不会生效，因为 LazyVim 使用了 config
  opts = {
    options = {
      component_separators = { left = "›", right = "‹" },
    }
  }
}
```

所以，你只能这样写：

```lua
{
  "nvim-lualine/lualine.nvim",
  config = function()
    require("lualine").setup({
      options = {
        theme = "auto",
        component_separators = { left = "›", right = "‹" },
      },
      sections = {
        lualine_a = { "mode" },
        -- 需要把所有配置都写一遍
      }
    })
  end,
}
```

与 opts 和 keys 不同，只有一个 config 函数会被调用（最后加载的那个）。所以如果你为插件指定了 config，LazyVim 的（config）配置就不会执行。

普通的配置项一般可以通过恰当的使用 opts 或 keys 来修改。但如果你需要执行的"命令式任务"与 LazyVim 提供的不同，你很可能需要从 [https://lazyvim.org](https://lazyvim.org/) 网站上把那个插件的完整配置复制到你的个人配置中。

> （ethan）**命令式任务（imperative tasks）**在这里主要指那些需要按特定顺序执行的操作，通常涉及到多个步骤或者需要调用特定函数的配置。这些不是简单的配置值，而是一系列的操作步骤。
>
> 让我用一个具体例子来说明：
>
> ```lua
> -- LazyVim 中的一个配置示例
> {
>   "folke/noice.nvim",
>   config = function()
>     -- 1. 首先设置一些 vim 选项
>     vim.opt.cmdheight = 0
> 
>     -- 2. 然后注册一些按键映射
>     vim.keymap.set("n", "<c-f>", function()
>       if not require("noice.lsp").scroll(4) then
>         return "<c-f>"
>       end
>     end)
> 
>     -- 3. 设置一些事件监听器
>     vim.api.nvim_create_autocmd("FileType", {
>       pattern = "markdown",
>       callback = function()
>         -- 做一些特殊处理
>       end
>     })
> 
>     -- 4. 最后设置插件配置
>     require("noice").setup({
>       -- 插件的具体配置
>     })
>   end
> }
> ```
>
> 这种情况下：
>
> 1. 这些操作都是按顺序执行的"命令"
> 2. 不仅仅是简单的配置值，而是一系列的操作步骤
> 3. 可能涉及到 vim API 调用、事件注册、按键映射等
> 4. 操作之间可能有依赖关系
>
> 如果你想修改这样的配置，简单使用 opts 是不够的，因为：
>
> - opts 只能修改最后的插件配置部分
> - 无法通过 opts 修改那些命令式的操作（如按键映射、自动命令等）
>
> 正确的修改方式是：
>
> 1. 从 LazyVim 网站复制完整的配置
> 2. 放到你自己的配置文件中
> 3. 然后按你的需求修改整个配置函数
>
> 例如，如果你想要不设置 cmdheight、修改按键映射为其他键、添加新的事件监控器等：
>
> ```lua
> {
>   "folke/noice.nvim",
>   config = function()
>     -- 1. 不设置 cmdheight
>     -- vim.opt.cmdheight = 0  -- 删除这行
> 
>     -- 2. 修改按键映射为其他键
>     vim.keymap.set("n", "<c-d>", function()  -- 改成 <c-d>
>       if not require("noice.lsp").scroll(4) then
>         return "<c-d>"
>       end
>     end)
> 
>     -- 3. 添加新的事件监听器
>     vim.api.nvim_create_autocmd("FileType", {
>       pattern = "markdown",
>       callback = function()
>         -- 你的自定义处理
>       end
>     })
> 
>     -- 4. 修改插件配置
>     require("noice").setup({
>       -- 你的配置
>     })
>   end
> }
> ```
>
> 这就是为什么对于这种"命令式任务"，我们需要复制完整配置然后修改，而不能简单地使用 opts。因为这些操作不仅仅是配置值，而是一系列需要按特定顺序执行的命令。

虽然这不是一个好的实践方式，但仍然比你根本不使用 LazyVim 要好，因为那样你就必须从头开始编写整个配置，而不是复制和修改一个可信的来源。

> （ethan）Opts VS Config：
>
> 1. **opts - 声明式配置（Declarative Configuration）**
>
> - 定义"想要什么"（What）
> - 只关注配置的内容和最终状态
> - 多个配置会自动合并
>
> ```lua
> {
>   "telescope.nvim",
>   opts = {
>     defaults = {
>       layout_strategy = "vertical",    -- 声明：我要垂直布局
>       sorting_strategy = "ascending",  -- 声明：我要升序排序
>     }
>   }
> }
> ```
>
> 2. **config - 命令式配置（Imperative Configuration）**
>
> - 定义"怎么做"（How）
> - 关注配置的过程和步骤
> - 完全替换而非合并
>
> ```lua
> {
>   "telescope.nvim",
>   config = function()
>     -- 步骤 1: 设置按键映射
>     vim.keymap.set(...)
>     
>     -- 步骤 2: 配置插件
>     require("telescope").setup({...})
>     
>     -- 步骤 3: 注册事件
>     vim.api.nvim_create_autocmd(...)
>   end
> }
> ```

## [19.5. 实时修改 Options](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_modifying_options_in_place)

当你提供一个 opts 表时，LazyVim 对其进行的"合并"可能并不总是能达到预期效果，特别是在处理嵌套表或者你想删除而不是添加键的情况下。

这种情况下，最好将 opts 指定为一个 Lua 函数，这个函数接收两个参数，第一个参数是插件规格（plugin spec），即插件的配置对象（前面有解释），第二个参数为一个 opts 表，也就是 LazyVim 正在构建的准备传递给 config 的 Lua 表。

举例来说：

- 嵌套表的问题

  ```lua
  -- LazyVim 的默认配置
  opts = {
    servers = {
      lua_ls = {
        settings = {
          Lua = {
            diagnostics = {
              globals = { "vim" }
            }
          }
        }
      }
    }
  }
  
  -- 用户配置（想要添加一个新的 global）
  opts = {
    servers = {
      lua_ls = {
        settings = {
          Lua = {
            diagnostics = {
              globals = { "CUSTOM" }  -- 这会完全替换原来的 { "vim" }
            }
          }
        }
      }
    }
  }
  ```

- 删除键的问题：

  ```lua
  -- LazyVim 的默认配置
  opts = {
    features = {
      "completion",
      "formatting",
      "linting"
    }
  }
  
  -- 用户配置（想要移除 "formatting"）
  -- 这样实际上是创建了一个新的 features 列表（覆盖了默认配置中的表），而不是从原列表中删除元素。
  -- 如果原配置后续又添加了新功能，这种方式可能会丢失那些更新。
  opts = {
    features = {
      "completion",
      "linting"
    }
  }
  ```

为了避免这种问题，你可以：

```lua
-- 处理嵌套表
opts = function(_, opts)
  -- 在已有的 globals 基础上添加新值
  opts.servers.lua_ls.settings.Lua.diagnostics.globals = 
    vim.list_extend(
      opts.servers.lua_ls.settings.Lua.diagnostics.globals or {},
      { "CUSTOM" }
    )
end

-- 删除键
opts = function(_, opts)
  -- 从列表中删除特定项
  opts.features = vim.tbl_filter(
    function(feature) return feature ~= "formatting" end,
    opts.features
  )
end
```

使用函数式（opts）配置的主要优势是：

1. 可以访问当前的配置状态。
2. 可以执行复杂的逻辑操作。
3. 可以精确控制如何修改配置。
4. 可以使用 Lua 的所有功能（条件判断、循环等）。

总的来说，对于复杂的配置覆盖，最好使用：先 get config，再 set config（虽然对于一些简单的配置覆盖，你可以依赖 Lazyvim 为你提供的 "合并" 特性）。

## [19.6. 复杂插件示例：Telescope-live-grep-args](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_complex_plugin_example_telescope_live_grep_args)

> （ethan）这个示例确实有点复杂，本人目前用不到，暂不翻译，感兴趣的可以自行阅读原文。

## [19.7. 配置非插件选项](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_configuring_non_plugin_options)

Vim 是一个高度可配置的编辑器，而 Neovim 的可配置性更强。在 :help option-list 输出中有超过三百个选项。对于这些选项中的大多数，Vim 的默认配置已经足够好用了，不过由于历史原因，有一些选项的默认值设置得不太合理。Neovim 已经修复了其中的一些问题，而 LazyVim 更是修改了近三分之一的选项，让开箱即用的体验更符合现代开发者的需求。

不过，你可能还是想根据个人喜好修改一些选项。这些修改通常在 lua/config/options.lua 文件中完成。LazyVim 默认会加载这个文件。

对于任何选项，你都可以通过设置 vim.opt.<选项名> 来修改。vim.opt 是一个特殊的 Lua 表，让你能够像操作普通 Lua 表一样修改 Vim 的设置。如果你在（谷歌或者询问 AI）查找 Vim 设置时，看到使用 :set option=value 的说明，这种方式也能临时生效。但如果你想让设置在下次启动 Neovim 时仍然保持，你需要将其转换为 vim.opt.option = value 的形式。

有时候（即使在使用 Vim 25年后，我仍然不太确定具体是什么时候），你需要使用 vim.g.<选项名> = value 来设置。这里的 g 表示全局（global）。如果你看到指示要设置 let g:varname = value 这样的变量，你可能需要使用 vim.g.varname = value。有些选项本身就是全局的，而有些选项则默认只应用于当前缓冲区，除非你指定 g。一些插件中，特别是较老的非 Lua 插件，就是通过全局变量来配置的，这时也要使用这种语法。

一般来说，除非你在文档或要复制的代码中看到 vim.g 或 g:，否则就使用 vim.opt。

## [19.8. 设置配色方案（主题）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_setting_the_colour_scheme_theme)

Vim 有两个用于设置配色方案的选项，它们之间的互动有时会出现意想不到的效果。

首先，你可以将窗口背景设置为深色或浅色。你可以在运行时通过"Ui"菜单下的 <Space>ub 快捷键来切换这个设置。通常当你切换背景时，配色方案会相应地调整前景色以适应所选的背景，但这种调整并不总是可靠的。有时它甚至会切换到一个更适合当前背景的相关配色方案。例如，如果你启用了 catppuccin-mocha，当你将背景改为浅色时，它会自动切换到 catppuccin-latte 配色方案。

如果你想永久更改背景，可以在 options.lua 文件中设置 vim.opt.background = "light" 或 vim.opt.background = "dark"。

要完全更换配色方案，可以使用 <Space>uC（注意 C 是大写）。这会弹出一个包含所有已安装配色方案的选择器。Neovim 自带了一些默认配色方案，而 LazyVim 还添加了 Catppuccin 和 Tokyo Night（默认主题）的多个变体。这些配色方案比 Neovim 自带的更好，因为它们为 LazyVim 安装的各种插件提供了大量额外的高亮组。

如果你想永久更改配色方案，应该在 LazyVim/LazyVim 插件中设置 opt。比如我喜欢 catppuccin 配色方案，所以我的 plugins/core.lua 文件是这样的：

```lua
return {
  {
    "LazyVim/LazyVim",
    opts = {
      colorscheme = "catppuccin",
    },
  },
}
```

但是，如果你想设置一个 LazyVim 默认没有的配色方案，你还需要安装提供该配色方案的插件。例如，流行的 gruvbox 可以这样安装：

```lua
return {
  { "ellisonleao/gruvbox.nvim" },
  {
    "LazyVim/LazyVim",
    opts = {
      colorscheme = "gruvbox",
    },
  },
}
```

在寻找新的配色方案时，尽量选择那些维护良好的仓库，它们要支持"treesitter"，并为你经常使用的所有插件（包括 LazyVim 自带的）提供高亮组。你可以在 [Awesome Neovim](https://github.com/rockerBOO/awesome-neovim/) 列表中找到配色方案。

## [19.9. 延迟加载](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_lazy_loading)

LazyVim 会按需自动延迟加载插件，而不是在程序启动时就加载所有插件。这可以节省启动时间（这个珍贵的资源）。

LazyVim 知道在需要插件代码时，或者当按下 keys 数组中指定的任何快捷键时加载插件。这通常正是你想要的加载时机。但是，如果你发现某些插件无法按预期工作，可能需要调整延迟加载配置。

首先，试着在插件配置中添加 lazy = false。这样插件就会在启动时加载。如果添加后插件正常工作了，你有两个选择：

1. 就保持 lazy = false 然后继续你的工作。
2. 微调优化，尝试在正确的时机强制插件延迟加载。

大多数情况下，我建议选择第一个方案。微调优化，只有在优化公共插件时才有意义。插件维护者可能会在他们的包中使用它，当然像 Folke 这样的发行版维护者也会花很多时间在这上面。但对你来说可能不值得。

可以分别在：启用和禁用延迟加载的情况下运行插件，并在仪表板中检查启动时间。如果发现有你想解决的差异，再继续往下读（其实就是前面讲的 "触发事件"）。

如果某个插件只应该在特定文件类型下使用，那就在配置中添加 ft 键（键值对中的"键"）。这个键接受一个字符串或字符串列表来表示文件类型。（要获取当前缓冲区的文件类型，输入 :set ft<Enter>）。

如果插件只应该在调用特定命令时加载，可以在 cmd 键下指定一个包含命令名的字符串列表。

你还可以指定一个 Neovim 事件来触发插件加载。这些事件太多了，无法在本书中一一列举，所以我建议你查看 :help events。最常用的触发插件加载的事件是 BufEnter、BufRead 和 BufWrite。

## [19.10. 特定文件类型的配置](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_filetype_specific_configuration)

如果你需要为特定文件类型配置某些功能，你需要使用 nvim_create_autocmd 函数。从技术上讲，你可以在任何地方调用这个函数，包括 init.lua 或特定插件的 config、init 中，但 LazyVim 的惯例是把它们放在 lua/config/autocmds.lua 文件中。

实际上我只有一个自动命令，因为 LazyVim（通过 lang.* LazyVim Extra）已经很好地为我配置了特定（语言）文件类型的行为。这个命令是这样的：

```
vim.api.nvim_create_autocmd({ "BufRead", "BufNewFile" }, {
  pattern = "*.svx",
  command = "setlocal filetype=markdown",
})
```

第一个参数是一个包含事件名字符串的 Lua 表；在这个例子中，每当我创建或读取文件时，这个自动命令就会运行。还有其他事件可以使用，但除非你在编写自己的插件，否则大多数情况下你只需要这两个事件（完整列表请参见 :help autocmd-events）。

第二个参数包含自动命令的选项。在这个例子中，我包含了一个 pattern，这是一个用于匹配我想要的文件类型的 Vim 正则表达式。我特意说"Vim 正则表达式"是为了解释那个特殊的 * 号，就像第 12 章讨论的那样。

在这个例子中，我使用 command 键（键值对中的"键"）在读取 *.svx 文件时执行命令。你也可以指定一个 callback 键，其值是一个在事件发生时会被调用的 Lua 函数。

## [19.11. 项目特定配置](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_per_project_configuration)

有时，你可能想为特定项目使用自定义的 LazyVim 配置。例如，我的大多数 TypeScript 项目都使用 Svelte，这意味着我（暂时）不能使用出色的 biome 代码检查器/格式化工具。所以在这些仓库中我使用 prettier 来格式化代码。我的 extend-conform.lua 插件配置是这样的：

```lua
return {
  {
    "stevearc/conform.nvim",
    opts = {
      formatters_by_ft = {
        ["typescript"] = { "prettier" },
        ["markdown"] = { "prettier" },
        ["yaml"] = { "prettier" },
        ["svelte"] = { "prettier" },
      },
    },
  },
}
```

但是，对于我的 TypeScript API 服务器，我可以使用 Biome，而且我只想为这些项目覆盖我的配置。

LazyVim 让这变得非常简单：只需在你的项目中创建一个 .lazy.lua 文件。它可以返回任何有效的插件配置，并且会在其他插件加载后被调用，覆盖它们。所以我的 Hono API 服务器有一个这样的 .lazy.lua 文件：

```lua
return {
  {
    "stevearc/conform.nvim",
    opts = {
      formatters_by_ft = {
        ["typescript"] = { "biome" },
      },
    },
  },
}
```

你可以根据项目的标准选择将其提交到代码库或添加到 .gitignore 中。

## [19.12. LazyVim 配置方案](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_lazyvim_recipes)

LazyVim 在其主页上收集了一些最常见的功能需求作为配置方案。大多数方案都可以直接复制到你的 lua/plugins 文件夹中的任何文件中。记得在它们前面添加 return，这样它们提供的表就会被导出。

大多数配置方案都只是提供一组建议的 opts 来触发相关行为。这些 opts 都是特定于插件的，你需要查看插件的帮助文件或 README 来理解它们的作用。

## [19.13. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-19/#_summary_19)

本章主要讲解了 LazyVim 的配置。虽然在之前介绍各种功能时，已经提到过一些插件配置的例子，但我想把这些内容系统地整理在这一章，方便你日后查阅。

# [第20章：下一步该去哪里](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_where_to_go_next)

我们的 LazyVim 学习之旅即将结束。如果你已经看到这里了，我相信你一定会继续探索这个优秀的 Neovim 发行版的新功能。在最后这一章，我会介绍一些我最喜欢的资源，包括获取帮助、深入了解、新闻资讯和插件的地方。

## [20.1. 重读本书](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_reread_this_book)

我敢肯定,你一定忘记了本书中提到的一些有趣的细节。我之所以这么说，是因为在多次审稿重读这本书时，我自己都学到了新东西。写作的一个好处就是，它迫使我比平时更深入地去研究每个主题。

所以我建议你重读这本书，或者至少快速浏览一遍。把那些"很酷但可能记不住"的快捷键都写在一个备忘录上。我建议你手写，因为手写的东西更容易记住，而且当你学到新东西时，可以随时在桌面上做笔记。

如果你读的是纸质书或电子书，内容可能会过时。要获取最新版本，你可以访问我的官方网站 [https://lazyvim-ambitious-devs.phillips.codes](https://lazyvim-ambitious-devs.phillips.codes/) ，如果想收到更新通知，也可以订阅我的邮件列表。

## [20.2. Neovim 文档](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_the_neovim_documentation)

Vim 诞生于 1991 年，那时候并不是每个人都能上网。在那个年代，软件都会附带文档，而不是像现在这样链接到网络上的文档(实际上，万维网也是那一年诞生的)。既然你有耐心读完这整本书，不妨试试输入 :help user-manual<Enter> 从头到尾读一遍。在你使用 Vim 的职业生涯中，可能会不止一次地阅读它(输入 :help<Enter> 可以查看更多文档)。

浏览帮助文件的关键，是 Control-] 这个快捷键。文档就像维基百科一样互相链接，当你把光标放在任何粗体文字上按 Control-]，就会跳转到那个章节，就像点击链接一样。

如果你更喜欢在浏览器中阅读文档，可以在 https://neovim.io/doc/user/usr_toc.html 查看用户手册的 HTML 版本。内容和 :help 是一样的，只是更方便点击。

这个手册非常全面，涵盖了很多命令和快捷键，虽然有些可能现在不太常用了。我相信我已经介绍了现代开发者需要的所有重要内容，但我相信你一定能在里面发现更多有用的知识。

## [20.3. LazyVim 文档](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_the_lazyvim_documentation)

LazyVim 有自己的官方网站 [https://www.lazyvim.org](https://www.lazyvim.org/) 。虽然网站在新手指导方面稍显不足（这也是为什么需要这本书），但对于已经入门的用户来说，这是一个非常有价值的资源。最重要的是，它详细列出了所有内置插件和扩展的当前配置。当你想要根据个人使用习惯调整配置时，你会经常访问这些页面。每个插件都有 Options 和 Full Spec 两个标签页。Options 展示了 LazyVim 为该插件传递的配置选项，而 Full Spec 则包含了完整的配置信息。

## [20.4. LazyVim 讨论组](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_lazyvim_discussion_groups)

获取答案最快的方法（当然，除了我们在第 16 章讨论的 copilot-chat 插件之外）就是在 GitHub 的讨论组中提问。虽然我也会在那里活动，但你的问题很可能会被比我更专业的人回答。

如果你发现了 LazyVim 的问题，第一步是创建一个最小复现示例，尽可能减少插件的数量。LazyVim 的 issue 追踪器中有一个 repro.lua 模板，你可以用它来配置最小复现示例。添加相关插件后，使用 nvim -u repro.lua 来测试问题。将这个文件随问题（或讨论）一起上传，这样可以帮助维护者更容易地帮助你。

## [20.5. 寻找有趣的插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_finding_interesting_plugins)

大多数情况下，LazyVim 已经包含了同类最佳的插件。但是，如果你觉得编辑器应该有某个功能，而这个功能在扩展中找不到，你几乎一定能在 GitHub 上的 [Awesome Neovim](https://github.com/rockerBOO/awesome-neovim) 仓库中找到。

另一个很棒的资源是 [neovimcraft](https://neovimcraft.com/) 网站。顺便说一下，neovimcraft 的维护者同时也负责着 [pgs.sh](https://pgs.sh/)，也就是本书网站的托管平台。我很欣赏他们的产品，所以想为他们做个免费广告。

## [20.6. Dotfiles（配置文件）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_dotfiles)

从历史上看，配置 Vim 最简单的方法，就是查看别人的配置文件并复制自己感兴趣的部分。现在，最简单的方法是使用 LazyVim，但你可能还是想看看一些知名 Neovim 和 LazyVim 用户的配置文件：

- [Folke Lemaitre](https://github.com/folke/dot)：LazyVim 的创建者，同时也开发了许多优秀的 Neovim 插件（其中大部分都包含在 LazyVim 中）。
- [Evgeni Chasnovski](https://github.com/echasnovski/nvim/)：mini.nvim 系列插件的作者，也是 Neovim 的核心贡献者。
- [Iordanis Petkakis](https://github.com/dpetka2001/dotfiles)：在 LazyVim GitHub 讨论组中最可能回答你问题的人。
- [我自己](https://github.com/dusty-phillips/dotfiles/)：说实话，我并不配和上面这些大神相提并论！我经常更新我的配置文件，而且我对使用的插件都很挑剔，所以如果某个插件出现在我的配置中，那它应该是不错的。

这些人都值得你在各个社交网络上关注。

## [20.7. Neovim GUIs](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_neovim_guis)

我依然认为 LazyVim 在一个优秀的终端中运行效果最好，但如果你想尝试的话，也有一些非常出色的图形界面可供选择。

Neovim 图形界面的主要优势在于，它们是在像素级别而不是字符级别运行的。这意味着平滑滚动、光标移动或窗口大小调整动画可以更细腻或性能更好。一些图形界面也可以选择使用自带的缓冲区栏、状态栏或文件树，但它们通常不如 LazyVim 自带的好用。

这些年来，有很多 Neovim 图形界面的尝试，但大多数都没有得到很好的维护。我实际上已经尝试过几乎所有的图形界面，根据我的经验，以下是目前值得尝试的几个：

- [Vimr](https://github.com/qvacua/vimr)：仅支持 MacOS，它提供了一些不错的系统集成功能。
- [Neovide](https://neovide.dev/)：如果你想使用所有现有的 Neovim 插件，但又想要更流畅的动画和滚动效果，这是最好的选择。而且性能非常出色。
- [Goneovim](https://github.com/akiyosi/goneovim)：也是一个很好的选择。
- [FVim](https://github.com/yatli/fvim)：曾经是我的最爱，但最近维护频率下降了，而且在 MacOS 上有一些怪异的问题，可能很快就会从这个列表中移除。

如果你准备使用这些图形界面，那你可能还要寻找一些能改善内嵌 Neovim 集成终端体验的插件。

## [20.8. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-20/#_summary_20)

这是一个简短的章节，总结了一些在 LazyVim 和 Neovim 学习之旅时可能有用的资源。

我要感谢你坚持读到最后。希望你喜欢这本书！如果你和我一样，可能在未来的几十年中，都会继续使用模态编辑。

总有一天 Neovim 也会变成 "老 Vim"，但我非常相信，指导它的"原则/理念"，在这个编辑器的未来版本中依然会保持重要的地位。

各位，编码愉快！

